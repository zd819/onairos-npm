(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Onairos = {}));
})(this, (function (exports) { 'use strict';

	function _mergeNamespaces(n, m) {
		m.forEach(function (e) {
			e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
				if (k !== 'default' && !(k in n)) {
					var d = Object.getOwnPropertyDescriptor(e, k);
					Object.defineProperty(n, k, d.get ? d : {
						enumerable: true,
						get: function () { return e[k]; }
					});
				}
			});
		});
		return Object.freeze(n);
	}

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function getDefaultExportFromNamespaceIfNotNamed (n) {
		return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
	}

	var browser = {exports: {}};

	var hasRequiredBrowser;

	function requireBrowser () {
		if (hasRequiredBrowser) return browser.exports;
		hasRequiredBrowser = 1;
		// shim for using process in browser
		var process = browser.exports = {};

		// cached from whatever global is present so that test runners that stub it
		// don't break things.  But we need to wrap it in a try catch in case it is
		// wrapped in strict mode code which doesn't define any globals.  It's inside a
		// function because try/catches deoptimize in certain engines.

		var cachedSetTimeout;
		var cachedClearTimeout;
		function defaultSetTimout() {
		  throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout() {
		  throw new Error('clearTimeout has not been defined');
		}
		(function () {
		  try {
		    if (typeof setTimeout === 'function') {
		      cachedSetTimeout = setTimeout;
		    } else {
		      cachedSetTimeout = defaultSetTimout;
		    }
		  } catch (e) {
		    cachedSetTimeout = defaultSetTimout;
		  }
		  try {
		    if (typeof clearTimeout === 'function') {
		      cachedClearTimeout = clearTimeout;
		    } else {
		      cachedClearTimeout = defaultClearTimeout;
		    }
		  } catch (e) {
		    cachedClearTimeout = defaultClearTimeout;
		  }
		})();
		function runTimeout(fun) {
		  if (cachedSetTimeout === setTimeout) {
		    //normal enviroments in sane situations
		    return setTimeout(fun, 0);
		  }
		  // if setTimeout wasn't available but was latter defined
		  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
		    cachedSetTimeout = setTimeout;
		    return setTimeout(fun, 0);
		  }
		  try {
		    // when when somebody has screwed with setTimeout but no I.E. maddness
		    return cachedSetTimeout(fun, 0);
		  } catch (e) {
		    try {
		      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
		      return cachedSetTimeout.call(null, fun, 0);
		    } catch (e) {
		      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
		      return cachedSetTimeout.call(this, fun, 0);
		    }
		  }
		}
		function runClearTimeout(marker) {
		  if (cachedClearTimeout === clearTimeout) {
		    //normal enviroments in sane situations
		    return clearTimeout(marker);
		  }
		  // if clearTimeout wasn't available but was latter defined
		  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
		    cachedClearTimeout = clearTimeout;
		    return clearTimeout(marker);
		  }
		  try {
		    // when when somebody has screwed with setTimeout but no I.E. maddness
		    return cachedClearTimeout(marker);
		  } catch (e) {
		    try {
		      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
		      return cachedClearTimeout.call(null, marker);
		    } catch (e) {
		      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
		      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
		      return cachedClearTimeout.call(this, marker);
		    }
		  }
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		function cleanUpNextTick() {
		  if (!draining || !currentQueue) {
		    return;
		  }
		  draining = false;
		  if (currentQueue.length) {
		    queue = currentQueue.concat(queue);
		  } else {
		    queueIndex = -1;
		  }
		  if (queue.length) {
		    drainQueue();
		  }
		}
		function drainQueue() {
		  if (draining) {
		    return;
		  }
		  var timeout = runTimeout(cleanUpNextTick);
		  draining = true;
		  var len = queue.length;
		  while (len) {
		    currentQueue = queue;
		    queue = [];
		    while (++queueIndex < len) {
		      if (currentQueue) {
		        currentQueue[queueIndex].run();
		      }
		    }
		    queueIndex = -1;
		    len = queue.length;
		  }
		  currentQueue = null;
		  draining = false;
		  runClearTimeout(timeout);
		}
		process.nextTick = function (fun) {
		  var args = new Array(arguments.length - 1);
		  if (arguments.length > 1) {
		    for (var i = 1; i < arguments.length; i++) {
		      args[i - 1] = arguments[i];
		    }
		  }
		  queue.push(new Item(fun, args));
		  if (queue.length === 1 && !draining) {
		    runTimeout(drainQueue);
		  }
		};

		// v8 likes predictible objects
		function Item(fun, array) {
		  this.fun = fun;
		  this.array = array;
		}
		Item.prototype.run = function () {
		  this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		function noop() {}
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;
		process.listeners = function (name) {
		  return [];
		};
		process.binding = function (name) {
		  throw new Error('process.binding is not supported');
		};
		process.cwd = function () {
		  return '/';
		};
		process.chdir = function (dir) {
		  throw new Error('process.chdir is not supported');
		};
		process.umask = function () {
		  return 0;
		};
		return browser.exports;
	}

	var browserExports = requireBrowser();
	var process = /*@__PURE__*/getDefaultExportFromCjs(browserExports);

	var react = {exports: {}};

	var react_production_min = {};

	/**
	 * @license React
	 * react.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReact_production_min;

	function requireReact_production_min () {
		if (hasRequiredReact_production_min) return react_production_min;
		hasRequiredReact_production_min = 1;

		var l = Symbol.for("react.element"),
		  n = Symbol.for("react.portal"),
		  p = Symbol.for("react.fragment"),
		  q = Symbol.for("react.strict_mode"),
		  r = Symbol.for("react.profiler"),
		  t = Symbol.for("react.provider"),
		  u = Symbol.for("react.context"),
		  v = Symbol.for("react.forward_ref"),
		  w = Symbol.for("react.suspense"),
		  x = Symbol.for("react.memo"),
		  y = Symbol.for("react.lazy"),
		  z = Symbol.iterator;
		function A(a) {
		  if (null === a || "object" !== typeof a) return null;
		  a = z && a[z] || a["@@iterator"];
		  return "function" === typeof a ? a : null;
		}
		var B = {
		    isMounted: function () {
		      return !1;
		    },
		    enqueueForceUpdate: function () {},
		    enqueueReplaceState: function () {},
		    enqueueSetState: function () {}
		  },
		  C = Object.assign,
		  D = {};
		function E(a, b, e) {
		  this.props = a;
		  this.context = b;
		  this.refs = D;
		  this.updater = e || B;
		}
		E.prototype.isReactComponent = {};
		E.prototype.setState = function (a, b) {
		  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
		  this.updater.enqueueSetState(this, a, b, "setState");
		};
		E.prototype.forceUpdate = function (a) {
		  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
		};
		function F() {}
		F.prototype = E.prototype;
		function G(a, b, e) {
		  this.props = a;
		  this.context = b;
		  this.refs = D;
		  this.updater = e || B;
		}
		var H = G.prototype = new F();
		H.constructor = G;
		C(H, E.prototype);
		H.isPureReactComponent = !0;
		var I = Array.isArray,
		  J = Object.prototype.hasOwnProperty,
		  K = {
		    current: null
		  },
		  L = {
		    key: !0,
		    ref: !0,
		    __self: !0,
		    __source: !0
		  };
		function M(a, b, e) {
		  var d,
		    c = {},
		    k = null,
		    h = null;
		  if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
		  var g = arguments.length - 2;
		  if (1 === g) c.children = e;else if (1 < g) {
		    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
		    c.children = f;
		  }
		  if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
		  return {
		    $$typeof: l,
		    type: a,
		    key: k,
		    ref: h,
		    props: c,
		    _owner: K.current
		  };
		}
		function N(a, b) {
		  return {
		    $$typeof: l,
		    type: a.type,
		    key: b,
		    ref: a.ref,
		    props: a.props,
		    _owner: a._owner
		  };
		}
		function O(a) {
		  return "object" === typeof a && null !== a && a.$$typeof === l;
		}
		function escape(a) {
		  var b = {
		    "=": "=0",
		    ":": "=2"
		  };
		  return "$" + a.replace(/[=:]/g, function (a) {
		    return b[a];
		  });
		}
		var P = /\/+/g;
		function Q(a, b) {
		  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
		}
		function R(a, b, e, d, c) {
		  var k = typeof a;
		  if ("undefined" === k || "boolean" === k) a = null;
		  var h = !1;
		  if (null === a) h = !0;else switch (k) {
		    case "string":
		    case "number":
		      h = !0;
		      break;
		    case "object":
		      switch (a.$$typeof) {
		        case l:
		        case n:
		          h = !0;
		      }
		  }
		  if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function (a) {
		    return a;
		  })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
		  h = 0;
		  d = "" === d ? "." : d + ":";
		  if (I(a)) for (var g = 0; g < a.length; g++) {
		    k = a[g];
		    var f = d + Q(k, g);
		    h += R(k, b, e, f, c);
		  } else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
		  return h;
		}
		function S(a, b, e) {
		  if (null == a) return a;
		  var d = [],
		    c = 0;
		  R(a, d, "", "", function (a) {
		    return b.call(e, a, c++);
		  });
		  return d;
		}
		function T(a) {
		  if (-1 === a._status) {
		    var b = a._result;
		    b = b();
		    b.then(function (b) {
		      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
		    }, function (b) {
		      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
		    });
		    -1 === a._status && (a._status = 0, a._result = b);
		  }
		  if (1 === a._status) return a._result.default;
		  throw a._result;
		}
		var U = {
		    current: null
		  },
		  V = {
		    transition: null
		  },
		  W = {
		    ReactCurrentDispatcher: U,
		    ReactCurrentBatchConfig: V,
		    ReactCurrentOwner: K
		  };
		react_production_min.Children = {
		  map: S,
		  forEach: function (a, b, e) {
		    S(a, function () {
		      b.apply(this, arguments);
		    }, e);
		  },
		  count: function (a) {
		    var b = 0;
		    S(a, function () {
		      b++;
		    });
		    return b;
		  },
		  toArray: function (a) {
		    return S(a, function (a) {
		      return a;
		    }) || [];
		  },
		  only: function (a) {
		    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
		    return a;
		  }
		};
		react_production_min.Component = E;
		react_production_min.Fragment = p;
		react_production_min.Profiler = r;
		react_production_min.PureComponent = G;
		react_production_min.StrictMode = q;
		react_production_min.Suspense = w;
		react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
		react_production_min.cloneElement = function (a, b, e) {
		  if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
		  var d = C({}, a.props),
		    c = a.key,
		    k = a.ref,
		    h = a._owner;
		  if (null != b) {
		    void 0 !== b.ref && (k = b.ref, h = K.current);
		    void 0 !== b.key && (c = "" + b.key);
		    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
		    for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
		  }
		  var f = arguments.length - 2;
		  if (1 === f) d.children = e;else if (1 < f) {
		    g = Array(f);
		    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
		    d.children = g;
		  }
		  return {
		    $$typeof: l,
		    type: a.type,
		    key: c,
		    ref: k,
		    props: d,
		    _owner: h
		  };
		};
		react_production_min.createContext = function (a) {
		  a = {
		    $$typeof: u,
		    _currentValue: a,
		    _currentValue2: a,
		    _threadCount: 0,
		    Provider: null,
		    Consumer: null,
		    _defaultValue: null,
		    _globalName: null
		  };
		  a.Provider = {
		    $$typeof: t,
		    _context: a
		  };
		  return a.Consumer = a;
		};
		react_production_min.createElement = M;
		react_production_min.createFactory = function (a) {
		  var b = M.bind(null, a);
		  b.type = a;
		  return b;
		};
		react_production_min.createRef = function () {
		  return {
		    current: null
		  };
		};
		react_production_min.forwardRef = function (a) {
		  return {
		    $$typeof: v,
		    render: a
		  };
		};
		react_production_min.isValidElement = O;
		react_production_min.lazy = function (a) {
		  return {
		    $$typeof: y,
		    _payload: {
		      _status: -1,
		      _result: a
		    },
		    _init: T
		  };
		};
		react_production_min.memo = function (a, b) {
		  return {
		    $$typeof: x,
		    type: a,
		    compare: void 0 === b ? null : b
		  };
		};
		react_production_min.startTransition = function (a) {
		  var b = V.transition;
		  V.transition = {};
		  try {
		    a();
		  } finally {
		    V.transition = b;
		  }
		};
		react_production_min.unstable_act = function () {
		  throw Error("act(...) is not supported in production builds of React.");
		};
		react_production_min.useCallback = function (a, b) {
		  return U.current.useCallback(a, b);
		};
		react_production_min.useContext = function (a) {
		  return U.current.useContext(a);
		};
		react_production_min.useDebugValue = function () {};
		react_production_min.useDeferredValue = function (a) {
		  return U.current.useDeferredValue(a);
		};
		react_production_min.useEffect = function (a, b) {
		  return U.current.useEffect(a, b);
		};
		react_production_min.useId = function () {
		  return U.current.useId();
		};
		react_production_min.useImperativeHandle = function (a, b, e) {
		  return U.current.useImperativeHandle(a, b, e);
		};
		react_production_min.useInsertionEffect = function (a, b) {
		  return U.current.useInsertionEffect(a, b);
		};
		react_production_min.useLayoutEffect = function (a, b) {
		  return U.current.useLayoutEffect(a, b);
		};
		react_production_min.useMemo = function (a, b) {
		  return U.current.useMemo(a, b);
		};
		react_production_min.useReducer = function (a, b, e) {
		  return U.current.useReducer(a, b, e);
		};
		react_production_min.useRef = function (a) {
		  return U.current.useRef(a);
		};
		react_production_min.useState = function (a) {
		  return U.current.useState(a);
		};
		react_production_min.useSyncExternalStore = function (a, b, e) {
		  return U.current.useSyncExternalStore(a, b, e);
		};
		react_production_min.useTransition = function () {
		  return U.current.useTransition();
		};
		react_production_min.version = "18.2.0";
		return react_production_min;
	}

	var react_development = {exports: {}};

	react_development.exports;

	var hasRequiredReact_development;

	function requireReact_development () {
		if (hasRequiredReact_development) return react_development.exports;
		hasRequiredReact_development = 1;
		(function (module, exports) {

			if (process.env.NODE_ENV !== "production") {
			  (function () {

			    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
			    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {
			      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
			    }
			    var ReactVersion = '18.2.0';

			    // ATTENTION
			    // When adding new symbols to this file,
			    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
			    // The Symbol used to tag the ReactElement-like types.
			    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
			    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
			    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
			    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
			    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
			    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
			    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
			    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
			    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
			    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
			    var REACT_MEMO_TYPE = Symbol.for('react.memo');
			    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
			    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
			    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
			    var FAUX_ITERATOR_SYMBOL = '@@iterator';
			    function getIteratorFn(maybeIterable) {
			      if (maybeIterable === null || typeof maybeIterable !== 'object') {
			        return null;
			      }
			      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
			      if (typeof maybeIterator === 'function') {
			        return maybeIterator;
			      }
			      return null;
			    }

			    /**
			     * Keeps track of the current dispatcher.
			     */
			    var ReactCurrentDispatcher = {
			      /**
			       * @internal
			       * @type {ReactComponent}
			       */
			      current: null
			    };

			    /**
			     * Keeps track of the current batch's configuration such as how long an update
			     * should suspend for if it needs to.
			     */
			    var ReactCurrentBatchConfig = {
			      transition: null
			    };
			    var ReactCurrentActQueue = {
			      current: null,
			      // Used to reproduce behavior of `batchedUpdates` in legacy mode.
			      isBatchingLegacy: false,
			      didScheduleLegacyUpdate: false
			    };

			    /**
			     * Keeps track of the current owner.
			     *
			     * The current owner is the component who should own any components that are
			     * currently being constructed.
			     */
			    var ReactCurrentOwner = {
			      /**
			       * @internal
			       * @type {ReactComponent}
			       */
			      current: null
			    };
			    var ReactDebugCurrentFrame = {};
			    var currentExtraStackFrame = null;
			    function setExtraStackFrame(stack) {
			      {
			        currentExtraStackFrame = stack;
			      }
			    }
			    {
			      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
			        {
			          currentExtraStackFrame = stack;
			        }
			      }; // Stack implementation injected by the current renderer.

			      ReactDebugCurrentFrame.getCurrentStack = null;
			      ReactDebugCurrentFrame.getStackAddendum = function () {
			        var stack = ''; // Add an extra top frame while an element is being validated

			        if (currentExtraStackFrame) {
			          stack += currentExtraStackFrame;
			        } // Delegate to the injected renderer-specific implementation

			        var impl = ReactDebugCurrentFrame.getCurrentStack;
			        if (impl) {
			          stack += impl() || '';
			        }
			        return stack;
			      };
			    }

			    // -----------------------------------------------------------------------------

			    var enableScopeAPI = false; // Experimental Create Event Handle API.
			    var enableCacheElement = false;
			    var enableTransitionTracing = false; // No known bugs, but needs performance testing

			    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
			    // stuff. Intended to enable React core members to more easily debug scheduling
			    // issues in DEV builds.

			    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

			    var ReactSharedInternals = {
			      ReactCurrentDispatcher: ReactCurrentDispatcher,
			      ReactCurrentBatchConfig: ReactCurrentBatchConfig,
			      ReactCurrentOwner: ReactCurrentOwner
			    };
			    {
			      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
			      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
			    }

			    // by calls to these methods by a Babel plugin.
			    //
			    // In PROD (or in packages without access to React internals),
			    // they are left as they are instead.

			    function warn(format) {
			      {
			        {
			          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			            args[_key - 1] = arguments[_key];
			          }
			          printWarning('warn', format, args);
			        }
			      }
			    }
			    function error(format) {
			      {
			        {
			          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
			            args[_key2 - 1] = arguments[_key2];
			          }
			          printWarning('error', format, args);
			        }
			      }
			    }
			    function printWarning(level, format, args) {
			      // When changing this logic, you might want to also
			      // update consoleWithStackDev.www.js as well.
			      {
			        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
			        var stack = ReactDebugCurrentFrame.getStackAddendum();
			        if (stack !== '') {
			          format += '%s';
			          args = args.concat([stack]);
			        } // eslint-disable-next-line react-internal/safe-string-coercion

			        var argsWithFormat = args.map(function (item) {
			          return String(item);
			        }); // Careful: RN currently depends on this prefix

			        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
			        // breaks IE9: https://github.com/facebook/react/issues/13610
			        // eslint-disable-next-line react-internal/no-production-logging

			        Function.prototype.apply.call(console[level], console, argsWithFormat);
			      }
			    }
			    var didWarnStateUpdateForUnmountedComponent = {};
			    function warnNoop(publicInstance, callerName) {
			      {
			        var _constructor = publicInstance.constructor;
			        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
			        var warningKey = componentName + "." + callerName;
			        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
			          return;
			        }
			        error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
			        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
			      }
			    }
			    /**
			     * This is the abstract API for an update queue.
			     */

			    var ReactNoopUpdateQueue = {
			      /**
			       * Checks whether or not this composite component is mounted.
			       * @param {ReactClass} publicInstance The instance we want to test.
			       * @return {boolean} True if mounted, false otherwise.
			       * @protected
			       * @final
			       */
			      isMounted: function (publicInstance) {
			        return false;
			      },
			      /**
			       * Forces an update. This should only be invoked when it is known with
			       * certainty that we are **not** in a DOM transaction.
			       *
			       * You may want to call this when you know that some deeper aspect of the
			       * component's state has changed but `setState` was not called.
			       *
			       * This will not invoke `shouldComponentUpdate`, but it will invoke
			       * `componentWillUpdate` and `componentDidUpdate`.
			       *
			       * @param {ReactClass} publicInstance The instance that should rerender.
			       * @param {?function} callback Called after component is updated.
			       * @param {?string} callerName name of the calling function in the public API.
			       * @internal
			       */
			      enqueueForceUpdate: function (publicInstance, callback, callerName) {
			        warnNoop(publicInstance, 'forceUpdate');
			      },
			      /**
			       * Replaces all of the state. Always use this or `setState` to mutate state.
			       * You should treat `this.state` as immutable.
			       *
			       * There is no guarantee that `this.state` will be immediately updated, so
			       * accessing `this.state` after calling this method may return the old value.
			       *
			       * @param {ReactClass} publicInstance The instance that should rerender.
			       * @param {object} completeState Next state.
			       * @param {?function} callback Called after component is updated.
			       * @param {?string} callerName name of the calling function in the public API.
			       * @internal
			       */
			      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
			        warnNoop(publicInstance, 'replaceState');
			      },
			      /**
			       * Sets a subset of the state. This only exists because _pendingState is
			       * internal. This provides a merging strategy that is not available to deep
			       * properties which is confusing. TODO: Expose pendingState or don't use it
			       * during the merge.
			       *
			       * @param {ReactClass} publicInstance The instance that should rerender.
			       * @param {object} partialState Next partial state to be merged with state.
			       * @param {?function} callback Called after component is updated.
			       * @param {?string} Name of the calling function in the public API.
			       * @internal
			       */
			      enqueueSetState: function (publicInstance, partialState, callback, callerName) {
			        warnNoop(publicInstance, 'setState');
			      }
			    };
			    var assign = Object.assign;
			    var emptyObject = {};
			    {
			      Object.freeze(emptyObject);
			    }
			    /**
			     * Base class helpers for the updating state of a component.
			     */

			    function Component(props, context, updater) {
			      this.props = props;
			      this.context = context; // If a component has string refs, we will assign a different object later.

			      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
			      // renderer.

			      this.updater = updater || ReactNoopUpdateQueue;
			    }
			    Component.prototype.isReactComponent = {};
			    /**
			     * Sets a subset of the state. Always use this to mutate
			     * state. You should treat `this.state` as immutable.
			     *
			     * There is no guarantee that `this.state` will be immediately updated, so
			     * accessing `this.state` after calling this method may return the old value.
			     *
			     * There is no guarantee that calls to `setState` will run synchronously,
			     * as they may eventually be batched together.  You can provide an optional
			     * callback that will be executed when the call to setState is actually
			     * completed.
			     *
			     * When a function is provided to setState, it will be called at some point in
			     * the future (not synchronously). It will be called with the up to date
			     * component arguments (state, props, context). These values can be different
			     * from this.* because your function may be called after receiveProps but before
			     * shouldComponentUpdate, and this new state, props, and context will not yet be
			     * assigned to this.
			     *
			     * @param {object|function} partialState Next partial state or function to
			     *        produce next partial state to be merged with current state.
			     * @param {?function} callback Called after state is updated.
			     * @final
			     * @protected
			     */

			    Component.prototype.setState = function (partialState, callback) {
			      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
			        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
			      }
			      this.updater.enqueueSetState(this, partialState, callback, 'setState');
			    };
			    /**
			     * Forces an update. This should only be invoked when it is known with
			     * certainty that we are **not** in a DOM transaction.
			     *
			     * You may want to call this when you know that some deeper aspect of the
			     * component's state has changed but `setState` was not called.
			     *
			     * This will not invoke `shouldComponentUpdate`, but it will invoke
			     * `componentWillUpdate` and `componentDidUpdate`.
			     *
			     * @param {?function} callback Called after update is complete.
			     * @final
			     * @protected
			     */

			    Component.prototype.forceUpdate = function (callback) {
			      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
			    };
			    /**
			     * Deprecated APIs. These APIs used to exist on classic React classes but since
			     * we would like to deprecate them, we're not going to move them over to this
			     * modern base class. Instead, we define a getter that warns if it's accessed.
			     */

			    {
			      var deprecatedAPIs = {
			        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
			        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
			      };
			      var defineDeprecationWarning = function (methodName, info) {
			        Object.defineProperty(Component.prototype, methodName, {
			          get: function () {
			            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
			            return undefined;
			          }
			        });
			      };
			      for (var fnName in deprecatedAPIs) {
			        if (deprecatedAPIs.hasOwnProperty(fnName)) {
			          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
			        }
			      }
			    }
			    function ComponentDummy() {}
			    ComponentDummy.prototype = Component.prototype;
			    /**
			     * Convenience component with default shallow equality check for sCU.
			     */

			    function PureComponent(props, context, updater) {
			      this.props = props;
			      this.context = context; // If a component has string refs, we will assign a different object later.

			      this.refs = emptyObject;
			      this.updater = updater || ReactNoopUpdateQueue;
			    }
			    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
			    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

			    assign(pureComponentPrototype, Component.prototype);
			    pureComponentPrototype.isPureReactComponent = true;

			    // an immutable object with a single mutable value
			    function createRef() {
			      var refObject = {
			        current: null
			      };
			      {
			        Object.seal(refObject);
			      }
			      return refObject;
			    }
			    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

			    function isArray(a) {
			      return isArrayImpl(a);
			    }

			    /*
			     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
			     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
			     *
			     * The functions in this module will throw an easier-to-understand,
			     * easier-to-debug exception with a clear errors message message explaining the
			     * problem. (Instead of a confusing exception thrown inside the implementation
			     * of the `value` object).
			     */
			    // $FlowFixMe only called in DEV, so void return is not possible.
			    function typeName(value) {
			      {
			        // toStringTag is needed for namespaced types like Temporal.Instant
			        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
			        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
			        return type;
			      }
			    } // $FlowFixMe only called in DEV, so void return is not possible.

			    function willCoercionThrow(value) {
			      {
			        try {
			          testStringCoercion(value);
			          return false;
			        } catch (e) {
			          return true;
			        }
			      }
			    }
			    function testStringCoercion(value) {
			      // If you ended up here by following an exception call stack, here's what's
			      // happened: you supplied an object or symbol value to React (as a prop, key,
			      // DOM attribute, CSS property, string ref, etc.) and when React tried to
			      // coerce it to a string using `'' + value`, an exception was thrown.
			      //
			      // The most common types that will cause this exception are `Symbol` instances
			      // and Temporal objects like `Temporal.Instant`. But any object that has a
			      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
			      // exception. (Library authors do this to prevent users from using built-in
			      // numeric operators like `+` or comparison operators like `>=` because custom
			      // methods are needed to perform accurate arithmetic or comparison.)
			      //
			      // To fix the problem, coerce this object or symbol value to a string before
			      // passing it to React. The most reliable way is usually `String(value)`.
			      //
			      // To find which value is throwing, check the browser or debugger console.
			      // Before this exception was thrown, there should be `console.error` output
			      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
			      // problem and how that type was used: key, atrribute, input value prop, etc.
			      // In most cases, this console output also shows the component and its
			      // ancestor components where the exception happened.
			      //
			      // eslint-disable-next-line react-internal/safe-string-coercion
			      return '' + value;
			    }
			    function checkKeyStringCoercion(value) {
			      {
			        if (willCoercionThrow(value)) {
			          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
			          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
			        }
			      }
			    }
			    function getWrappedName(outerType, innerType, wrapperName) {
			      var displayName = outerType.displayName;
			      if (displayName) {
			        return displayName;
			      }
			      var functionName = innerType.displayName || innerType.name || '';
			      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
			    } // Keep in sync with react-reconciler/getComponentNameFromFiber

			    function getContextName(type) {
			      return type.displayName || 'Context';
			    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

			    function getComponentNameFromType(type) {
			      if (type == null) {
			        // Host root, text node or just invalid type.
			        return null;
			      }
			      {
			        if (typeof type.tag === 'number') {
			          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
			        }
			      }
			      if (typeof type === 'function') {
			        return type.displayName || type.name || null;
			      }
			      if (typeof type === 'string') {
			        return type;
			      }
			      switch (type) {
			        case REACT_FRAGMENT_TYPE:
			          return 'Fragment';
			        case REACT_PORTAL_TYPE:
			          return 'Portal';
			        case REACT_PROFILER_TYPE:
			          return 'Profiler';
			        case REACT_STRICT_MODE_TYPE:
			          return 'StrictMode';
			        case REACT_SUSPENSE_TYPE:
			          return 'Suspense';
			        case REACT_SUSPENSE_LIST_TYPE:
			          return 'SuspenseList';
			      }
			      if (typeof type === 'object') {
			        switch (type.$$typeof) {
			          case REACT_CONTEXT_TYPE:
			            var context = type;
			            return getContextName(context) + '.Consumer';
			          case REACT_PROVIDER_TYPE:
			            var provider = type;
			            return getContextName(provider._context) + '.Provider';
			          case REACT_FORWARD_REF_TYPE:
			            return getWrappedName(type, type.render, 'ForwardRef');
			          case REACT_MEMO_TYPE:
			            var outerName = type.displayName || null;
			            if (outerName !== null) {
			              return outerName;
			            }
			            return getComponentNameFromType(type.type) || 'Memo';
			          case REACT_LAZY_TYPE:
			            {
			              var lazyComponent = type;
			              var payload = lazyComponent._payload;
			              var init = lazyComponent._init;
			              try {
			                return getComponentNameFromType(init(payload));
			              } catch (x) {
			                return null;
			              }
			            }

			          // eslint-disable-next-line no-fallthrough
			        }
			      }
			      return null;
			    }
			    var hasOwnProperty = Object.prototype.hasOwnProperty;
			    var RESERVED_PROPS = {
			      key: true,
			      ref: true,
			      __self: true,
			      __source: true
			    };
			    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
			    {
			      didWarnAboutStringRefs = {};
			    }
			    function hasValidRef(config) {
			      {
			        if (hasOwnProperty.call(config, 'ref')) {
			          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
			          if (getter && getter.isReactWarning) {
			            return false;
			          }
			        }
			      }
			      return config.ref !== undefined;
			    }
			    function hasValidKey(config) {
			      {
			        if (hasOwnProperty.call(config, 'key')) {
			          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
			          if (getter && getter.isReactWarning) {
			            return false;
			          }
			        }
			      }
			      return config.key !== undefined;
			    }
			    function defineKeyPropWarningGetter(props, displayName) {
			      var warnAboutAccessingKey = function () {
			        {
			          if (!specialPropKeyWarningShown) {
			            specialPropKeyWarningShown = true;
			            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
			          }
			        }
			      };
			      warnAboutAccessingKey.isReactWarning = true;
			      Object.defineProperty(props, 'key', {
			        get: warnAboutAccessingKey,
			        configurable: true
			      });
			    }
			    function defineRefPropWarningGetter(props, displayName) {
			      var warnAboutAccessingRef = function () {
			        {
			          if (!specialPropRefWarningShown) {
			            specialPropRefWarningShown = true;
			            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
			          }
			        }
			      };
			      warnAboutAccessingRef.isReactWarning = true;
			      Object.defineProperty(props, 'ref', {
			        get: warnAboutAccessingRef,
			        configurable: true
			      });
			    }
			    function warnIfStringRefCannotBeAutoConverted(config) {
			      {
			        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
			          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
			          if (!didWarnAboutStringRefs[componentName]) {
			            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
			            didWarnAboutStringRefs[componentName] = true;
			          }
			        }
			      }
			    }
			    /**
			     * Factory method to create a new React element. This no longer adheres to
			     * the class pattern, so do not use new to call it. Also, instanceof check
			     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
			     * if something is a React Element.
			     *
			     * @param {*} type
			     * @param {*} props
			     * @param {*} key
			     * @param {string|object} ref
			     * @param {*} owner
			     * @param {*} self A *temporary* helper to detect places where `this` is
			     * different from the `owner` when React.createElement is called, so that we
			     * can warn. We want to get rid of owner and replace string `ref`s with arrow
			     * functions, and as long as `this` and owner are the same, there will be no
			     * change in behavior.
			     * @param {*} source An annotation object (added by a transpiler or otherwise)
			     * indicating filename, line number, and/or other information.
			     * @internal
			     */

			    var ReactElement = function (type, key, ref, self, source, owner, props) {
			      var element = {
			        // This tag allows us to uniquely identify this as a React Element
			        $$typeof: REACT_ELEMENT_TYPE,
			        // Built-in properties that belong on the element
			        type: type,
			        key: key,
			        ref: ref,
			        props: props,
			        // Record the component responsible for creating this element.
			        _owner: owner
			      };
			      {
			        // The validation flag is currently mutative. We put it on
			        // an external backing store so that we can freeze the whole object.
			        // This can be replaced with a WeakMap once they are implemented in
			        // commonly used development environments.
			        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
			        // the validation flag non-enumerable (where possible, which should
			        // include every environment we run tests in), so the test framework
			        // ignores it.

			        Object.defineProperty(element._store, 'validated', {
			          configurable: false,
			          enumerable: false,
			          writable: true,
			          value: false
			        }); // self and source are DEV only properties.

			        Object.defineProperty(element, '_self', {
			          configurable: false,
			          enumerable: false,
			          writable: false,
			          value: self
			        }); // Two elements created in two different places should be considered
			        // equal for testing purposes and therefore we hide it from enumeration.

			        Object.defineProperty(element, '_source', {
			          configurable: false,
			          enumerable: false,
			          writable: false,
			          value: source
			        });
			        if (Object.freeze) {
			          Object.freeze(element.props);
			          Object.freeze(element);
			        }
			      }
			      return element;
			    };
			    /**
			     * Create and return a new ReactElement of the given type.
			     * See https://reactjs.org/docs/react-api.html#createelement
			     */

			    function createElement(type, config, children) {
			      var propName; // Reserved names are extracted

			      var props = {};
			      var key = null;
			      var ref = null;
			      var self = null;
			      var source = null;
			      if (config != null) {
			        if (hasValidRef(config)) {
			          ref = config.ref;
			          {
			            warnIfStringRefCannotBeAutoConverted(config);
			          }
			        }
			        if (hasValidKey(config)) {
			          {
			            checkKeyStringCoercion(config.key);
			          }
			          key = '' + config.key;
			        }
			        self = config.__self === undefined ? null : config.__self;
			        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

			        for (propName in config) {
			          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
			            props[propName] = config[propName];
			          }
			        }
			      } // Children can be more than one argument, and those are transferred onto
			      // the newly allocated props object.

			      var childrenLength = arguments.length - 2;
			      if (childrenLength === 1) {
			        props.children = children;
			      } else if (childrenLength > 1) {
			        var childArray = Array(childrenLength);
			        for (var i = 0; i < childrenLength; i++) {
			          childArray[i] = arguments[i + 2];
			        }
			        {
			          if (Object.freeze) {
			            Object.freeze(childArray);
			          }
			        }
			        props.children = childArray;
			      } // Resolve default props

			      if (type && type.defaultProps) {
			        var defaultProps = type.defaultProps;
			        for (propName in defaultProps) {
			          if (props[propName] === undefined) {
			            props[propName] = defaultProps[propName];
			          }
			        }
			      }
			      {
			        if (key || ref) {
			          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
			          if (key) {
			            defineKeyPropWarningGetter(props, displayName);
			          }
			          if (ref) {
			            defineRefPropWarningGetter(props, displayName);
			          }
			        }
			      }
			      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
			    }
			    function cloneAndReplaceKey(oldElement, newKey) {
			      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
			      return newElement;
			    }
			    /**
			     * Clone and return a new ReactElement using element as the starting point.
			     * See https://reactjs.org/docs/react-api.html#cloneelement
			     */

			    function cloneElement(element, config, children) {
			      if (element === null || element === undefined) {
			        throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
			      }
			      var propName; // Original props are copied

			      var props = assign({}, element.props); // Reserved names are extracted

			      var key = element.key;
			      var ref = element.ref; // Self is preserved since the owner is preserved.

			      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
			      // transpiler, and the original source is probably a better indicator of the
			      // true owner.

			      var source = element._source; // Owner will be preserved, unless ref is overridden

			      var owner = element._owner;
			      if (config != null) {
			        if (hasValidRef(config)) {
			          // Silently steal the ref from the parent.
			          ref = config.ref;
			          owner = ReactCurrentOwner.current;
			        }
			        if (hasValidKey(config)) {
			          {
			            checkKeyStringCoercion(config.key);
			          }
			          key = '' + config.key;
			        } // Remaining properties override existing props

			        var defaultProps;
			        if (element.type && element.type.defaultProps) {
			          defaultProps = element.type.defaultProps;
			        }
			        for (propName in config) {
			          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
			            if (config[propName] === undefined && defaultProps !== undefined) {
			              // Resolve default props
			              props[propName] = defaultProps[propName];
			            } else {
			              props[propName] = config[propName];
			            }
			          }
			        }
			      } // Children can be more than one argument, and those are transferred onto
			      // the newly allocated props object.

			      var childrenLength = arguments.length - 2;
			      if (childrenLength === 1) {
			        props.children = children;
			      } else if (childrenLength > 1) {
			        var childArray = Array(childrenLength);
			        for (var i = 0; i < childrenLength; i++) {
			          childArray[i] = arguments[i + 2];
			        }
			        props.children = childArray;
			      }
			      return ReactElement(element.type, key, ref, self, source, owner, props);
			    }
			    /**
			     * Verifies the object is a ReactElement.
			     * See https://reactjs.org/docs/react-api.html#isvalidelement
			     * @param {?object} object
			     * @return {boolean} True if `object` is a ReactElement.
			     * @final
			     */

			    function isValidElement(object) {
			      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
			    }
			    var SEPARATOR = '.';
			    var SUBSEPARATOR = ':';
			    /**
			     * Escape and wrap key so it is safe to use as a reactid
			     *
			     * @param {string} key to be escaped.
			     * @return {string} the escaped key.
			     */

			    function escape(key) {
			      var escapeRegex = /[=:]/g;
			      var escaperLookup = {
			        '=': '=0',
			        ':': '=2'
			      };
			      var escapedString = key.replace(escapeRegex, function (match) {
			        return escaperLookup[match];
			      });
			      return '$' + escapedString;
			    }
			    /**
			     * TODO: Test that a single child and an array with one item have the same key
			     * pattern.
			     */

			    var didWarnAboutMaps = false;
			    var userProvidedKeyEscapeRegex = /\/+/g;
			    function escapeUserProvidedKey(text) {
			      return text.replace(userProvidedKeyEscapeRegex, '$&/');
			    }
			    /**
			     * Generate a key string that identifies a element within a set.
			     *
			     * @param {*} element A element that could contain a manual key.
			     * @param {number} index Index that is used if a manual key is not provided.
			     * @return {string}
			     */

			    function getElementKey(element, index) {
			      // Do some typechecking here since we call this blindly. We want to ensure
			      // that we don't block potential future ES APIs.
			      if (typeof element === 'object' && element !== null && element.key != null) {
			        // Explicit key
			        {
			          checkKeyStringCoercion(element.key);
			        }
			        return escape('' + element.key);
			      } // Implicit key determined by the index in the set

			      return index.toString(36);
			    }
			    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
			      var type = typeof children;
			      if (type === 'undefined' || type === 'boolean') {
			        // All of the above are perceived as null.
			        children = null;
			      }
			      var invokeCallback = false;
			      if (children === null) {
			        invokeCallback = true;
			      } else {
			        switch (type) {
			          case 'string':
			          case 'number':
			            invokeCallback = true;
			            break;
			          case 'object':
			            switch (children.$$typeof) {
			              case REACT_ELEMENT_TYPE:
			              case REACT_PORTAL_TYPE:
			                invokeCallback = true;
			            }
			        }
			      }
			      if (invokeCallback) {
			        var _child = children;
			        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
			        // so that it's consistent if the number of children grows:

			        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
			        if (isArray(mappedChild)) {
			          var escapedChildKey = '';
			          if (childKey != null) {
			            escapedChildKey = escapeUserProvidedKey(childKey) + '/';
			          }
			          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
			            return c;
			          });
			        } else if (mappedChild != null) {
			          if (isValidElement(mappedChild)) {
			            {
			              // The `if` statement here prevents auto-disabling of the safe
			              // coercion ESLint rule, so we must manually disable it below.
			              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
			              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
			                checkKeyStringCoercion(mappedChild.key);
			              }
			            }
			            mappedChild = cloneAndReplaceKey(mappedChild,
			            // Keep both the (mapped) and old keys if they differ, just as
			            // traverseAllChildren used to do for objects as children
			            escapedPrefix + (
			            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
			            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?
			            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
			            // eslint-disable-next-line react-internal/safe-string-coercion
			            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
			          }
			          array.push(mappedChild);
			        }
			        return 1;
			      }
			      var child;
			      var nextName;
			      var subtreeCount = 0; // Count of children found in the current subtree.

			      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
			      if (isArray(children)) {
			        for (var i = 0; i < children.length; i++) {
			          child = children[i];
			          nextName = nextNamePrefix + getElementKey(child, i);
			          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
			        }
			      } else {
			        var iteratorFn = getIteratorFn(children);
			        if (typeof iteratorFn === 'function') {
			          var iterableChildren = children;
			          {
			            // Warn about using Maps as children
			            if (iteratorFn === iterableChildren.entries) {
			              if (!didWarnAboutMaps) {
			                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
			              }
			              didWarnAboutMaps = true;
			            }
			          }
			          var iterator = iteratorFn.call(iterableChildren);
			          var step;
			          var ii = 0;
			          while (!(step = iterator.next()).done) {
			            child = step.value;
			            nextName = nextNamePrefix + getElementKey(child, ii++);
			            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
			          }
			        } else if (type === 'object') {
			          // eslint-disable-next-line react-internal/safe-string-coercion
			          var childrenString = String(children);
			          throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
			        }
			      }
			      return subtreeCount;
			    }

			    /**
			     * Maps children that are typically specified as `props.children`.
			     *
			     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
			     *
			     * The provided mapFunction(child, index) will be called for each
			     * leaf child.
			     *
			     * @param {?*} children Children tree container.
			     * @param {function(*, int)} func The map function.
			     * @param {*} context Context for mapFunction.
			     * @return {object} Object containing the ordered map of results.
			     */
			    function mapChildren(children, func, context) {
			      if (children == null) {
			        return children;
			      }
			      var result = [];
			      var count = 0;
			      mapIntoArray(children, result, '', '', function (child) {
			        return func.call(context, child, count++);
			      });
			      return result;
			    }
			    /**
			     * Count the number of children that are typically specified as
			     * `props.children`.
			     *
			     * See https://reactjs.org/docs/react-api.html#reactchildrencount
			     *
			     * @param {?*} children Children tree container.
			     * @return {number} The number of children.
			     */

			    function countChildren(children) {
			      var n = 0;
			      mapChildren(children, function () {
			        n++; // Don't return anything
			      });
			      return n;
			    }

			    /**
			     * Iterates through children that are typically specified as `props.children`.
			     *
			     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
			     *
			     * The provided forEachFunc(child, index) will be called for each
			     * leaf child.
			     *
			     * @param {?*} children Children tree container.
			     * @param {function(*, int)} forEachFunc
			     * @param {*} forEachContext Context for forEachContext.
			     */
			    function forEachChildren(children, forEachFunc, forEachContext) {
			      mapChildren(children, function () {
			        forEachFunc.apply(this, arguments); // Don't return anything.
			      }, forEachContext);
			    }
			    /**
			     * Flatten a children object (typically specified as `props.children`) and
			     * return an array with appropriately re-keyed children.
			     *
			     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
			     */

			    function toArray(children) {
			      return mapChildren(children, function (child) {
			        return child;
			      }) || [];
			    }
			    /**
			     * Returns the first child in a collection of children and verifies that there
			     * is only one child in the collection.
			     *
			     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
			     *
			     * The current implementation of this function assumes that a single child gets
			     * passed without a wrapper, but the purpose of this helper function is to
			     * abstract away the particular structure of children.
			     *
			     * @param {?object} children Child collection structure.
			     * @return {ReactElement} The first and only `ReactElement` contained in the
			     * structure.
			     */

			    function onlyChild(children) {
			      if (!isValidElement(children)) {
			        throw new Error('React.Children.only expected to receive a single React element child.');
			      }
			      return children;
			    }
			    function createContext(defaultValue) {
			      // TODO: Second argument used to be an optional `calculateChangedBits`
			      // function. Warn to reserve for future use?
			      var context = {
			        $$typeof: REACT_CONTEXT_TYPE,
			        // As a workaround to support multiple concurrent renderers, we categorize
			        // some renderers as primary and others as secondary. We only expect
			        // there to be two concurrent renderers at most: React Native (primary) and
			        // Fabric (secondary); React DOM (primary) and React ART (secondary).
			        // Secondary renderers store their context values on separate fields.
			        _currentValue: defaultValue,
			        _currentValue2: defaultValue,
			        // Used to track how many concurrent renderers this context currently
			        // supports within in a single renderer. Such as parallel server rendering.
			        _threadCount: 0,
			        // These are circular
			        Provider: null,
			        Consumer: null,
			        // Add these to use same hidden class in VM as ServerContext
			        _defaultValue: null,
			        _globalName: null
			      };
			      context.Provider = {
			        $$typeof: REACT_PROVIDER_TYPE,
			        _context: context
			      };
			      var hasWarnedAboutUsingNestedContextConsumers = false;
			      var hasWarnedAboutUsingConsumerProvider = false;
			      var hasWarnedAboutDisplayNameOnConsumer = false;
			      {
			        // A separate object, but proxies back to the original context object for
			        // backwards compatibility. It has a different $$typeof, so we can properly
			        // warn for the incorrect usage of Context as a Consumer.
			        var Consumer = {
			          $$typeof: REACT_CONTEXT_TYPE,
			          _context: context
			        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

			        Object.defineProperties(Consumer, {
			          Provider: {
			            get: function () {
			              if (!hasWarnedAboutUsingConsumerProvider) {
			                hasWarnedAboutUsingConsumerProvider = true;
			                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
			              }
			              return context.Provider;
			            },
			            set: function (_Provider) {
			              context.Provider = _Provider;
			            }
			          },
			          _currentValue: {
			            get: function () {
			              return context._currentValue;
			            },
			            set: function (_currentValue) {
			              context._currentValue = _currentValue;
			            }
			          },
			          _currentValue2: {
			            get: function () {
			              return context._currentValue2;
			            },
			            set: function (_currentValue2) {
			              context._currentValue2 = _currentValue2;
			            }
			          },
			          _threadCount: {
			            get: function () {
			              return context._threadCount;
			            },
			            set: function (_threadCount) {
			              context._threadCount = _threadCount;
			            }
			          },
			          Consumer: {
			            get: function () {
			              if (!hasWarnedAboutUsingNestedContextConsumers) {
			                hasWarnedAboutUsingNestedContextConsumers = true;
			                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
			              }
			              return context.Consumer;
			            }
			          },
			          displayName: {
			            get: function () {
			              return context.displayName;
			            },
			            set: function (displayName) {
			              if (!hasWarnedAboutDisplayNameOnConsumer) {
			                warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
			                hasWarnedAboutDisplayNameOnConsumer = true;
			              }
			            }
			          }
			        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

			        context.Consumer = Consumer;
			      }
			      {
			        context._currentRenderer = null;
			        context._currentRenderer2 = null;
			      }
			      return context;
			    }
			    var Uninitialized = -1;
			    var Pending = 0;
			    var Resolved = 1;
			    var Rejected = 2;
			    function lazyInitializer(payload) {
			      if (payload._status === Uninitialized) {
			        var ctor = payload._result;
			        var thenable = ctor(); // Transition to the next state.
			        // This might throw either because it's missing or throws. If so, we treat it
			        // as still uninitialized and try again next time. Which is the same as what
			        // happens if the ctor or any wrappers processing the ctor throws. This might
			        // end up fixing it if the resolution was a concurrency bug.

			        thenable.then(function (moduleObject) {
			          if (payload._status === Pending || payload._status === Uninitialized) {
			            // Transition to the next state.
			            var resolved = payload;
			            resolved._status = Resolved;
			            resolved._result = moduleObject;
			          }
			        }, function (error) {
			          if (payload._status === Pending || payload._status === Uninitialized) {
			            // Transition to the next state.
			            var rejected = payload;
			            rejected._status = Rejected;
			            rejected._result = error;
			          }
			        });
			        if (payload._status === Uninitialized) {
			          // In case, we're still uninitialized, then we're waiting for the thenable
			          // to resolve. Set it as pending in the meantime.
			          var pending = payload;
			          pending._status = Pending;
			          pending._result = thenable;
			        }
			      }
			      if (payload._status === Resolved) {
			        var moduleObject = payload._result;
			        {
			          if (moduleObject === undefined) {
			            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
			            // Break up imports to avoid accidentally parsing them as dependencies.
			            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
			          }
			        }
			        {
			          if (!('default' in moduleObject)) {
			            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' +
			            // Break up imports to avoid accidentally parsing them as dependencies.
			            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
			          }
			        }
			        return moduleObject.default;
			      } else {
			        throw payload._result;
			      }
			    }
			    function lazy(ctor) {
			      var payload = {
			        // We use these fields to store the result.
			        _status: Uninitialized,
			        _result: ctor
			      };
			      var lazyType = {
			        $$typeof: REACT_LAZY_TYPE,
			        _payload: payload,
			        _init: lazyInitializer
			      };
			      {
			        // In production, this would just set it on the object.
			        var defaultProps;
			        var propTypes; // $FlowFixMe

			        Object.defineProperties(lazyType, {
			          defaultProps: {
			            configurable: true,
			            get: function () {
			              return defaultProps;
			            },
			            set: function (newDefaultProps) {
			              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
			              defaultProps = newDefaultProps; // Match production behavior more closely:
			              // $FlowFixMe

			              Object.defineProperty(lazyType, 'defaultProps', {
			                enumerable: true
			              });
			            }
			          },
			          propTypes: {
			            configurable: true,
			            get: function () {
			              return propTypes;
			            },
			            set: function (newPropTypes) {
			              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
			              propTypes = newPropTypes; // Match production behavior more closely:
			              // $FlowFixMe

			              Object.defineProperty(lazyType, 'propTypes', {
			                enumerable: true
			              });
			            }
			          }
			        });
			      }
			      return lazyType;
			    }
			    function forwardRef(render) {
			      {
			        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
			          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
			        } else if (typeof render !== 'function') {
			          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
			        } else {
			          if (render.length !== 0 && render.length !== 2) {
			            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
			          }
			        }
			        if (render != null) {
			          if (render.defaultProps != null || render.propTypes != null) {
			            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
			          }
			        }
			      }
			      var elementType = {
			        $$typeof: REACT_FORWARD_REF_TYPE,
			        render: render
			      };
			      {
			        var ownName;
			        Object.defineProperty(elementType, 'displayName', {
			          enumerable: false,
			          configurable: true,
			          get: function () {
			            return ownName;
			          },
			          set: function (name) {
			            ownName = name; // The inner component shouldn't inherit this display name in most cases,
			            // because the component may be used elsewhere.
			            // But it's nice for anonymous functions to inherit the name,
			            // so that our component-stack generation logic will display their frames.
			            // An anonymous function generally suggests a pattern like:
			            //   React.forwardRef((props, ref) => {...});
			            // This kind of inner function is not used elsewhere so the side effect is okay.

			            if (!render.name && !render.displayName) {
			              render.displayName = name;
			            }
			          }
			        });
			      }
			      return elementType;
			    }
			    var REACT_MODULE_REFERENCE;
			    {
			      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
			    }
			    function isValidElementType(type) {
			      if (typeof type === 'string' || typeof type === 'function') {
			        return true;
			      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

			      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
			        return true;
			      }
			      if (typeof type === 'object' && type !== null) {
			        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
			        // This needs to include all possible module reference object
			        // types supported by any Flight configuration anywhere since
			        // we don't know which Flight build this will end up being used
			        // with.
			        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
			          return true;
			        }
			      }
			      return false;
			    }
			    function memo(type, compare) {
			      {
			        if (!isValidElementType(type)) {
			          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
			        }
			      }
			      var elementType = {
			        $$typeof: REACT_MEMO_TYPE,
			        type: type,
			        compare: compare === undefined ? null : compare
			      };
			      {
			        var ownName;
			        Object.defineProperty(elementType, 'displayName', {
			          enumerable: false,
			          configurable: true,
			          get: function () {
			            return ownName;
			          },
			          set: function (name) {
			            ownName = name; // The inner component shouldn't inherit this display name in most cases,
			            // because the component may be used elsewhere.
			            // But it's nice for anonymous functions to inherit the name,
			            // so that our component-stack generation logic will display their frames.
			            // An anonymous function generally suggests a pattern like:
			            //   React.memo((props) => {...});
			            // This kind of inner function is not used elsewhere so the side effect is okay.

			            if (!type.name && !type.displayName) {
			              type.displayName = name;
			            }
			          }
			        });
			      }
			      return elementType;
			    }
			    function resolveDispatcher() {
			      var dispatcher = ReactCurrentDispatcher.current;
			      {
			        if (dispatcher === null) {
			          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
			        }
			      } // Will result in a null access error if accessed outside render phase. We
			      // intentionally don't throw our own error because this is in a hot path.
			      // Also helps ensure this is inlined.

			      return dispatcher;
			    }
			    function useContext(Context) {
			      var dispatcher = resolveDispatcher();
			      {
			        // TODO: add a more generic warning for invalid values.
			        if (Context._context !== undefined) {
			          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
			          // and nobody should be using this in existing code.

			          if (realContext.Consumer === Context) {
			            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
			          } else if (realContext.Provider === Context) {
			            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
			          }
			        }
			      }
			      return dispatcher.useContext(Context);
			    }
			    function useState(initialState) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useState(initialState);
			    }
			    function useReducer(reducer, initialArg, init) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useReducer(reducer, initialArg, init);
			    }
			    function useRef(initialValue) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useRef(initialValue);
			    }
			    function useEffect(create, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useEffect(create, deps);
			    }
			    function useInsertionEffect(create, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useInsertionEffect(create, deps);
			    }
			    function useLayoutEffect(create, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useLayoutEffect(create, deps);
			    }
			    function useCallback(callback, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useCallback(callback, deps);
			    }
			    function useMemo(create, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useMemo(create, deps);
			    }
			    function useImperativeHandle(ref, create, deps) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useImperativeHandle(ref, create, deps);
			    }
			    function useDebugValue(value, formatterFn) {
			      {
			        var dispatcher = resolveDispatcher();
			        return dispatcher.useDebugValue(value, formatterFn);
			      }
			    }
			    function useTransition() {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useTransition();
			    }
			    function useDeferredValue(value) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useDeferredValue(value);
			    }
			    function useId() {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useId();
			    }
			    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
			      var dispatcher = resolveDispatcher();
			      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
			    }

			    // Helpers to patch console.logs to avoid logging during side-effect free
			    // replaying on render function. This currently only patches the object
			    // lazily which won't cover if the log function was extracted eagerly.
			    // We could also eagerly patch the method.
			    var disabledDepth = 0;
			    var prevLog;
			    var prevInfo;
			    var prevWarn;
			    var prevError;
			    var prevGroup;
			    var prevGroupCollapsed;
			    var prevGroupEnd;
			    function disabledLog() {}
			    disabledLog.__reactDisabledLog = true;
			    function disableLogs() {
			      {
			        if (disabledDepth === 0) {
			          /* eslint-disable react-internal/no-production-logging */
			          prevLog = console.log;
			          prevInfo = console.info;
			          prevWarn = console.warn;
			          prevError = console.error;
			          prevGroup = console.group;
			          prevGroupCollapsed = console.groupCollapsed;
			          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

			          var props = {
			            configurable: true,
			            enumerable: true,
			            value: disabledLog,
			            writable: true
			          }; // $FlowFixMe Flow thinks console is immutable.

			          Object.defineProperties(console, {
			            info: props,
			            log: props,
			            warn: props,
			            error: props,
			            group: props,
			            groupCollapsed: props,
			            groupEnd: props
			          });
			          /* eslint-enable react-internal/no-production-logging */
			        }
			        disabledDepth++;
			      }
			    }
			    function reenableLogs() {
			      {
			        disabledDepth--;
			        if (disabledDepth === 0) {
			          /* eslint-disable react-internal/no-production-logging */
			          var props = {
			            configurable: true,
			            enumerable: true,
			            writable: true
			          }; // $FlowFixMe Flow thinks console is immutable.

			          Object.defineProperties(console, {
			            log: assign({}, props, {
			              value: prevLog
			            }),
			            info: assign({}, props, {
			              value: prevInfo
			            }),
			            warn: assign({}, props, {
			              value: prevWarn
			            }),
			            error: assign({}, props, {
			              value: prevError
			            }),
			            group: assign({}, props, {
			              value: prevGroup
			            }),
			            groupCollapsed: assign({}, props, {
			              value: prevGroupCollapsed
			            }),
			            groupEnd: assign({}, props, {
			              value: prevGroupEnd
			            })
			          });
			          /* eslint-enable react-internal/no-production-logging */
			        }
			        if (disabledDepth < 0) {
			          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
			        }
			      }
			    }
			    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
			    var prefix;
			    function describeBuiltInComponentFrame(name, source, ownerFn) {
			      {
			        if (prefix === undefined) {
			          // Extract the VM specific prefix used by each line.
			          try {
			            throw Error();
			          } catch (x) {
			            var match = x.stack.trim().match(/\n( *(at )?)/);
			            prefix = match && match[1] || '';
			          }
			        } // We use the prefix to ensure our stacks line up with native stack frames.

			        return '\n' + prefix + name;
			      }
			    }
			    var reentry = false;
			    var componentFrameCache;
			    {
			      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
			      componentFrameCache = new PossiblyWeakMap();
			    }
			    function describeNativeComponentFrame(fn, construct) {
			      // If something asked for a stack inside a fake render, it should get ignored.
			      if (!fn || reentry) {
			        return '';
			      }
			      {
			        var frame = componentFrameCache.get(fn);
			        if (frame !== undefined) {
			          return frame;
			        }
			      }
			      var control;
			      reentry = true;
			      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

			      Error.prepareStackTrace = undefined;
			      var previousDispatcher;
			      {
			        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
			        // for warnings.

			        ReactCurrentDispatcher$1.current = null;
			        disableLogs();
			      }
			      try {
			        // This should throw.
			        if (construct) {
			          // Something should be setting the props in the constructor.
			          var Fake = function () {
			            throw Error();
			          }; // $FlowFixMe

			          Object.defineProperty(Fake.prototype, 'props', {
			            set: function () {
			              // We use a throwing setter instead of frozen or non-writable props
			              // because that won't throw in a non-strict mode function.
			              throw Error();
			            }
			          });
			          if (typeof Reflect === 'object' && Reflect.construct) {
			            // We construct a different control for this case to include any extra
			            // frames added by the construct call.
			            try {
			              Reflect.construct(Fake, []);
			            } catch (x) {
			              control = x;
			            }
			            Reflect.construct(fn, [], Fake);
			          } else {
			            try {
			              Fake.call();
			            } catch (x) {
			              control = x;
			            }
			            fn.call(Fake.prototype);
			          }
			        } else {
			          try {
			            throw Error();
			          } catch (x) {
			            control = x;
			          }
			          fn();
			        }
			      } catch (sample) {
			        // This is inlined manually because closure doesn't do it for us.
			        if (sample && control && typeof sample.stack === 'string') {
			          // This extracts the first frame from the sample that isn't also in the control.
			          // Skipping one frame that we assume is the frame that calls the two.
			          var sampleLines = sample.stack.split('\n');
			          var controlLines = control.stack.split('\n');
			          var s = sampleLines.length - 1;
			          var c = controlLines.length - 1;
			          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
			            // We expect at least one stack frame to be shared.
			            // Typically this will be the root most one. However, stack frames may be
			            // cut off due to maximum stack limits. In this case, one maybe cut off
			            // earlier than the other. We assume that the sample is longer or the same
			            // and there for cut off earlier. So we should find the root most frame in
			            // the sample somewhere in the control.
			            c--;
			          }
			          for (; s >= 1 && c >= 0; s--, c--) {
			            // Next we find the first one that isn't the same which should be the
			            // frame that called our sample function and the control.
			            if (sampleLines[s] !== controlLines[c]) {
			              // In V8, the first line is describing the message but other VMs don't.
			              // If we're about to return the first line, and the control is also on the same
			              // line, that's a pretty good indicator that our sample threw at same line as
			              // the control. I.e. before we entered the sample frame. So we ignore this result.
			              // This can happen if you passed a class to function component, or non-function.
			              if (s !== 1 || c !== 1) {
			                do {
			                  s--;
			                  c--; // We may still have similar intermediate frames from the construct call.
			                  // The next one that isn't the same should be our match though.

			                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
			                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
			                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
			                    // but we have a user-provided "displayName"
			                    // splice it in to make the stack more readable.

			                    if (fn.displayName && _frame.includes('<anonymous>')) {
			                      _frame = _frame.replace('<anonymous>', fn.displayName);
			                    }
			                    {
			                      if (typeof fn === 'function') {
			                        componentFrameCache.set(fn, _frame);
			                      }
			                    } // Return the line we found.

			                    return _frame;
			                  }
			                } while (s >= 1 && c >= 0);
			              }
			              break;
			            }
			          }
			        }
			      } finally {
			        reentry = false;
			        {
			          ReactCurrentDispatcher$1.current = previousDispatcher;
			          reenableLogs();
			        }
			        Error.prepareStackTrace = previousPrepareStackTrace;
			      } // Fallback to just using the name if we couldn't make it throw.

			      var name = fn ? fn.displayName || fn.name : '';
			      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
			      {
			        if (typeof fn === 'function') {
			          componentFrameCache.set(fn, syntheticFrame);
			        }
			      }
			      return syntheticFrame;
			    }
			    function describeFunctionComponentFrame(fn, source, ownerFn) {
			      {
			        return describeNativeComponentFrame(fn, false);
			      }
			    }
			    function shouldConstruct(Component) {
			      var prototype = Component.prototype;
			      return !!(prototype && prototype.isReactComponent);
			    }
			    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
			      if (type == null) {
			        return '';
			      }
			      if (typeof type === 'function') {
			        {
			          return describeNativeComponentFrame(type, shouldConstruct(type));
			        }
			      }
			      if (typeof type === 'string') {
			        return describeBuiltInComponentFrame(type);
			      }
			      switch (type) {
			        case REACT_SUSPENSE_TYPE:
			          return describeBuiltInComponentFrame('Suspense');
			        case REACT_SUSPENSE_LIST_TYPE:
			          return describeBuiltInComponentFrame('SuspenseList');
			      }
			      if (typeof type === 'object') {
			        switch (type.$$typeof) {
			          case REACT_FORWARD_REF_TYPE:
			            return describeFunctionComponentFrame(type.render);
			          case REACT_MEMO_TYPE:
			            // Memo may contain any component type so we recursively resolve it.
			            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
			          case REACT_LAZY_TYPE:
			            {
			              var lazyComponent = type;
			              var payload = lazyComponent._payload;
			              var init = lazyComponent._init;
			              try {
			                // Lazy may contain any component type so we recursively resolve it.
			                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
			              } catch (x) {}
			            }
			        }
			      }
			      return '';
			    }
			    var loggedTypeFailures = {};
			    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
			    function setCurrentlyValidatingElement(element) {
			      {
			        if (element) {
			          var owner = element._owner;
			          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
			          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
			        } else {
			          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
			        }
			      }
			    }
			    function checkPropTypes(typeSpecs, values, location, componentName, element) {
			      {
			        // $FlowFixMe This is okay but Flow doesn't know it.
			        var has = Function.call.bind(hasOwnProperty);
			        for (var typeSpecName in typeSpecs) {
			          if (has(typeSpecs, typeSpecName)) {
			            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
			            // fail the render phase where it didn't fail before. So we log it.
			            // After these have been cleaned up, we'll let them throw.

			            try {
			              // This is intentionally an invariant that gets caught. It's the same
			              // behavior as without this statement except with a better message.
			              if (typeof typeSpecs[typeSpecName] !== 'function') {
			                // eslint-disable-next-line react-internal/prod-error-codes
			                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
			                err.name = 'Invariant Violation';
			                throw err;
			              }
			              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
			            } catch (ex) {
			              error$1 = ex;
			            }
			            if (error$1 && !(error$1 instanceof Error)) {
			              setCurrentlyValidatingElement(element);
			              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
			              setCurrentlyValidatingElement(null);
			            }
			            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
			              // Only monitor this failure once because there tends to be a lot of the
			              // same error.
			              loggedTypeFailures[error$1.message] = true;
			              setCurrentlyValidatingElement(element);
			              error('Failed %s type: %s', location, error$1.message);
			              setCurrentlyValidatingElement(null);
			            }
			          }
			        }
			      }
			    }
			    function setCurrentlyValidatingElement$1(element) {
			      {
			        if (element) {
			          var owner = element._owner;
			          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
			          setExtraStackFrame(stack);
			        } else {
			          setExtraStackFrame(null);
			        }
			      }
			    }
			    var propTypesMisspellWarningShown;
			    {
			      propTypesMisspellWarningShown = false;
			    }
			    function getDeclarationErrorAddendum() {
			      if (ReactCurrentOwner.current) {
			        var name = getComponentNameFromType(ReactCurrentOwner.current.type);
			        if (name) {
			          return '\n\nCheck the render method of `' + name + '`.';
			        }
			      }
			      return '';
			    }
			    function getSourceInfoErrorAddendum(source) {
			      if (source !== undefined) {
			        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
			        var lineNumber = source.lineNumber;
			        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
			      }
			      return '';
			    }
			    function getSourceInfoErrorAddendumForProps(elementProps) {
			      if (elementProps !== null && elementProps !== undefined) {
			        return getSourceInfoErrorAddendum(elementProps.__source);
			      }
			      return '';
			    }
			    /**
			     * Warn if there's no key explicitly set on dynamic arrays of children or
			     * object keys are not valid. This allows us to keep track of children between
			     * updates.
			     */

			    var ownerHasKeyUseWarning = {};
			    function getCurrentComponentErrorInfo(parentType) {
			      var info = getDeclarationErrorAddendum();
			      if (!info) {
			        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
			        if (parentName) {
			          info = "\n\nCheck the top-level render call using <" + parentName + ">.";
			        }
			      }
			      return info;
			    }
			    /**
			     * Warn if the element doesn't have an explicit key assigned to it.
			     * This element is in an array. The array could grow and shrink or be
			     * reordered. All children that haven't already been validated are required to
			     * have a "key" property assigned to it. Error statuses are cached so a warning
			     * will only be shown once.
			     *
			     * @internal
			     * @param {ReactElement} element Element that requires a key.
			     * @param {*} parentType element's parent's type.
			     */

			    function validateExplicitKey(element, parentType) {
			      if (!element._store || element._store.validated || element.key != null) {
			        return;
			      }
			      element._store.validated = true;
			      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
			      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
			        return;
			      }
			      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
			      // property, it may be the creator of the child that's responsible for
			      // assigning it a key.

			      var childOwner = '';
			      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
			        // Give the component that originally created this child.
			        childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
			      }
			      {
			        setCurrentlyValidatingElement$1(element);
			        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
			        setCurrentlyValidatingElement$1(null);
			      }
			    }
			    /**
			     * Ensure that every element either is passed in a static location, in an
			     * array with an explicit keys property defined, or in an object literal
			     * with valid key property.
			     *
			     * @internal
			     * @param {ReactNode} node Statically passed child of any type.
			     * @param {*} parentType node's parent's type.
			     */

			    function validateChildKeys(node, parentType) {
			      if (typeof node !== 'object') {
			        return;
			      }
			      if (isArray(node)) {
			        for (var i = 0; i < node.length; i++) {
			          var child = node[i];
			          if (isValidElement(child)) {
			            validateExplicitKey(child, parentType);
			          }
			        }
			      } else if (isValidElement(node)) {
			        // This element was passed in a valid location.
			        if (node._store) {
			          node._store.validated = true;
			        }
			      } else if (node) {
			        var iteratorFn = getIteratorFn(node);
			        if (typeof iteratorFn === 'function') {
			          // Entry iterators used to provide implicit keys,
			          // but now we print a separate warning for them later.
			          if (iteratorFn !== node.entries) {
			            var iterator = iteratorFn.call(node);
			            var step;
			            while (!(step = iterator.next()).done) {
			              if (isValidElement(step.value)) {
			                validateExplicitKey(step.value, parentType);
			              }
			            }
			          }
			        }
			      }
			    }
			    /**
			     * Given an element, validate that its props follow the propTypes definition,
			     * provided by the type.
			     *
			     * @param {ReactElement} element
			     */

			    function validatePropTypes(element) {
			      {
			        var type = element.type;
			        if (type === null || type === undefined || typeof type === 'string') {
			          return;
			        }
			        var propTypes;
			        if (typeof type === 'function') {
			          propTypes = type.propTypes;
			        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
			        // Note: Memo only checks outer props here.
			        // Inner props are checked in the reconciler.
			        type.$$typeof === REACT_MEMO_TYPE)) {
			          propTypes = type.propTypes;
			        } else {
			          return;
			        }
			        if (propTypes) {
			          // Intentionally inside to avoid triggering lazy initializers:
			          var name = getComponentNameFromType(type);
			          checkPropTypes(propTypes, element.props, 'prop', name, element);
			        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
			          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

			          var _name = getComponentNameFromType(type);
			          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
			        }
			        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
			          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
			        }
			      }
			    }
			    /**
			     * Given a fragment, validate that it can only be provided with fragment props
			     * @param {ReactElement} fragment
			     */

			    function validateFragmentProps(fragment) {
			      {
			        var keys = Object.keys(fragment.props);
			        for (var i = 0; i < keys.length; i++) {
			          var key = keys[i];
			          if (key !== 'children' && key !== 'key') {
			            setCurrentlyValidatingElement$1(fragment);
			            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
			            setCurrentlyValidatingElement$1(null);
			            break;
			          }
			        }
			        if (fragment.ref !== null) {
			          setCurrentlyValidatingElement$1(fragment);
			          error('Invalid attribute `ref` supplied to `React.Fragment`.');
			          setCurrentlyValidatingElement$1(null);
			        }
			      }
			    }
			    function createElementWithValidation(type, props, children) {
			      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
			      // succeed and there will likely be errors in render.

			      if (!validType) {
			        var info = '';
			        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
			          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
			        }
			        var sourceInfo = getSourceInfoErrorAddendumForProps(props);
			        if (sourceInfo) {
			          info += sourceInfo;
			        } else {
			          info += getDeclarationErrorAddendum();
			        }
			        var typeString;
			        if (type === null) {
			          typeString = 'null';
			        } else if (isArray(type)) {
			          typeString = 'array';
			        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
			          typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
			          info = ' Did you accidentally export a JSX literal instead of a component?';
			        } else {
			          typeString = typeof type;
			        }
			        {
			          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
			        }
			      }
			      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
			      // TODO: Drop this when these are no longer allowed as the type argument.

			      if (element == null) {
			        return element;
			      } // Skip key warning if the type isn't valid since our key validation logic
			      // doesn't expect a non-string/function type and can throw confusing errors.
			      // We don't want exception behavior to differ between dev and prod.
			      // (Rendering will throw with a helpful message and as soon as the type is
			      // fixed, the key warnings will appear.)

			      if (validType) {
			        for (var i = 2; i < arguments.length; i++) {
			          validateChildKeys(arguments[i], type);
			        }
			      }
			      if (type === REACT_FRAGMENT_TYPE) {
			        validateFragmentProps(element);
			      } else {
			        validatePropTypes(element);
			      }
			      return element;
			    }
			    var didWarnAboutDeprecatedCreateFactory = false;
			    function createFactoryWithValidation(type) {
			      var validatedFactory = createElementWithValidation.bind(null, type);
			      validatedFactory.type = type;
			      {
			        if (!didWarnAboutDeprecatedCreateFactory) {
			          didWarnAboutDeprecatedCreateFactory = true;
			          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
			        } // Legacy hook: remove it

			        Object.defineProperty(validatedFactory, 'type', {
			          enumerable: false,
			          get: function () {
			            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
			            Object.defineProperty(this, 'type', {
			              value: type
			            });
			            return type;
			          }
			        });
			      }
			      return validatedFactory;
			    }
			    function cloneElementWithValidation(element, props, children) {
			      var newElement = cloneElement.apply(this, arguments);
			      for (var i = 2; i < arguments.length; i++) {
			        validateChildKeys(arguments[i], newElement.type);
			      }
			      validatePropTypes(newElement);
			      return newElement;
			    }
			    function startTransition(scope, options) {
			      var prevTransition = ReactCurrentBatchConfig.transition;
			      ReactCurrentBatchConfig.transition = {};
			      var currentTransition = ReactCurrentBatchConfig.transition;
			      {
			        ReactCurrentBatchConfig.transition._updatedFibers = new Set();
			      }
			      try {
			        scope();
			      } finally {
			        ReactCurrentBatchConfig.transition = prevTransition;
			        {
			          if (prevTransition === null && currentTransition._updatedFibers) {
			            var updatedFibersCount = currentTransition._updatedFibers.size;
			            if (updatedFibersCount > 10) {
			              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
			            }
			            currentTransition._updatedFibers.clear();
			          }
			        }
			      }
			    }
			    var didWarnAboutMessageChannel = false;
			    var enqueueTaskImpl = null;
			    function enqueueTask(task) {
			      if (enqueueTaskImpl === null) {
			        try {
			          // read require off the module object to get around the bundlers.
			          // we don't want them to detect a require and bundle a Node polyfill.
			          var requireString = ('require' + Math.random()).slice(0, 7);
			          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
			          // version of setImmediate, bypassing fake timers if any.

			          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
			        } catch (_err) {
			          // we're in a browser
			          // we can't use regular timers because they may still be faked
			          // so we try MessageChannel+postMessage instead
			          enqueueTaskImpl = function (callback) {
			            {
			              if (didWarnAboutMessageChannel === false) {
			                didWarnAboutMessageChannel = true;
			                if (typeof MessageChannel === 'undefined') {
			                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
			                }
			              }
			            }
			            var channel = new MessageChannel();
			            channel.port1.onmessage = callback;
			            channel.port2.postMessage(undefined);
			          };
			        }
			      }
			      return enqueueTaskImpl(task);
			    }
			    var actScopeDepth = 0;
			    var didWarnNoAwaitAct = false;
			    function act(callback) {
			      {
			        // `act` calls can be nested, so we track the depth. This represents the
			        // number of `act` scopes on the stack.
			        var prevActScopeDepth = actScopeDepth;
			        actScopeDepth++;
			        if (ReactCurrentActQueue.current === null) {
			          // This is the outermost `act` scope. Initialize the queue. The reconciler
			          // will detect the queue and use it instead of Scheduler.
			          ReactCurrentActQueue.current = [];
			        }
			        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
			        var result;
			        try {
			          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
			          // set to `true` while the given callback is executed, not for updates
			          // triggered during an async event, because this is how the legacy
			          // implementation of `act` behaved.
			          ReactCurrentActQueue.isBatchingLegacy = true;
			          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
			          // which flushed updates immediately after the scope function exits, even
			          // if it's an async function.

			          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
			            var queue = ReactCurrentActQueue.current;
			            if (queue !== null) {
			              ReactCurrentActQueue.didScheduleLegacyUpdate = false;
			              flushActQueue(queue);
			            }
			          }
			        } catch (error) {
			          popActScope(prevActScopeDepth);
			          throw error;
			        } finally {
			          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
			        }
			        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
			          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
			          // for it to resolve before exiting the current scope.

			          var wasAwaited = false;
			          var thenable = {
			            then: function (resolve, reject) {
			              wasAwaited = true;
			              thenableResult.then(function (returnValue) {
			                popActScope(prevActScopeDepth);
			                if (actScopeDepth === 0) {
			                  // We've exited the outermost act scope. Recursively flush the
			                  // queue until there's no remaining work.
			                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
			                } else {
			                  resolve(returnValue);
			                }
			              }, function (error) {
			                // The callback threw an error.
			                popActScope(prevActScopeDepth);
			                reject(error);
			              });
			            }
			          };
			          {
			            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
			              // eslint-disable-next-line no-undef
			              Promise.resolve().then(function () {}).then(function () {
			                if (!wasAwaited) {
			                  didWarnNoAwaitAct = true;
			                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
			                }
			              });
			            }
			          }
			          return thenable;
			        } else {
			          var returnValue = result; // The callback is not an async function. Exit the current scope
			          // immediately, without awaiting.

			          popActScope(prevActScopeDepth);
			          if (actScopeDepth === 0) {
			            // Exiting the outermost act scope. Flush the queue.
			            var _queue = ReactCurrentActQueue.current;
			            if (_queue !== null) {
			              flushActQueue(_queue);
			              ReactCurrentActQueue.current = null;
			            } // Return a thenable. If the user awaits it, we'll flush again in
			            // case additional work was scheduled by a microtask.

			            var _thenable = {
			              then: function (resolve, reject) {
			                // Confirm we haven't re-entered another `act` scope, in case
			                // the user does something weird like await the thenable
			                // multiple times.
			                if (ReactCurrentActQueue.current === null) {
			                  // Recursively flush the queue until there's no remaining work.
			                  ReactCurrentActQueue.current = [];
			                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
			                } else {
			                  resolve(returnValue);
			                }
			              }
			            };
			            return _thenable;
			          } else {
			            // Since we're inside a nested `act` scope, the returned thenable
			            // immediately resolves. The outer scope will flush the queue.
			            var _thenable2 = {
			              then: function (resolve, reject) {
			                resolve(returnValue);
			              }
			            };
			            return _thenable2;
			          }
			        }
			      }
			    }
			    function popActScope(prevActScopeDepth) {
			      {
			        if (prevActScopeDepth !== actScopeDepth - 1) {
			          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
			        }
			        actScopeDepth = prevActScopeDepth;
			      }
			    }
			    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
			      {
			        var queue = ReactCurrentActQueue.current;
			        if (queue !== null) {
			          try {
			            flushActQueue(queue);
			            enqueueTask(function () {
			              if (queue.length === 0) {
			                // No additional work was scheduled. Finish.
			                ReactCurrentActQueue.current = null;
			                resolve(returnValue);
			              } else {
			                // Keep flushing work until there's none left.
			                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
			              }
			            });
			          } catch (error) {
			            reject(error);
			          }
			        } else {
			          resolve(returnValue);
			        }
			      }
			    }
			    var isFlushing = false;
			    function flushActQueue(queue) {
			      {
			        if (!isFlushing) {
			          // Prevent re-entrance.
			          isFlushing = true;
			          var i = 0;
			          try {
			            for (; i < queue.length; i++) {
			              var callback = queue[i];
			              do {
			                callback = callback(true);
			              } while (callback !== null);
			            }
			            queue.length = 0;
			          } catch (error) {
			            // If something throws, leave the remaining callbacks on the queue.
			            queue = queue.slice(i + 1);
			            throw error;
			          } finally {
			            isFlushing = false;
			          }
			        }
			      }
			    }
			    var createElement$1 = createElementWithValidation;
			    var cloneElement$1 = cloneElementWithValidation;
			    var createFactory = createFactoryWithValidation;
			    var Children = {
			      map: mapChildren,
			      forEach: forEachChildren,
			      count: countChildren,
			      toArray: toArray,
			      only: onlyChild
			    };
			    exports.Children = Children;
			    exports.Component = Component;
			    exports.Fragment = REACT_FRAGMENT_TYPE;
			    exports.Profiler = REACT_PROFILER_TYPE;
			    exports.PureComponent = PureComponent;
			    exports.StrictMode = REACT_STRICT_MODE_TYPE;
			    exports.Suspense = REACT_SUSPENSE_TYPE;
			    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
			    exports.cloneElement = cloneElement$1;
			    exports.createContext = createContext;
			    exports.createElement = createElement$1;
			    exports.createFactory = createFactory;
			    exports.createRef = createRef;
			    exports.forwardRef = forwardRef;
			    exports.isValidElement = isValidElement;
			    exports.lazy = lazy;
			    exports.memo = memo;
			    exports.startTransition = startTransition;
			    exports.unstable_act = act;
			    exports.useCallback = useCallback;
			    exports.useContext = useContext;
			    exports.useDebugValue = useDebugValue;
			    exports.useDeferredValue = useDeferredValue;
			    exports.useEffect = useEffect;
			    exports.useId = useId;
			    exports.useImperativeHandle = useImperativeHandle;
			    exports.useInsertionEffect = useInsertionEffect;
			    exports.useLayoutEffect = useLayoutEffect;
			    exports.useMemo = useMemo;
			    exports.useReducer = useReducer;
			    exports.useRef = useRef;
			    exports.useState = useState;
			    exports.useSyncExternalStore = useSyncExternalStore;
			    exports.useTransition = useTransition;
			    exports.version = ReactVersion;
			    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
			    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {
			      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
			    }
			  })();
			} 
		} (react_development, react_development.exports));
		return react_development.exports;
	}

	var hasRequiredReact;

	function requireReact () {
		if (hasRequiredReact) return react.exports;
		hasRequiredReact = 1;

		if (process.env.NODE_ENV === 'production') {
		  react.exports = requireReact_production_min();
		} else {
		  react.exports = requireReact_development();
		}
		return react.exports;
	}

	var reactExports = requireReact();
	var React$1 = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

	var buffer = {};

	var base64Js = {};

	var hasRequiredBase64Js;

	function requireBase64Js () {
		if (hasRequiredBase64Js) return base64Js;
		hasRequiredBase64Js = 1;

		base64Js.byteLength = byteLength;
		base64Js.toByteArray = toByteArray;
		base64Js.fromByteArray = fromByteArray;
		var lookup = [];
		var revLookup = [];
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i];
		  revLookup[code.charCodeAt(i)] = i;
		}

		// Support decoding URL-safe base64 strings, as Node.js does.
		// See: https://en.wikipedia.org/wiki/Base64#URL_applications
		revLookup['-'.charCodeAt(0)] = 62;
		revLookup['_'.charCodeAt(0)] = 63;
		function getLens(b64) {
		  var len = b64.length;
		  if (len % 4 > 0) {
		    throw new Error('Invalid string. Length must be a multiple of 4');
		  }

		  // Trim off extra bytes after placeholder bytes are found
		  // See: https://github.com/beatgammit/base64-js/issues/42
		  var validLen = b64.indexOf('=');
		  if (validLen === -1) validLen = len;
		  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
		  return [validLen, placeHoldersLen];
		}

		// base64 is 4/3 + up to two characters of the original data
		function byteLength(b64) {
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function _byteLength(b64, validLen, placeHoldersLen) {
		  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
		}
		function toByteArray(b64) {
		  var tmp;
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
		  var curByte = 0;

		  // if there are placeholders, only get up to the last complete 4 chars
		  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
		  var i;
		  for (i = 0; i < len; i += 4) {
		    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
		    arr[curByte++] = tmp >> 16 & 0xFF;
		    arr[curByte++] = tmp >> 8 & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }
		  if (placeHoldersLen === 2) {
		    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
		    arr[curByte++] = tmp & 0xFF;
		  }
		  if (placeHoldersLen === 1) {
		    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
		    arr[curByte++] = tmp >> 8 & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }
		  return arr;
		}
		function tripletToBase64(num) {
		  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		}
		function encodeChunk(uint8, start, end) {
		  var tmp;
		  var output = [];
		  for (var i = start; i < end; i += 3) {
		    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
		    output.push(tripletToBase64(tmp));
		  }
		  return output.join('');
		}
		function fromByteArray(uint8) {
		  var tmp;
		  var len = uint8.length;
		  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
		  var parts = [];
		  var maxChunkLength = 16383; // must be multiple of 3

		  // go through the array every three bytes, we'll deal with trailing stuff later
		  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
		  }

		  // pad the end with zeros, but make sure to not forget the extra bytes
		  if (extraBytes === 1) {
		    tmp = uint8[len - 1];
		    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
		    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
		  }
		  return parts.join('');
		}
		return base64Js;
	}

	var ieee754 = {};

	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

	var hasRequiredIeee754;

	function requireIeee754 () {
		if (hasRequiredIeee754) return ieee754;
		hasRequiredIeee754 = 1;
		ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var nBits = -7;
		  var i = isLE ? nBytes - 1 : 0;
		  var d = isLE ? -1 : 1;
		  var s = buffer[offset + i];
		  i += d;
		  e = s & (1 << -nBits) - 1;
		  s >>= -nBits;
		  nBits += eLen;
		  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
		  m = e & (1 << -nBits) - 1;
		  e >>= -nBits;
		  nBits += mLen;
		  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
		  if (e === 0) {
		    e = 1 - eBias;
		  } else if (e === eMax) {
		    return m ? NaN : (s ? -1 : 1) * Infinity;
		  } else {
		    m = m + Math.pow(2, mLen);
		    e = e - eBias;
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
		};
		ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c;
		  var eLen = nBytes * 8 - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
		  var i = isLE ? 0 : nBytes - 1;
		  var d = isLE ? 1 : -1;
		  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
		  value = Math.abs(value);
		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0;
		    e = eMax;
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2);
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--;
		      c *= 2;
		    }
		    if (e + eBias >= 1) {
		      value += rt / c;
		    } else {
		      value += rt * Math.pow(2, 1 - eBias);
		    }
		    if (value * c >= 2) {
		      e++;
		      c /= 2;
		    }
		    if (e + eBias >= eMax) {
		      m = 0;
		      e = eMax;
		    } else if (e + eBias >= 1) {
		      m = (value * c - 1) * Math.pow(2, mLen);
		      e = e + eBias;
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
		      e = 0;
		    }
		  }
		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
		  e = e << mLen | m;
		  eLen += mLen;
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
		  buffer[offset + i - d] |= s * 128;
		};
		return ieee754;
	}

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <https://feross.org>
	 * @license  MIT
	 */

	var hasRequiredBuffer;

	function requireBuffer () {
		if (hasRequiredBuffer) return buffer;
		hasRequiredBuffer = 1;
		(function (exports) {

			const base64 = requireBase64Js();
			const ieee754 = requireIeee754();
			const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
			? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
			: null;
			exports.Buffer = Buffer;
			exports.SlowBuffer = SlowBuffer;
			exports.INSPECT_MAX_BYTES = 50;
			const K_MAX_LENGTH = 0x7fffffff;
			exports.kMaxLength = K_MAX_LENGTH;

			/**
			 * If `Buffer.TYPED_ARRAY_SUPPORT`:
			 *   === true    Use Uint8Array implementation (fastest)
			 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
			 *               implementation (most compatible, even IE6)
			 *
			 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
			 * Opera 11.6+, iOS 4.2+.
			 *
			 * We report that the browser does not support typed arrays if the are not subclassable
			 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
			 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
			 * for __proto__ and has a buggy typed array implementation.
			 */
			Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
			if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
			  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
			}
			function typedArraySupport() {
			  // Can typed array instances can be augmented?
			  try {
			    const arr = new Uint8Array(1);
			    const proto = {
			      foo: function () {
			        return 42;
			      }
			    };
			    Object.setPrototypeOf(proto, Uint8Array.prototype);
			    Object.setPrototypeOf(arr, proto);
			    return arr.foo() === 42;
			  } catch (e) {
			    return false;
			  }
			}
			Object.defineProperty(Buffer.prototype, 'parent', {
			  enumerable: true,
			  get: function () {
			    if (!Buffer.isBuffer(this)) return undefined;
			    return this.buffer;
			  }
			});
			Object.defineProperty(Buffer.prototype, 'offset', {
			  enumerable: true,
			  get: function () {
			    if (!Buffer.isBuffer(this)) return undefined;
			    return this.byteOffset;
			  }
			});
			function createBuffer(length) {
			  if (length > K_MAX_LENGTH) {
			    throw new RangeError('The value "' + length + '" is invalid for option "size"');
			  }
			  // Return an augmented `Uint8Array` instance
			  const buf = new Uint8Array(length);
			  Object.setPrototypeOf(buf, Buffer.prototype);
			  return buf;
			}

			/**
			 * The Buffer constructor returns instances of `Uint8Array` that have their
			 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
			 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
			 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
			 * returns a single octet.
			 *
			 * The `Uint8Array` prototype remains unmodified.
			 */

			function Buffer(arg, encodingOrOffset, length) {
			  // Common case.
			  if (typeof arg === 'number') {
			    if (typeof encodingOrOffset === 'string') {
			      throw new TypeError('The "string" argument must be of type string. Received type number');
			    }
			    return allocUnsafe(arg);
			  }
			  return from(arg, encodingOrOffset, length);
			}
			Buffer.poolSize = 8192; // not used by this implementation

			function from(value, encodingOrOffset, length) {
			  if (typeof value === 'string') {
			    return fromString(value, encodingOrOffset);
			  }
			  if (ArrayBuffer.isView(value)) {
			    return fromArrayView(value);
			  }
			  if (value == null) {
			    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
			  }
			  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
			    return fromArrayBuffer(value, encodingOrOffset, length);
			  }
			  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
			    return fromArrayBuffer(value, encodingOrOffset, length);
			  }
			  if (typeof value === 'number') {
			    throw new TypeError('The "value" argument must not be of type number. Received type number');
			  }
			  const valueOf = value.valueOf && value.valueOf();
			  if (valueOf != null && valueOf !== value) {
			    return Buffer.from(valueOf, encodingOrOffset, length);
			  }
			  const b = fromObject(value);
			  if (b) return b;
			  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
			    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
			  }
			  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
			}

			/**
			 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
			 * if value is a number.
			 * Buffer.from(str[, encoding])
			 * Buffer.from(array)
			 * Buffer.from(buffer)
			 * Buffer.from(arrayBuffer[, byteOffset[, length]])
			 **/
			Buffer.from = function (value, encodingOrOffset, length) {
			  return from(value, encodingOrOffset, length);
			};

			// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
			// https://github.com/feross/buffer/pull/148
			Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
			Object.setPrototypeOf(Buffer, Uint8Array);
			function assertSize(size) {
			  if (typeof size !== 'number') {
			    throw new TypeError('"size" argument must be of type number');
			  } else if (size < 0) {
			    throw new RangeError('The value "' + size + '" is invalid for option "size"');
			  }
			}
			function alloc(size, fill, encoding) {
			  assertSize(size);
			  if (size <= 0) {
			    return createBuffer(size);
			  }
			  if (fill !== undefined) {
			    // Only pay attention to encoding if it's a string. This
			    // prevents accidentally sending in a number that would
			    // be interpreted as a start offset.
			    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
			  }
			  return createBuffer(size);
			}

			/**
			 * Creates a new filled Buffer instance.
			 * alloc(size[, fill[, encoding]])
			 **/
			Buffer.alloc = function (size, fill, encoding) {
			  return alloc(size, fill, encoding);
			};
			function allocUnsafe(size) {
			  assertSize(size);
			  return createBuffer(size < 0 ? 0 : checked(size) | 0);
			}

			/**
			 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
			 * */
			Buffer.allocUnsafe = function (size) {
			  return allocUnsafe(size);
			};
			/**
			 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
			 */
			Buffer.allocUnsafeSlow = function (size) {
			  return allocUnsafe(size);
			};
			function fromString(string, encoding) {
			  if (typeof encoding !== 'string' || encoding === '') {
			    encoding = 'utf8';
			  }
			  if (!Buffer.isEncoding(encoding)) {
			    throw new TypeError('Unknown encoding: ' + encoding);
			  }
			  const length = byteLength(string, encoding) | 0;
			  let buf = createBuffer(length);
			  const actual = buf.write(string, encoding);
			  if (actual !== length) {
			    // Writing a hex string, for example, that contains invalid characters will
			    // cause everything after the first invalid character to be ignored. (e.g.
			    // 'abxxcd' will be treated as 'ab')
			    buf = buf.slice(0, actual);
			  }
			  return buf;
			}
			function fromArrayLike(array) {
			  const length = array.length < 0 ? 0 : checked(array.length) | 0;
			  const buf = createBuffer(length);
			  for (let i = 0; i < length; i += 1) {
			    buf[i] = array[i] & 255;
			  }
			  return buf;
			}
			function fromArrayView(arrayView) {
			  if (isInstance(arrayView, Uint8Array)) {
			    const copy = new Uint8Array(arrayView);
			    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
			  }
			  return fromArrayLike(arrayView);
			}
			function fromArrayBuffer(array, byteOffset, length) {
			  if (byteOffset < 0 || array.byteLength < byteOffset) {
			    throw new RangeError('"offset" is outside of buffer bounds');
			  }
			  if (array.byteLength < byteOffset + (length || 0)) {
			    throw new RangeError('"length" is outside of buffer bounds');
			  }
			  let buf;
			  if (byteOffset === undefined && length === undefined) {
			    buf = new Uint8Array(array);
			  } else if (length === undefined) {
			    buf = new Uint8Array(array, byteOffset);
			  } else {
			    buf = new Uint8Array(array, byteOffset, length);
			  }

			  // Return an augmented `Uint8Array` instance
			  Object.setPrototypeOf(buf, Buffer.prototype);
			  return buf;
			}
			function fromObject(obj) {
			  if (Buffer.isBuffer(obj)) {
			    const len = checked(obj.length) | 0;
			    const buf = createBuffer(len);
			    if (buf.length === 0) {
			      return buf;
			    }
			    obj.copy(buf, 0, 0, len);
			    return buf;
			  }
			  if (obj.length !== undefined) {
			    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
			      return createBuffer(0);
			    }
			    return fromArrayLike(obj);
			  }
			  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
			    return fromArrayLike(obj.data);
			  }
			}
			function checked(length) {
			  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
			  // length is NaN (which is otherwise coerced to zero.)
			  if (length >= K_MAX_LENGTH) {
			    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
			  }
			  return length | 0;
			}
			function SlowBuffer(length) {
			  if (+length != length) {
			    // eslint-disable-line eqeqeq
			    length = 0;
			  }
			  return Buffer.alloc(+length);
			}
			Buffer.isBuffer = function isBuffer(b) {
			  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
			};
			Buffer.compare = function compare(a, b) {
			  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
			  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
			  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
			    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
			  }
			  if (a === b) return 0;
			  let x = a.length;
			  let y = b.length;
			  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
			    if (a[i] !== b[i]) {
			      x = a[i];
			      y = b[i];
			      break;
			    }
			  }
			  if (x < y) return -1;
			  if (y < x) return 1;
			  return 0;
			};
			Buffer.isEncoding = function isEncoding(encoding) {
			  switch (String(encoding).toLowerCase()) {
			    case 'hex':
			    case 'utf8':
			    case 'utf-8':
			    case 'ascii':
			    case 'latin1':
			    case 'binary':
			    case 'base64':
			    case 'ucs2':
			    case 'ucs-2':
			    case 'utf16le':
			    case 'utf-16le':
			      return true;
			    default:
			      return false;
			  }
			};
			Buffer.concat = function concat(list, length) {
			  if (!Array.isArray(list)) {
			    throw new TypeError('"list" argument must be an Array of Buffers');
			  }
			  if (list.length === 0) {
			    return Buffer.alloc(0);
			  }
			  let i;
			  if (length === undefined) {
			    length = 0;
			    for (i = 0; i < list.length; ++i) {
			      length += list[i].length;
			    }
			  }
			  const buffer = Buffer.allocUnsafe(length);
			  let pos = 0;
			  for (i = 0; i < list.length; ++i) {
			    let buf = list[i];
			    if (isInstance(buf, Uint8Array)) {
			      if (pos + buf.length > buffer.length) {
			        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
			        buf.copy(buffer, pos);
			      } else {
			        Uint8Array.prototype.set.call(buffer, buf, pos);
			      }
			    } else if (!Buffer.isBuffer(buf)) {
			      throw new TypeError('"list" argument must be an Array of Buffers');
			    } else {
			      buf.copy(buffer, pos);
			    }
			    pos += buf.length;
			  }
			  return buffer;
			};
			function byteLength(string, encoding) {
			  if (Buffer.isBuffer(string)) {
			    return string.length;
			  }
			  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
			    return string.byteLength;
			  }
			  if (typeof string !== 'string') {
			    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
			  }
			  const len = string.length;
			  const mustMatch = arguments.length > 2 && arguments[2] === true;
			  if (!mustMatch && len === 0) return 0;

			  // Use a for loop to avoid recursion
			  let loweredCase = false;
			  for (;;) {
			    switch (encoding) {
			      case 'ascii':
			      case 'latin1':
			      case 'binary':
			        return len;
			      case 'utf8':
			      case 'utf-8':
			        return utf8ToBytes(string).length;
			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return len * 2;
			      case 'hex':
			        return len >>> 1;
			      case 'base64':
			        return base64ToBytes(string).length;
			      default:
			        if (loweredCase) {
			          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
			        }
			        encoding = ('' + encoding).toLowerCase();
			        loweredCase = true;
			    }
			  }
			}
			Buffer.byteLength = byteLength;
			function slowToString(encoding, start, end) {
			  let loweredCase = false;

			  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
			  // property of a typed array.

			  // This behaves neither like String nor Uint8Array in that we set start/end
			  // to their upper/lower bounds if the value passed is out of range.
			  // undefined is handled specially as per ECMA-262 6th Edition,
			  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
			  if (start === undefined || start < 0) {
			    start = 0;
			  }
			  // Return early if start > this.length. Done here to prevent potential uint32
			  // coercion fail below.
			  if (start > this.length) {
			    return '';
			  }
			  if (end === undefined || end > this.length) {
			    end = this.length;
			  }
			  if (end <= 0) {
			    return '';
			  }

			  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
			  end >>>= 0;
			  start >>>= 0;
			  if (end <= start) {
			    return '';
			  }
			  if (!encoding) encoding = 'utf8';
			  while (true) {
			    switch (encoding) {
			      case 'hex':
			        return hexSlice(this, start, end);
			      case 'utf8':
			      case 'utf-8':
			        return utf8Slice(this, start, end);
			      case 'ascii':
			        return asciiSlice(this, start, end);
			      case 'latin1':
			      case 'binary':
			        return latin1Slice(this, start, end);
			      case 'base64':
			        return base64Slice(this, start, end);
			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return utf16leSlice(this, start, end);
			      default:
			        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
			        encoding = (encoding + '').toLowerCase();
			        loweredCase = true;
			    }
			  }
			}

			// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
			// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
			// reliably in a browserify context because there could be multiple different
			// copies of the 'buffer' package in use. This method works even for Buffer
			// instances that were created from another copy of the `buffer` package.
			// See: https://github.com/feross/buffer/issues/154
			Buffer.prototype._isBuffer = true;
			function swap(b, n, m) {
			  const i = b[n];
			  b[n] = b[m];
			  b[m] = i;
			}
			Buffer.prototype.swap16 = function swap16() {
			  const len = this.length;
			  if (len % 2 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 16-bits');
			  }
			  for (let i = 0; i < len; i += 2) {
			    swap(this, i, i + 1);
			  }
			  return this;
			};
			Buffer.prototype.swap32 = function swap32() {
			  const len = this.length;
			  if (len % 4 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 32-bits');
			  }
			  for (let i = 0; i < len; i += 4) {
			    swap(this, i, i + 3);
			    swap(this, i + 1, i + 2);
			  }
			  return this;
			};
			Buffer.prototype.swap64 = function swap64() {
			  const len = this.length;
			  if (len % 8 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 64-bits');
			  }
			  for (let i = 0; i < len; i += 8) {
			    swap(this, i, i + 7);
			    swap(this, i + 1, i + 6);
			    swap(this, i + 2, i + 5);
			    swap(this, i + 3, i + 4);
			  }
			  return this;
			};
			Buffer.prototype.toString = function toString() {
			  const length = this.length;
			  if (length === 0) return '';
			  if (arguments.length === 0) return utf8Slice(this, 0, length);
			  return slowToString.apply(this, arguments);
			};
			Buffer.prototype.toLocaleString = Buffer.prototype.toString;
			Buffer.prototype.equals = function equals(b) {
			  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
			  if (this === b) return true;
			  return Buffer.compare(this, b) === 0;
			};
			Buffer.prototype.inspect = function inspect() {
			  let str = '';
			  const max = exports.INSPECT_MAX_BYTES;
			  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
			  if (this.length > max) str += ' ... ';
			  return '<Buffer ' + str + '>';
			};
			if (customInspectSymbol) {
			  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
			}
			Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
			  if (isInstance(target, Uint8Array)) {
			    target = Buffer.from(target, target.offset, target.byteLength);
			  }
			  if (!Buffer.isBuffer(target)) {
			    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
			  }
			  if (start === undefined) {
			    start = 0;
			  }
			  if (end === undefined) {
			    end = target ? target.length : 0;
			  }
			  if (thisStart === undefined) {
			    thisStart = 0;
			  }
			  if (thisEnd === undefined) {
			    thisEnd = this.length;
			  }
			  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
			    throw new RangeError('out of range index');
			  }
			  if (thisStart >= thisEnd && start >= end) {
			    return 0;
			  }
			  if (thisStart >= thisEnd) {
			    return -1;
			  }
			  if (start >= end) {
			    return 1;
			  }
			  start >>>= 0;
			  end >>>= 0;
			  thisStart >>>= 0;
			  thisEnd >>>= 0;
			  if (this === target) return 0;
			  let x = thisEnd - thisStart;
			  let y = end - start;
			  const len = Math.min(x, y);
			  const thisCopy = this.slice(thisStart, thisEnd);
			  const targetCopy = target.slice(start, end);
			  for (let i = 0; i < len; ++i) {
			    if (thisCopy[i] !== targetCopy[i]) {
			      x = thisCopy[i];
			      y = targetCopy[i];
			      break;
			    }
			  }
			  if (x < y) return -1;
			  if (y < x) return 1;
			  return 0;
			};

			// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
			// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
			//
			// Arguments:
			// - buffer - a Buffer to search
			// - val - a string, Buffer, or number
			// - byteOffset - an index into `buffer`; will be clamped to an int32
			// - encoding - an optional encoding, relevant is val is a string
			// - dir - true for indexOf, false for lastIndexOf
			function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
			  // Empty buffer means no match
			  if (buffer.length === 0) return -1;

			  // Normalize byteOffset
			  if (typeof byteOffset === 'string') {
			    encoding = byteOffset;
			    byteOffset = 0;
			  } else if (byteOffset > 0x7fffffff) {
			    byteOffset = 0x7fffffff;
			  } else if (byteOffset < -0x80000000) {
			    byteOffset = -0x80000000;
			  }
			  byteOffset = +byteOffset; // Coerce to Number.
			  if (numberIsNaN(byteOffset)) {
			    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
			    byteOffset = dir ? 0 : buffer.length - 1;
			  }

			  // Normalize byteOffset: negative offsets start from the end of the buffer
			  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
			  if (byteOffset >= buffer.length) {
			    if (dir) return -1;else byteOffset = buffer.length - 1;
			  } else if (byteOffset < 0) {
			    if (dir) byteOffset = 0;else return -1;
			  }

			  // Normalize val
			  if (typeof val === 'string') {
			    val = Buffer.from(val, encoding);
			  }

			  // Finally, search either indexOf (if dir is true) or lastIndexOf
			  if (Buffer.isBuffer(val)) {
			    // Special case: looking for empty string/buffer always fails
			    if (val.length === 0) {
			      return -1;
			    }
			    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
			  } else if (typeof val === 'number') {
			    val = val & 0xFF; // Search for a byte value [0-255]
			    if (typeof Uint8Array.prototype.indexOf === 'function') {
			      if (dir) {
			        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
			      } else {
			        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
			      }
			    }
			    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
			  }
			  throw new TypeError('val must be string, number or Buffer');
			}
			function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
			  let indexSize = 1;
			  let arrLength = arr.length;
			  let valLength = val.length;
			  if (encoding !== undefined) {
			    encoding = String(encoding).toLowerCase();
			    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
			      if (arr.length < 2 || val.length < 2) {
			        return -1;
			      }
			      indexSize = 2;
			      arrLength /= 2;
			      valLength /= 2;
			      byteOffset /= 2;
			    }
			  }
			  function read(buf, i) {
			    if (indexSize === 1) {
			      return buf[i];
			    } else {
			      return buf.readUInt16BE(i * indexSize);
			    }
			  }
			  let i;
			  if (dir) {
			    let foundIndex = -1;
			    for (i = byteOffset; i < arrLength; i++) {
			      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
			        if (foundIndex === -1) foundIndex = i;
			        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
			      } else {
			        if (foundIndex !== -1) i -= i - foundIndex;
			        foundIndex = -1;
			      }
			    }
			  } else {
			    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
			    for (i = byteOffset; i >= 0; i--) {
			      let found = true;
			      for (let j = 0; j < valLength; j++) {
			        if (read(arr, i + j) !== read(val, j)) {
			          found = false;
			          break;
			        }
			      }
			      if (found) return i;
			    }
			  }
			  return -1;
			}
			Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
			  return this.indexOf(val, byteOffset, encoding) !== -1;
			};
			Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
			  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
			};
			Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
			  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
			};
			function hexWrite(buf, string, offset, length) {
			  offset = Number(offset) || 0;
			  const remaining = buf.length - offset;
			  if (!length) {
			    length = remaining;
			  } else {
			    length = Number(length);
			    if (length > remaining) {
			      length = remaining;
			    }
			  }
			  const strLen = string.length;
			  if (length > strLen / 2) {
			    length = strLen / 2;
			  }
			  let i;
			  for (i = 0; i < length; ++i) {
			    const parsed = parseInt(string.substr(i * 2, 2), 16);
			    if (numberIsNaN(parsed)) return i;
			    buf[offset + i] = parsed;
			  }
			  return i;
			}
			function utf8Write(buf, string, offset, length) {
			  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
			}
			function asciiWrite(buf, string, offset, length) {
			  return blitBuffer(asciiToBytes(string), buf, offset, length);
			}
			function base64Write(buf, string, offset, length) {
			  return blitBuffer(base64ToBytes(string), buf, offset, length);
			}
			function ucs2Write(buf, string, offset, length) {
			  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
			}
			Buffer.prototype.write = function write(string, offset, length, encoding) {
			  // Buffer#write(string)
			  if (offset === undefined) {
			    encoding = 'utf8';
			    length = this.length;
			    offset = 0;
			    // Buffer#write(string, encoding)
			  } else if (length === undefined && typeof offset === 'string') {
			    encoding = offset;
			    length = this.length;
			    offset = 0;
			    // Buffer#write(string, offset[, length][, encoding])
			  } else if (isFinite(offset)) {
			    offset = offset >>> 0;
			    if (isFinite(length)) {
			      length = length >>> 0;
			      if (encoding === undefined) encoding = 'utf8';
			    } else {
			      encoding = length;
			      length = undefined;
			    }
			  } else {
			    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
			  }
			  const remaining = this.length - offset;
			  if (length === undefined || length > remaining) length = remaining;
			  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
			    throw new RangeError('Attempt to write outside buffer bounds');
			  }
			  if (!encoding) encoding = 'utf8';
			  let loweredCase = false;
			  for (;;) {
			    switch (encoding) {
			      case 'hex':
			        return hexWrite(this, string, offset, length);
			      case 'utf8':
			      case 'utf-8':
			        return utf8Write(this, string, offset, length);
			      case 'ascii':
			      case 'latin1':
			      case 'binary':
			        return asciiWrite(this, string, offset, length);
			      case 'base64':
			        // Warning: maxLength not taken into account in base64Write
			        return base64Write(this, string, offset, length);
			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return ucs2Write(this, string, offset, length);
			      default:
			        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
			        encoding = ('' + encoding).toLowerCase();
			        loweredCase = true;
			    }
			  }
			};
			Buffer.prototype.toJSON = function toJSON() {
			  return {
			    type: 'Buffer',
			    data: Array.prototype.slice.call(this._arr || this, 0)
			  };
			};
			function base64Slice(buf, start, end) {
			  if (start === 0 && end === buf.length) {
			    return base64.fromByteArray(buf);
			  } else {
			    return base64.fromByteArray(buf.slice(start, end));
			  }
			}
			function utf8Slice(buf, start, end) {
			  end = Math.min(buf.length, end);
			  const res = [];
			  let i = start;
			  while (i < end) {
			    const firstByte = buf[i];
			    let codePoint = null;
			    let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
			    if (i + bytesPerSequence <= end) {
			      let secondByte, thirdByte, fourthByte, tempCodePoint;
			      switch (bytesPerSequence) {
			        case 1:
			          if (firstByte < 0x80) {
			            codePoint = firstByte;
			          }
			          break;
			        case 2:
			          secondByte = buf[i + 1];
			          if ((secondByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
			            if (tempCodePoint > 0x7F) {
			              codePoint = tempCodePoint;
			            }
			          }
			          break;
			        case 3:
			          secondByte = buf[i + 1];
			          thirdByte = buf[i + 2];
			          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
			            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
			              codePoint = tempCodePoint;
			            }
			          }
			          break;
			        case 4:
			          secondByte = buf[i + 1];
			          thirdByte = buf[i + 2];
			          fourthByte = buf[i + 3];
			          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
			            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
			              codePoint = tempCodePoint;
			            }
			          }
			      }
			    }
			    if (codePoint === null) {
			      // we did not generate a valid codePoint so insert a
			      // replacement char (U+FFFD) and advance only 1 byte
			      codePoint = 0xFFFD;
			      bytesPerSequence = 1;
			    } else if (codePoint > 0xFFFF) {
			      // encode to utf16 (surrogate pair dance)
			      codePoint -= 0x10000;
			      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
			      codePoint = 0xDC00 | codePoint & 0x3FF;
			    }
			    res.push(codePoint);
			    i += bytesPerSequence;
			  }
			  return decodeCodePointsArray(res);
			}

			// Based on http://stackoverflow.com/a/22747272/680742, the browser with
			// the lowest limit is Chrome, with 0x10000 args.
			// We go 1 magnitude less, for safety
			const MAX_ARGUMENTS_LENGTH = 0x1000;
			function decodeCodePointsArray(codePoints) {
			  const len = codePoints.length;
			  if (len <= MAX_ARGUMENTS_LENGTH) {
			    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
			  }

			  // Decode in chunks to avoid "call stack size exceeded".
			  let res = '';
			  let i = 0;
			  while (i < len) {
			    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
			  }
			  return res;
			}
			function asciiSlice(buf, start, end) {
			  let ret = '';
			  end = Math.min(buf.length, end);
			  for (let i = start; i < end; ++i) {
			    ret += String.fromCharCode(buf[i] & 0x7F);
			  }
			  return ret;
			}
			function latin1Slice(buf, start, end) {
			  let ret = '';
			  end = Math.min(buf.length, end);
			  for (let i = start; i < end; ++i) {
			    ret += String.fromCharCode(buf[i]);
			  }
			  return ret;
			}
			function hexSlice(buf, start, end) {
			  const len = buf.length;
			  if (!start || start < 0) start = 0;
			  if (!end || end < 0 || end > len) end = len;
			  let out = '';
			  for (let i = start; i < end; ++i) {
			    out += hexSliceLookupTable[buf[i]];
			  }
			  return out;
			}
			function utf16leSlice(buf, start, end) {
			  const bytes = buf.slice(start, end);
			  let res = '';
			  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
			  for (let i = 0; i < bytes.length - 1; i += 2) {
			    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
			  }
			  return res;
			}
			Buffer.prototype.slice = function slice(start, end) {
			  const len = this.length;
			  start = ~~start;
			  end = end === undefined ? len : ~~end;
			  if (start < 0) {
			    start += len;
			    if (start < 0) start = 0;
			  } else if (start > len) {
			    start = len;
			  }
			  if (end < 0) {
			    end += len;
			    if (end < 0) end = 0;
			  } else if (end > len) {
			    end = len;
			  }
			  if (end < start) end = start;
			  const newBuf = this.subarray(start, end);
			  // Return an augmented `Uint8Array` instance
			  Object.setPrototypeOf(newBuf, Buffer.prototype);
			  return newBuf;
			};

			/*
			 * Need to make sure that buffer isn't trying to write out of bounds.
			 */
			function checkOffset(offset, ext, length) {
			  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
			  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
			}
			Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);
			  let val = this[offset];
			  let mul = 1;
			  let i = 0;
			  while (++i < byteLength && (mul *= 0x100)) {
			    val += this[offset + i] * mul;
			  }
			  return val;
			};
			Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    checkOffset(offset, byteLength, this.length);
			  }
			  let val = this[offset + --byteLength];
			  let mul = 1;
			  while (byteLength > 0 && (mul *= 0x100)) {
			    val += this[offset + --byteLength] * mul;
			  }
			  return val;
			};
			Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 1, this.length);
			  return this[offset];
			};
			Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  return this[offset] | this[offset + 1] << 8;
			};
			Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  return this[offset] << 8 | this[offset + 1];
			};
			Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
			};
			Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
			};
			Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }
			  const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
			  const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
			  return BigInt(lo) + (BigInt(hi) << BigInt(32));
			});
			Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }
			  const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
			  const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
			  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
			});
			Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);
			  let val = this[offset];
			  let mul = 1;
			  let i = 0;
			  while (++i < byteLength && (mul *= 0x100)) {
			    val += this[offset + i] * mul;
			  }
			  mul *= 0x80;
			  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
			  return val;
			};
			Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);
			  let i = byteLength;
			  let mul = 1;
			  let val = this[offset + --i];
			  while (i > 0 && (mul *= 0x100)) {
			    val += this[offset + --i] * mul;
			  }
			  mul *= 0x80;
			  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
			  return val;
			};
			Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 1, this.length);
			  if (!(this[offset] & 0x80)) return this[offset];
			  return (0xff - this[offset] + 1) * -1;
			};
			Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  const val = this[offset] | this[offset + 1] << 8;
			  return val & 0x8000 ? val | 0xFFFF0000 : val;
			};
			Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  const val = this[offset + 1] | this[offset] << 8;
			  return val & 0x8000 ? val | 0xFFFF0000 : val;
			};
			Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
			};
			Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
			};
			Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }
			  const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24); // Overflow

			  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
			});
			Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }
			  const val = (first << 24) +
			  // Overflow
			  this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
			  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
			});
			Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return ieee754.read(this, offset, true, 23, 4);
			};
			Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return ieee754.read(this, offset, false, 23, 4);
			};
			Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 8, this.length);
			  return ieee754.read(this, offset, true, 52, 8);
			};
			Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 8, this.length);
			  return ieee754.read(this, offset, false, 52, 8);
			};
			function checkInt(buf, value, offset, ext, max, min) {
			  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
			  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
			  if (offset + ext > buf.length) throw new RangeError('Index out of range');
			}
			Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
			    checkInt(this, value, offset, byteLength, maxBytes, 0);
			  }
			  let mul = 1;
			  let i = 0;
			  this[offset] = value & 0xFF;
			  while (++i < byteLength && (mul *= 0x100)) {
			    this[offset + i] = value / mul & 0xFF;
			  }
			  return offset + byteLength;
			};
			Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
			    checkInt(this, value, offset, byteLength, maxBytes, 0);
			  }
			  let i = byteLength - 1;
			  let mul = 1;
			  this[offset + i] = value & 0xFF;
			  while (--i >= 0 && (mul *= 0x100)) {
			    this[offset + i] = value / mul & 0xFF;
			  }
			  return offset + byteLength;
			};
			Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
			  this[offset] = value & 0xff;
			  return offset + 1;
			};
			Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
			  this[offset] = value & 0xff;
			  this[offset + 1] = value >>> 8;
			  return offset + 2;
			};
			Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
			  this[offset] = value >>> 8;
			  this[offset + 1] = value & 0xff;
			  return offset + 2;
			};
			Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
			  this[offset + 3] = value >>> 24;
			  this[offset + 2] = value >>> 16;
			  this[offset + 1] = value >>> 8;
			  this[offset] = value & 0xff;
			  return offset + 4;
			};
			Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
			  this[offset] = value >>> 24;
			  this[offset + 1] = value >>> 16;
			  this[offset + 2] = value >>> 8;
			  this[offset + 3] = value & 0xff;
			  return offset + 4;
			};
			function wrtBigUInt64LE(buf, value, offset, min, max) {
			  checkIntBI(value, min, max, buf, offset, 7);
			  let lo = Number(value & BigInt(0xffffffff));
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  return offset;
			}
			function wrtBigUInt64BE(buf, value, offset, min, max) {
			  checkIntBI(value, min, max, buf, offset, 7);
			  let lo = Number(value & BigInt(0xffffffff));
			  buf[offset + 7] = lo;
			  lo = lo >> 8;
			  buf[offset + 6] = lo;
			  lo = lo >> 8;
			  buf[offset + 5] = lo;
			  lo = lo >> 8;
			  buf[offset + 4] = lo;
			  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
			  buf[offset + 3] = hi;
			  hi = hi >> 8;
			  buf[offset + 2] = hi;
			  hi = hi >> 8;
			  buf[offset + 1] = hi;
			  hi = hi >> 8;
			  buf[offset] = hi;
			  return offset + 8;
			}
			Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
			  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
			});
			Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
			  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
			});
			Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    const limit = Math.pow(2, 8 * byteLength - 1);
			    checkInt(this, value, offset, byteLength, limit - 1, -limit);
			  }
			  let i = 0;
			  let mul = 1;
			  let sub = 0;
			  this[offset] = value & 0xFF;
			  while (++i < byteLength && (mul *= 0x100)) {
			    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
			      sub = 1;
			    }
			    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
			  }
			  return offset + byteLength;
			};
			Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    const limit = Math.pow(2, 8 * byteLength - 1);
			    checkInt(this, value, offset, byteLength, limit - 1, -limit);
			  }
			  let i = byteLength - 1;
			  let mul = 1;
			  let sub = 0;
			  this[offset + i] = value & 0xFF;
			  while (--i >= 0 && (mul *= 0x100)) {
			    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
			      sub = 1;
			    }
			    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
			  }
			  return offset + byteLength;
			};
			Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
			  if (value < 0) value = 0xff + value + 1;
			  this[offset] = value & 0xff;
			  return offset + 1;
			};
			Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
			  this[offset] = value & 0xff;
			  this[offset + 1] = value >>> 8;
			  return offset + 2;
			};
			Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
			  this[offset] = value >>> 8;
			  this[offset + 1] = value & 0xff;
			  return offset + 2;
			};
			Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
			  this[offset] = value & 0xff;
			  this[offset + 1] = value >>> 8;
			  this[offset + 2] = value >>> 16;
			  this[offset + 3] = value >>> 24;
			  return offset + 4;
			};
			Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
			  if (value < 0) value = 0xffffffff + value + 1;
			  this[offset] = value >>> 24;
			  this[offset + 1] = value >>> 16;
			  this[offset + 2] = value >>> 8;
			  this[offset + 3] = value & 0xff;
			  return offset + 4;
			};
			Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
			  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
			});
			Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
			  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
			});
			function checkIEEE754(buf, value, offset, ext, max, min) {
			  if (offset + ext > buf.length) throw new RangeError('Index out of range');
			  if (offset < 0) throw new RangeError('Index out of range');
			}
			function writeFloat(buf, value, offset, littleEndian, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    checkIEEE754(buf, value, offset, 4);
			  }
			  ieee754.write(buf, value, offset, littleEndian, 23, 4);
			  return offset + 4;
			}
			Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
			  return writeFloat(this, value, offset, true, noAssert);
			};
			Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
			  return writeFloat(this, value, offset, false, noAssert);
			};
			function writeDouble(buf, value, offset, littleEndian, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    checkIEEE754(buf, value, offset, 8);
			  }
			  ieee754.write(buf, value, offset, littleEndian, 52, 8);
			  return offset + 8;
			}
			Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
			  return writeDouble(this, value, offset, true, noAssert);
			};
			Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
			  return writeDouble(this, value, offset, false, noAssert);
			};

			// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
			Buffer.prototype.copy = function copy(target, targetStart, start, end) {
			  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
			  if (!start) start = 0;
			  if (!end && end !== 0) end = this.length;
			  if (targetStart >= target.length) targetStart = target.length;
			  if (!targetStart) targetStart = 0;
			  if (end > 0 && end < start) end = start;

			  // Copy 0 bytes; we're done
			  if (end === start) return 0;
			  if (target.length === 0 || this.length === 0) return 0;

			  // Fatal error conditions
			  if (targetStart < 0) {
			    throw new RangeError('targetStart out of bounds');
			  }
			  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
			  if (end < 0) throw new RangeError('sourceEnd out of bounds');

			  // Are we oob?
			  if (end > this.length) end = this.length;
			  if (target.length - targetStart < end - start) {
			    end = target.length - targetStart + start;
			  }
			  const len = end - start;
			  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
			    // Use built-in when available, missing from IE11
			    this.copyWithin(targetStart, start, end);
			  } else {
			    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
			  }
			  return len;
			};

			// Usage:
			//    buffer.fill(number[, offset[, end]])
			//    buffer.fill(buffer[, offset[, end]])
			//    buffer.fill(string[, offset[, end]][, encoding])
			Buffer.prototype.fill = function fill(val, start, end, encoding) {
			  // Handle string cases:
			  if (typeof val === 'string') {
			    if (typeof start === 'string') {
			      encoding = start;
			      start = 0;
			      end = this.length;
			    } else if (typeof end === 'string') {
			      encoding = end;
			      end = this.length;
			    }
			    if (encoding !== undefined && typeof encoding !== 'string') {
			      throw new TypeError('encoding must be a string');
			    }
			    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
			      throw new TypeError('Unknown encoding: ' + encoding);
			    }
			    if (val.length === 1) {
			      const code = val.charCodeAt(0);
			      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
			        // Fast path: If `val` fits into a single byte, use that numeric value.
			        val = code;
			      }
			    }
			  } else if (typeof val === 'number') {
			    val = val & 255;
			  } else if (typeof val === 'boolean') {
			    val = Number(val);
			  }

			  // Invalid ranges are not set to a default, so can range check early.
			  if (start < 0 || this.length < start || this.length < end) {
			    throw new RangeError('Out of range index');
			  }
			  if (end <= start) {
			    return this;
			  }
			  start = start >>> 0;
			  end = end === undefined ? this.length : end >>> 0;
			  if (!val) val = 0;
			  let i;
			  if (typeof val === 'number') {
			    for (i = start; i < end; ++i) {
			      this[i] = val;
			    }
			  } else {
			    const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
			    const len = bytes.length;
			    if (len === 0) {
			      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
			    }
			    for (i = 0; i < end - start; ++i) {
			      this[i + start] = bytes[i % len];
			    }
			  }
			  return this;
			};

			// CUSTOM ERRORS
			// =============

			// Simplified versions from Node, changed for Buffer-only usage
			const errors = {};
			function E(sym, getMessage, Base) {
			  errors[sym] = class NodeError extends Base {
			    constructor() {
			      super();
			      Object.defineProperty(this, 'message', {
			        value: getMessage.apply(this, arguments),
			        writable: true,
			        configurable: true
			      });

			      // Add the error code to the name to include it in the stack trace.
			      this.name = `${this.name} [${sym}]`;
			      // Access the stack to generate the error message including the error code
			      // from the name.
			      this.stack; // eslint-disable-line no-unused-expressions
			      // Reset the name to the actual name.
			      delete this.name;
			    }
			    get code() {
			      return sym;
			    }
			    set code(value) {
			      Object.defineProperty(this, 'code', {
			        configurable: true,
			        enumerable: true,
			        value,
			        writable: true
			      });
			    }
			    toString() {
			      return `${this.name} [${sym}]: ${this.message}`;
			    }
			  };
			}
			E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
			  if (name) {
			    return `${name} is outside of buffer bounds`;
			  }
			  return 'Attempt to access memory outside buffer bounds';
			}, RangeError);
			E('ERR_INVALID_ARG_TYPE', function (name, actual) {
			  return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
			}, TypeError);
			E('ERR_OUT_OF_RANGE', function (str, range, input) {
			  let msg = `The value of "${str}" is out of range.`;
			  let received = input;
			  if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
			    received = addNumericalSeparator(String(input));
			  } else if (typeof input === 'bigint') {
			    received = String(input);
			    if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
			      received = addNumericalSeparator(received);
			    }
			    received += 'n';
			  }
			  msg += ` It must be ${range}. Received ${received}`;
			  return msg;
			}, RangeError);
			function addNumericalSeparator(val) {
			  let res = '';
			  let i = val.length;
			  const start = val[0] === '-' ? 1 : 0;
			  for (; i >= start + 4; i -= 3) {
			    res = `_${val.slice(i - 3, i)}${res}`;
			  }
			  return `${val.slice(0, i)}${res}`;
			}

			// CHECK FUNCTIONS
			// ===============

			function checkBounds(buf, offset, byteLength) {
			  validateNumber(offset, 'offset');
			  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
			    boundsError(offset, buf.length - (byteLength + 1));
			  }
			}
			function checkIntBI(value, min, max, buf, offset, byteLength) {
			  if (value > max || value < min) {
			    const n = typeof min === 'bigint' ? 'n' : '';
			    let range;
			    if (byteLength > 3) {
			      if (min === 0 || min === BigInt(0)) {
			        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
			      } else {
			        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
			      }
			    } else {
			      range = `>= ${min}${n} and <= ${max}${n}`;
			    }
			    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
			  }
			  checkBounds(buf, offset, byteLength);
			}
			function validateNumber(value, name) {
			  if (typeof value !== 'number') {
			    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
			  }
			}
			function boundsError(value, length, type) {
			  if (Math.floor(value) !== value) {
			    validateNumber(value, type);
			    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
			  }
			  if (length < 0) {
			    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
			  }
			  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
			}

			// HELPER FUNCTIONS
			// ================

			const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
			function base64clean(str) {
			  // Node takes equal signs as end of the Base64 encoding
			  str = str.split('=')[0];
			  // Node strips out invalid characters like \n and \t from the string, base64-js does not
			  str = str.trim().replace(INVALID_BASE64_RE, '');
			  // Node converts strings with length < 2 to ''
			  if (str.length < 2) return '';
			  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
			  while (str.length % 4 !== 0) {
			    str = str + '=';
			  }
			  return str;
			}
			function utf8ToBytes(string, units) {
			  units = units || Infinity;
			  let codePoint;
			  const length = string.length;
			  let leadSurrogate = null;
			  const bytes = [];
			  for (let i = 0; i < length; ++i) {
			    codePoint = string.charCodeAt(i);

			    // is surrogate component
			    if (codePoint > 0xD7FF && codePoint < 0xE000) {
			      // last char was a lead
			      if (!leadSurrogate) {
			        // no lead yet
			        if (codePoint > 0xDBFF) {
			          // unexpected trail
			          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			          continue;
			        } else if (i + 1 === length) {
			          // unpaired lead
			          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			          continue;
			        }

			        // valid lead
			        leadSurrogate = codePoint;
			        continue;
			      }

			      // 2 leads in a row
			      if (codePoint < 0xDC00) {
			        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			        leadSurrogate = codePoint;
			        continue;
			      }

			      // valid surrogate pair
			      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
			    } else if (leadSurrogate) {
			      // valid bmp char, but last char was a lead
			      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			    }
			    leadSurrogate = null;

			    // encode utf8
			    if (codePoint < 0x80) {
			      if ((units -= 1) < 0) break;
			      bytes.push(codePoint);
			    } else if (codePoint < 0x800) {
			      if ((units -= 2) < 0) break;
			      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
			    } else if (codePoint < 0x10000) {
			      if ((units -= 3) < 0) break;
			      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
			    } else if (codePoint < 0x110000) {
			      if ((units -= 4) < 0) break;
			      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
			    } else {
			      throw new Error('Invalid code point');
			    }
			  }
			  return bytes;
			}
			function asciiToBytes(str) {
			  const byteArray = [];
			  for (let i = 0; i < str.length; ++i) {
			    // Node's code seems to be doing this and not & 0x7F..
			    byteArray.push(str.charCodeAt(i) & 0xFF);
			  }
			  return byteArray;
			}
			function utf16leToBytes(str, units) {
			  let c, hi, lo;
			  const byteArray = [];
			  for (let i = 0; i < str.length; ++i) {
			    if ((units -= 2) < 0) break;
			    c = str.charCodeAt(i);
			    hi = c >> 8;
			    lo = c % 256;
			    byteArray.push(lo);
			    byteArray.push(hi);
			  }
			  return byteArray;
			}
			function base64ToBytes(str) {
			  return base64.toByteArray(base64clean(str));
			}
			function blitBuffer(src, dst, offset, length) {
			  let i;
			  for (i = 0; i < length; ++i) {
			    if (i + offset >= dst.length || i >= src.length) break;
			    dst[i + offset] = src[i];
			  }
			  return i;
			}

			// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
			// the `instanceof` check but they should be treated as of that type.
			// See: https://github.com/feross/buffer/issues/166
			function isInstance(obj, type) {
			  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
			}
			function numberIsNaN(obj) {
			  // For IE11 support
			  return obj !== obj; // eslint-disable-line no-self-compare
			}

			// Create lookup table for `toString('hex')`
			// See: https://github.com/feross/buffer/issues/219
			const hexSliceLookupTable = function () {
			  const alphabet = '0123456789abcdef';
			  const table = new Array(256);
			  for (let i = 0; i < 16; ++i) {
			    const i16 = i * 16;
			    for (let j = 0; j < 16; ++j) {
			      table[i16 + j] = alphabet[i] + alphabet[j];
			    }
			  }
			  return table;
			}();

			// Return not function with Error if BigInt not supported
			function defineBigIntMethod(fn) {
			  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
			}
			function BufferBigIntNotDefined() {
			  throw new Error('BigInt not supported');
			} 
		} (buffer));
		return buffer;
	}

	var bufferExports = requireBuffer();

	function e(e, t) {
	  var i = {};
	  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (i[o] = e[o]);
	  if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
	    var n = 0;
	    for (o = Object.getOwnPropertySymbols(e); n < o.length; n++) t.indexOf(o[n]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[n]) && (i[o[n]] = e[o[n]]);
	  }
	  return i;
	}
	"function" == typeof SuppressedError && SuppressedError;
	var t = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
	function i(e) {
	  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
	}
	function o(e, t) {
	  return e(t = {
	    exports: {}
	  }, t.exports), t.exports;
	}
	var n = o(function (e, t) {
	  Object.defineProperty(t, "__esModule", {
	    value: !0
	  });
	  var i = function () {
	    function e() {
	      var e = this;
	      this.locked = new Map(), this.addToLocked = function (t, i) {
	        var o = e.locked.get(t);
	        void 0 === o ? void 0 === i ? e.locked.set(t, []) : e.locked.set(t, [i]) : void 0 !== i && (o.unshift(i), e.locked.set(t, o));
	      }, this.isLocked = function (t) {
	        return e.locked.has(t);
	      }, this.lock = function (t) {
	        return new Promise(function (i, o) {
	          e.isLocked(t) ? e.addToLocked(t, i) : (e.addToLocked(t), i());
	        });
	      }, this.unlock = function (t) {
	        var i = e.locked.get(t);
	        if (void 0 !== i && 0 !== i.length) {
	          var o = i.pop();
	          e.locked.set(t, i), void 0 !== o && setTimeout(o, 0);
	        } else e.locked.delete(t);
	      };
	    }
	    return e.getInstance = function () {
	      return void 0 === e.instance && (e.instance = new e()), e.instance;
	    }, e;
	  }();
	  t.default = function () {
	    return i.getInstance();
	  };
	});
	i(n);
	var a = i(o(function (e, i) {
	  var o = t && t.__awaiter || function (e, t, i, o) {
	      return new (i || (i = Promise))(function (n, a) {
	        function r(e) {
	          try {
	            c(o.next(e));
	          } catch (e) {
	            a(e);
	          }
	        }
	        function s(e) {
	          try {
	            c(o.throw(e));
	          } catch (e) {
	            a(e);
	          }
	        }
	        function c(e) {
	          e.done ? n(e.value) : new i(function (t) {
	            t(e.value);
	          }).then(r, s);
	        }
	        c((o = o.apply(e, t || [])).next());
	      });
	    },
	    a = t && t.__generator || function (e, t) {
	      var i,
	        o,
	        n,
	        a,
	        r = {
	          label: 0,
	          sent: function () {
	            if (1 & n[0]) throw n[1];
	            return n[1];
	          },
	          trys: [],
	          ops: []
	        };
	      return a = {
	        next: s(0),
	        throw: s(1),
	        return: s(2)
	      }, "function" == typeof Symbol && (a[Symbol.iterator] = function () {
	        return this;
	      }), a;
	      function s(a) {
	        return function (s) {
	          return function (a) {
	            if (i) throw new TypeError("Generator is already executing.");
	            for (; r;) try {
	              if (i = 1, o && (n = 2 & a[0] ? o.return : a[0] ? o.throw || ((n = o.return) && n.call(o), 0) : o.next) && !(n = n.call(o, a[1])).done) return n;
	              switch (o = 0, n && (a = [2 & a[0], n.value]), a[0]) {
	                case 0:
	                case 1:
	                  n = a;
	                  break;
	                case 4:
	                  return r.label++, {
	                    value: a[1],
	                    done: !1
	                  };
	                case 5:
	                  r.label++, o = a[1], a = [0];
	                  continue;
	                case 7:
	                  a = r.ops.pop(), r.trys.pop();
	                  continue;
	                default:
	                  if (!(n = r.trys, (n = n.length > 0 && n[n.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
	                    r = 0;
	                    continue;
	                  }
	                  if (3 === a[0] && (!n || a[1] > n[0] && a[1] < n[3])) {
	                    r.label = a[1];
	                    break;
	                  }
	                  if (6 === a[0] && r.label < n[1]) {
	                    r.label = n[1], n = a;
	                    break;
	                  }
	                  if (n && r.label < n[2]) {
	                    r.label = n[2], r.ops.push(a);
	                    break;
	                  }
	                  n[2] && r.ops.pop(), r.trys.pop();
	                  continue;
	              }
	              a = t.call(e, r);
	            } catch (e) {
	              a = [6, e], o = 0;
	            } finally {
	              i = n = 0;
	            }
	            if (5 & a[0]) throw a[1];
	            return {
	              value: a[0] ? a[1] : void 0,
	              done: !0
	            };
	          }([a, s]);
	        };
	      }
	    },
	    r = t;
	  Object.defineProperty(i, "__esModule", {
	    value: !0
	  });
	  var s = "browser-tabs-lock-key",
	    c = {
	      key: function (e) {
	        return o(r, void 0, void 0, function () {
	          return a(this, function (e) {
	            throw new Error("Unsupported");
	          });
	        });
	      },
	      getItem: function (e) {
	        return o(r, void 0, void 0, function () {
	          return a(this, function (e) {
	            throw new Error("Unsupported");
	          });
	        });
	      },
	      clear: function () {
	        return o(r, void 0, void 0, function () {
	          return a(this, function (e) {
	            return [2, window.localStorage.clear()];
	          });
	        });
	      },
	      removeItem: function (e) {
	        return o(r, void 0, void 0, function () {
	          return a(this, function (e) {
	            throw new Error("Unsupported");
	          });
	        });
	      },
	      setItem: function (e, t) {
	        return o(r, void 0, void 0, function () {
	          return a(this, function (e) {
	            throw new Error("Unsupported");
	          });
	        });
	      },
	      keySync: function (e) {
	        return window.localStorage.key(e);
	      },
	      getItemSync: function (e) {
	        return window.localStorage.getItem(e);
	      },
	      clearSync: function () {
	        return window.localStorage.clear();
	      },
	      removeItemSync: function (e) {
	        return window.localStorage.removeItem(e);
	      },
	      setItemSync: function (e, t) {
	        return window.localStorage.setItem(e, t);
	      }
	    };
	  function d(e) {
	    return new Promise(function (t) {
	      return setTimeout(t, e);
	    });
	  }
	  function u(e) {
	    for (var t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i = "", o = 0; o < e; o++) {
	      i += t[Math.floor(Math.random() * t.length)];
	    }
	    return i;
	  }
	  var l = function () {
	    function e(t) {
	      this.acquiredIatSet = new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t, void 0 === e.waiters && (e.waiters = []);
	    }
	    return e.prototype.acquireLock = function (t, i) {
	      return void 0 === i && (i = 5e3), o(this, void 0, void 0, function () {
	        var o, n, r, l, h, p, m;
	        return a(this, function (a) {
	          switch (a.label) {
	            case 0:
	              o = Date.now() + u(4), n = Date.now() + i, r = s + "-" + t, l = void 0 === this.storageHandler ? c : this.storageHandler, a.label = 1;
	            case 1:
	              return Date.now() < n ? [4, d(30)] : [3, 8];
	            case 2:
	              return a.sent(), null !== l.getItemSync(r) ? [3, 5] : (h = this.id + "-" + t + "-" + o, [4, d(Math.floor(25 * Math.random()))]);
	            case 3:
	              return a.sent(), l.setItemSync(r, JSON.stringify({
	                id: this.id,
	                iat: o,
	                timeoutKey: h,
	                timeAcquired: Date.now(),
	                timeRefreshed: Date.now()
	              })), [4, d(30)];
	            case 4:
	              return a.sent(), null !== (p = l.getItemSync(r)) && (m = JSON.parse(p)).id === this.id && m.iat === o ? (this.acquiredIatSet.add(o), this.refreshLockWhileAcquired(r, o), [2, !0]) : [3, 7];
	            case 5:
	              return e.lockCorrector(void 0 === this.storageHandler ? c : this.storageHandler), [4, this.waitForSomethingToChange(n)];
	            case 6:
	              a.sent(), a.label = 7;
	            case 7:
	              return o = Date.now() + u(4), [3, 1];
	            case 8:
	              return [2, !1];
	          }
	        });
	      });
	    }, e.prototype.refreshLockWhileAcquired = function (e, t) {
	      return o(this, void 0, void 0, function () {
	        var i = this;
	        return a(this, function (r) {
	          return setTimeout(function () {
	            return o(i, void 0, void 0, function () {
	              var i, o, r;
	              return a(this, function (a) {
	                switch (a.label) {
	                  case 0:
	                    return [4, n.default().lock(t)];
	                  case 1:
	                    return a.sent(), this.acquiredIatSet.has(t) ? (i = void 0 === this.storageHandler ? c : this.storageHandler, null === (o = i.getItemSync(e)) ? (n.default().unlock(t), [2]) : ((r = JSON.parse(o)).timeRefreshed = Date.now(), i.setItemSync(e, JSON.stringify(r)), n.default().unlock(t), this.refreshLockWhileAcquired(e, t), [2])) : (n.default().unlock(t), [2]);
	                }
	              });
	            });
	          }, 1e3), [2];
	        });
	      });
	    }, e.prototype.waitForSomethingToChange = function (t) {
	      return o(this, void 0, void 0, function () {
	        return a(this, function (i) {
	          switch (i.label) {
	            case 0:
	              return [4, new Promise(function (i) {
	                var o = !1,
	                  n = Date.now(),
	                  a = !1;
	                function r() {
	                  if (a || (window.removeEventListener("storage", r), e.removeFromWaiting(r), clearTimeout(s), a = !0), !o) {
	                    o = !0;
	                    var t = 50 - (Date.now() - n);
	                    t > 0 ? setTimeout(i, t) : i(null);
	                  }
	                }
	                window.addEventListener("storage", r), e.addToWaiting(r);
	                var s = setTimeout(r, Math.max(0, t - Date.now()));
	              })];
	            case 1:
	              return i.sent(), [2];
	          }
	        });
	      });
	    }, e.addToWaiting = function (t) {
	      this.removeFromWaiting(t), void 0 !== e.waiters && e.waiters.push(t);
	    }, e.removeFromWaiting = function (t) {
	      void 0 !== e.waiters && (e.waiters = e.waiters.filter(function (e) {
	        return e !== t;
	      }));
	    }, e.notifyWaiters = function () {
	      void 0 !== e.waiters && e.waiters.slice().forEach(function (e) {
	        return e();
	      });
	    }, e.prototype.releaseLock = function (e) {
	      return o(this, void 0, void 0, function () {
	        return a(this, function (t) {
	          switch (t.label) {
	            case 0:
	              return [4, this.releaseLock__private__(e)];
	            case 1:
	              return [2, t.sent()];
	          }
	        });
	      });
	    }, e.prototype.releaseLock__private__ = function (t) {
	      return o(this, void 0, void 0, function () {
	        var i, o, r, d;
	        return a(this, function (a) {
	          switch (a.label) {
	            case 0:
	              return i = void 0 === this.storageHandler ? c : this.storageHandler, o = s + "-" + t, null === (r = i.getItemSync(o)) ? [2] : (d = JSON.parse(r)).id !== this.id ? [3, 2] : [4, n.default().lock(d.iat)];
	            case 1:
	              a.sent(), this.acquiredIatSet.delete(d.iat), i.removeItemSync(o), n.default().unlock(d.iat), e.notifyWaiters(), a.label = 2;
	            case 2:
	              return [2];
	          }
	        });
	      });
	    }, e.lockCorrector = function (t) {
	      for (var i = Date.now() - 5e3, o = t, n = [], a = 0;;) {
	        var r = o.keySync(a);
	        if (null === r) break;
	        n.push(r), a++;
	      }
	      for (var c = !1, d = 0; d < n.length; d++) {
	        var u = n[d];
	        if (u.includes(s)) {
	          var l = o.getItemSync(u);
	          if (null !== l) {
	            var h = JSON.parse(l);
	            (void 0 === h.timeRefreshed && h.timeAcquired < i || void 0 !== h.timeRefreshed && h.timeRefreshed < i) && (o.removeItemSync(u), c = !0);
	          }
	        }
	      }
	      c && e.notifyWaiters();
	    }, e.waiters = void 0, e;
	  }();
	  i.default = l;
	}));
	const r = {
	    timeoutInSeconds: 60
	  },
	  s = {
	    name: "auth0-spa-js",
	    version: "2.1.3"
	  },
	  c$1 = () => Date.now();
	class d$1 extends Error {
	  constructor(e, t) {
	    super(t), this.error = e, this.error_description = t, Object.setPrototypeOf(this, d$1.prototype);
	  }
	  static fromPayload({
	    error: e,
	    error_description: t
	  }) {
	    return new d$1(e, t);
	  }
	}
	class u extends d$1 {
	  constructor(e, t, i, o = null) {
	    super(e, t), this.state = i, this.appState = o, Object.setPrototypeOf(this, u.prototype);
	  }
	}
	class l extends d$1 {
	  constructor() {
	    super("timeout", "Timeout"), Object.setPrototypeOf(this, l.prototype);
	  }
	}
	class h$1 extends l {
	  constructor(e) {
	    super(), this.popup = e, Object.setPrototypeOf(this, h$1.prototype);
	  }
	}
	class p$1 extends d$1 {
	  constructor(e) {
	    super("cancelled", "Popup closed"), this.popup = e, Object.setPrototypeOf(this, p$1.prototype);
	  }
	}
	class m extends d$1 {
	  constructor(e, t, i) {
	    super(e, t), this.mfa_token = i, Object.setPrototypeOf(this, m.prototype);
	  }
	}
	class f extends d$1 {
	  constructor(e, t) {
	    super("missing_refresh_token", `Missing Refresh Token (audience: '${g(e, ["default"])}', scope: '${g(t)}')`), this.audience = e, this.scope = t, Object.setPrototypeOf(this, f.prototype);
	  }
	}
	function g(e, t = []) {
	  return e && !t.includes(e) ? e : "";
	}
	const w$2 = () => window.crypto,
	  y = () => {
	    const e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
	    let t = "";
	    return Array.from(w$2().getRandomValues(new Uint8Array(43))).forEach(i => t += e[i % e.length]), t;
	  },
	  k$1 = e => btoa(e),
	  v$1 = t => {
	    var {
	        clientId: i
	      } = t,
	      o = e(t, ["clientId"]);
	    return new URLSearchParams((e => Object.keys(e).filter(t => void 0 !== e[t]).reduce((t, i) => Object.assign(Object.assign({}, t), {
	      [i]: e[i]
	    }), {}))(Object.assign({
	      client_id: i
	    }, o))).toString();
	  },
	  b$1 = e => (e => decodeURIComponent(atob(e).split("").map(e => "%" + ("00" + e.charCodeAt(0).toString(16)).slice(-2)).join("")))(e.replace(/_/g, "/").replace(/-/g, "+")),
	  _$2 = async (e, t) => {
	    const i = await fetch(e, t);
	    return {
	      ok: i.ok,
	      json: await i.json()
	    };
	  },
	  I$2 = async (e, t, i) => {
	    const o = new AbortController();
	    let n;
	    return t.signal = o.signal, Promise.race([_$2(e, t), new Promise((e, t) => {
	      n = setTimeout(() => {
	        o.abort(), t(new Error("Timeout when executing 'fetch'"));
	      }, i);
	    })]).finally(() => {
	      clearTimeout(n);
	    });
	  },
	  S$1 = async (e, t, i, o, n, a, r) => {
	    return s = {
	      auth: {
	        audience: t,
	        scope: i
	      },
	      timeout: n,
	      fetchUrl: e,
	      fetchOptions: o,
	      useFormData: r
	    }, c = a, new Promise(function (e, t) {
	      const i = new MessageChannel();
	      i.port1.onmessage = function (o) {
	        o.data.error ? t(new Error(o.data.error)) : e(o.data), i.port1.close();
	      }, c.postMessage(s, [i.port2]);
	    });
	    var s, c;
	  },
	  O$1 = async (e, t, i, o, n, a, r = 1e4) => n ? S$1(e, t, i, o, r, n, a) : I$2(e, o, r);
	async function T$1(t, i) {
	  var {
	      baseUrl: o,
	      timeout: n,
	      audience: a,
	      scope: r,
	      auth0Client: c,
	      useFormData: u
	    } = t,
	    l = e(t, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
	  const h = u ? v$1(l) : JSON.stringify(l);
	  return await async function (t, i, o, n, a, r, s) {
	    let c,
	      u = null;
	    for (let e = 0; e < 3; e++) try {
	      c = await O$1(t, o, n, a, r, s, i), u = null;
	      break;
	    } catch (e) {
	      u = e;
	    }
	    if (u) throw u;
	    const l = c.json,
	      {
	        error: h,
	        error_description: p
	      } = l,
	      g = e(l, ["error", "error_description"]),
	      {
	        ok: w
	      } = c;
	    if (!w) {
	      const e = p || `HTTP error. Unable to fetch ${t}`;
	      if ("mfa_required" === h) throw new m(h, e, g.mfa_token);
	      if ("missing_refresh_token" === h) throw new f(o, n);
	      throw new d$1(h || "request_error", e);
	    }
	    return g;
	  }(`${o}/oauth/token`, n, a || "default", r, {
	    method: "POST",
	    body: h,
	    headers: {
	      "Content-Type": u ? "application/x-www-form-urlencoded" : "application/json",
	      "Auth0-Client": btoa(JSON.stringify(c || s))
	    }
	  }, i, u);
	}
	const j = (...e) => {
	  return (t = e.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t))).join(" ");
	  var t;
	};
	class C$2 {
	  constructor(e, t = "@@auth0spajs@@", i) {
	    this.prefix = t, this.suffix = i, this.clientId = e.clientId, this.scope = e.scope, this.audience = e.audience;
	  }
	  toKey() {
	    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
	  }
	  static fromKey(e) {
	    const [t, i, o, n] = e.split("::");
	    return new C$2({
	      clientId: i,
	      scope: n,
	      audience: o
	    }, t);
	  }
	  static fromCacheEntry(e) {
	    const {
	      scope: t,
	      audience: i,
	      client_id: o
	    } = e;
	    return new C$2({
	      scope: t,
	      audience: i,
	      clientId: o
	    });
	  }
	}
	class z$2 {
	  set(e, t) {
	    localStorage.setItem(e, JSON.stringify(t));
	  }
	  get(e) {
	    const t = window.localStorage.getItem(e);
	    if (t) try {
	      return JSON.parse(t);
	    } catch (e) {
	      return;
	    }
	  }
	  remove(e) {
	    localStorage.removeItem(e);
	  }
	  allKeys() {
	    return Object.keys(window.localStorage).filter(e => e.startsWith("@@auth0spajs@@"));
	  }
	}
	class P$2 {
	  constructor() {
	    this.enclosedCache = function () {
	      let e = {};
	      return {
	        set(t, i) {
	          e[t] = i;
	        },
	        get(t) {
	          const i = e[t];
	          if (i) return i;
	        },
	        remove(t) {
	          delete e[t];
	        },
	        allKeys: () => Object.keys(e)
	      };
	    }();
	  }
	}
	class x$2 {
	  constructor(e, t, i) {
	    this.cache = e, this.keyManifest = t, this.nowProvider = i || c$1;
	  }
	  async setIdToken(e, t, i) {
	    var o;
	    const n = this.getIdTokenCacheKey(e);
	    await this.cache.set(n, {
	      id_token: t,
	      decodedToken: i
	    }), await (null === (o = this.keyManifest) || void 0 === o ? void 0 : o.add(n));
	  }
	  async getIdToken(e) {
	    const t = await this.cache.get(this.getIdTokenCacheKey(e.clientId));
	    if (!t && e.scope && e.audience) {
	      const t = await this.get(e);
	      if (!t) return;
	      if (!t.id_token || !t.decodedToken) return;
	      return {
	        id_token: t.id_token,
	        decodedToken: t.decodedToken
	      };
	    }
	    if (t) return {
	      id_token: t.id_token,
	      decodedToken: t.decodedToken
	    };
	  }
	  async get(e, t = 0) {
	    var i;
	    let o = await this.cache.get(e.toKey());
	    if (!o) {
	      const t = await this.getCacheKeys();
	      if (!t) return;
	      const i = this.matchExistingCacheKey(e, t);
	      i && (o = await this.cache.get(i));
	    }
	    if (!o) return;
	    const n = await this.nowProvider(),
	      a = Math.floor(n / 1e3);
	    return o.expiresAt - t < a ? o.body.refresh_token ? (o.body = {
	      refresh_token: o.body.refresh_token
	    }, await this.cache.set(e.toKey(), o), o.body) : (await this.cache.remove(e.toKey()), void (await (null === (i = this.keyManifest) || void 0 === i ? void 0 : i.remove(e.toKey())))) : o.body;
	  }
	  async set(e) {
	    var t;
	    const i = new C$2({
	        clientId: e.client_id,
	        scope: e.scope,
	        audience: e.audience
	      }),
	      o = await this.wrapCacheEntry(e);
	    await this.cache.set(i.toKey(), o), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.add(i.toKey()));
	  }
	  async clear(e) {
	    var t;
	    const i = await this.getCacheKeys();
	    i && (await i.filter(t => !e || t.includes(e)).reduce(async (e, t) => {
	      await e, await this.cache.remove(t);
	    }, Promise.resolve()), await (null === (t = this.keyManifest) || void 0 === t ? void 0 : t.clear()));
	  }
	  async wrapCacheEntry(e) {
	    const t = await this.nowProvider();
	    return {
	      body: e,
	      expiresAt: Math.floor(t / 1e3) + e.expires_in
	    };
	  }
	  async getCacheKeys() {
	    var e;
	    return this.keyManifest ? null === (e = await this.keyManifest.get()) || void 0 === e ? void 0 : e.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;
	  }
	  getIdTokenCacheKey(e) {
	    return new C$2({
	      clientId: e
	    }, "@@auth0spajs@@", "@@user@@").toKey();
	  }
	  matchExistingCacheKey(e, t) {
	    return t.filter(t => {
	      var i;
	      const o = C$2.fromKey(t),
	        n = new Set(o.scope && o.scope.split(" ")),
	        a = (null === (i = e.scope) || void 0 === i ? void 0 : i.split(" ")) || [],
	        r = o.scope && a.reduce((e, t) => e && n.has(t), !0);
	      return "@@auth0spajs@@" === o.prefix && o.clientId === e.clientId && o.audience === e.audience && r;
	    })[0];
	  }
	}
	class Z$2 {
	  constructor(e, t, i) {
	    this.storage = e, this.clientId = t, this.cookieDomain = i, this.storageKey = `a0.spajs.txs.${this.clientId}`;
	  }
	  create(e) {
	    this.storage.save(this.storageKey, e, {
	      daysUntilExpire: 1,
	      cookieDomain: this.cookieDomain
	    });
	  }
	  get() {
	    return this.storage.get(this.storageKey);
	  }
	  remove() {
	    this.storage.remove(this.storageKey, {
	      cookieDomain: this.cookieDomain
	    });
	  }
	}
	const K = e => "number" == typeof e,
	  W = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"],
	  E$2 = e => {
	    if (!e.id_token) throw new Error("ID token is required but missing");
	    const t = (e => {
	      const t = e.split("."),
	        [i, o, n] = t;
	      if (3 !== t.length || !i || !o || !n) throw new Error("ID token could not be decoded");
	      const a = JSON.parse(b$1(o)),
	        r = {
	          __raw: e
	        },
	        s = {};
	      return Object.keys(a).forEach(e => {
	        r[e] = a[e], W.includes(e) || (s[e] = a[e]);
	      }), {
	        encoded: {
	          header: i,
	          payload: o,
	          signature: n
	        },
	        header: JSON.parse(b$1(i)),
	        claims: r,
	        user: s
	      };
	    })(e.id_token);
	    if (!t.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token");
	    if (t.claims.iss !== e.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e.iss}", found "${t.claims.iss}"`);
	    if (!t.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token");
	    if ("RS256" !== t.header.alg) throw new Error(`Signature algorithm of "${t.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);
	    if (!t.claims.aud || "string" != typeof t.claims.aud && !Array.isArray(t.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
	    if (Array.isArray(t.claims.aud)) {
	      if (!t.claims.aud.includes(e.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but was not one of "${t.claims.aud.join(", ")}"`);
	      if (t.claims.aud.length > 1) {
	        if (!t.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
	        if (t.claims.azp !== e.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e.aud}", found "${t.claims.azp}"`);
	      }
	    } else if (t.claims.aud !== e.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e.aud}" but found "${t.claims.aud}"`);
	    if (e.nonce) {
	      if (!t.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token");
	      if (t.claims.nonce !== e.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e.nonce}", found "${t.claims.nonce}"`);
	    }
	    if (e.max_age && !K(t.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
	    if (null == t.claims.exp || !K(t.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
	    if (!K(t.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token");
	    const i = e.leeway || 60,
	      o = new Date(e.now || Date.now()),
	      n = new Date(0);
	    if (n.setUTCSeconds(t.claims.exp + i), o > n) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o}) is after expiration time (${n})`);
	    if (null != t.claims.nbf && K(t.claims.nbf)) {
	      const e = new Date(0);
	      if (e.setUTCSeconds(t.claims.nbf - i), o < e) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o}) is before ${e}`);
	    }
	    if (null != t.claims.auth_time && K(t.claims.auth_time)) {
	      const n = new Date(0);
	      if (n.setUTCSeconds(parseInt(t.claims.auth_time) + e.max_age + i), o > n) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o}) is after last auth at ${n}`);
	    }
	    if (e.organization) {
	      const i = e.organization.trim();
	      if (i.startsWith("org_")) {
	        const e = i;
	        if (!t.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
	        if (e !== t.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${e}", found "${t.claims.org_id}"`);
	      } else {
	        const e = i.toLowerCase();
	        if (!t.claims.org_name) throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
	        if (e !== t.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${e}", found "${t.claims.org_name}"`);
	      }
	    }
	    return t;
	  };
	var R = o(function (e, i) {
	  var o = t && t.__assign || function () {
	    return o = Object.assign || function (e) {
	      for (var t, i = 1, o = arguments.length; i < o; i++) for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
	      return e;
	    }, o.apply(this, arguments);
	  };
	  function n(e, t) {
	    if (!t) return "";
	    var i = "; " + e;
	    return !0 === t ? i : i + "=" + t;
	  }
	  function a(e, t, i) {
	    return encodeURIComponent(e).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function (e) {
	      if ("number" == typeof e.expires) {
	        var t = new Date();
	        t.setMilliseconds(t.getMilliseconds() + 864e5 * e.expires), e.expires = t;
	      }
	      return n("Expires", e.expires ? e.expires.toUTCString() : "") + n("Domain", e.domain) + n("Path", e.path) + n("Secure", e.secure) + n("SameSite", e.sameSite);
	    }(i);
	  }
	  function r(e) {
	    for (var t = {}, i = e ? e.split("; ") : [], o = /(%[\dA-F]{2})+/gi, n = 0; n < i.length; n++) {
	      var a = i[n].split("="),
	        r = a.slice(1).join("=");
	      '"' === r.charAt(0) && (r = r.slice(1, -1));
	      try {
	        t[a[0].replace(o, decodeURIComponent)] = r.replace(o, decodeURIComponent);
	      } catch (e) {}
	    }
	    return t;
	  }
	  function s() {
	    return r(document.cookie);
	  }
	  function c(e, t, i) {
	    document.cookie = a(e, t, o({
	      path: "/"
	    }, i));
	  }
	  i.__esModule = !0, i.encode = a, i.parse = r, i.getAll = s, i.get = function (e) {
	    return s()[e];
	  }, i.set = c, i.remove = function (e, t) {
	    c(e, "", o(o({}, t), {
	      expires: -1
	    }));
	  };
	});
	i(R), R.encode, R.parse, R.getAll;
	var U$1 = R.get,
	  L = R.set,
	  D$1 = R.remove;
	const X$2 = {
	    get(e) {
	      const t = U$1(e);
	      if (void 0 !== t) return JSON.parse(t);
	    },
	    save(e, t, i) {
	      let o = {};
	      "https:" === window.location.protocol && (o = {
	        secure: !0,
	        sameSite: "none"
	      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), L(e, JSON.stringify(t), o);
	    },
	    remove(e, t) {
	      let i = {};
	      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), D$1(e, i);
	    }
	  },
	  N$2 = {
	    get(e) {
	      const t = X$2.get(e);
	      return t || X$2.get(`_legacy_${e}`);
	    },
	    save(e, t, i) {
	      let o = {};
	      "https:" === window.location.protocol && (o = {
	        secure: !0
	      }), (null == i ? void 0 : i.daysUntilExpire) && (o.expires = i.daysUntilExpire), (null == i ? void 0 : i.cookieDomain) && (o.domain = i.cookieDomain), L(`_legacy_${e}`, JSON.stringify(t), o), X$2.save(e, t, i);
	    },
	    remove(e, t) {
	      let i = {};
	      (null == t ? void 0 : t.cookieDomain) && (i.domain = t.cookieDomain), D$1(e, i), X$2.remove(e, t), X$2.remove(`_legacy_${e}`, t);
	    }
	  },
	  J$1 = {
	    get(e) {
	      if ("undefined" == typeof sessionStorage) return;
	      const t = sessionStorage.getItem(e);
	      return null != t ? JSON.parse(t) : void 0;
	    },
	    save(e, t) {
	      sessionStorage.setItem(e, JSON.stringify(t));
	    },
	    remove(e) {
	      sessionStorage.removeItem(e);
	    }
	  };
	function F$1(e, t, i) {
	  var o = void 0 === t ? null : t,
	    n = function (e, t) {
	      var i = atob(e);
	      if (t) {
	        for (var o = new Uint8Array(i.length), n = 0, a = i.length; n < a; ++n) o[n] = i.charCodeAt(n);
	        return String.fromCharCode.apply(null, new Uint16Array(o.buffer));
	      }
	      return i;
	    }(e, void 0 !== i && i),
	    a = n.indexOf("\n", 10) + 1,
	    r = n.substring(a) + (o ? "//# sourceMappingURL=" + o : ""),
	    s = new Blob([r], {
	      type: "application/javascript"
	    });
	  return URL.createObjectURL(s);
	}
	var H,
	  Y$1,
	  G$1,
	  V$1,
	  M$1 = (H = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=", Y$1 = null, G$1 = !1, function (e) {
	    return V$1 = V$1 || F$1(H, Y$1, G$1), new Worker(V$1, e);
	  });
	const A$1 = {};
	class B$2 {
	  constructor(e, t) {
	    this.cache = e, this.clientId = t, this.manifestKey = this.createManifestKeyFrom(this.clientId);
	  }
	  async add(e) {
	    var t;
	    const i = new Set((null === (t = await this.cache.get(this.manifestKey)) || void 0 === t ? void 0 : t.keys) || []);
	    i.add(e), await this.cache.set(this.manifestKey, {
	      keys: [...i]
	    });
	  }
	  async remove(e) {
	    const t = await this.cache.get(this.manifestKey);
	    if (t) {
	      const i = new Set(t.keys);
	      return i.delete(e), i.size > 0 ? await this.cache.set(this.manifestKey, {
	        keys: [...i]
	      }) : await this.cache.remove(this.manifestKey);
	    }
	  }
	  get() {
	    return this.cache.get(this.manifestKey);
	  }
	  clear() {
	    return this.cache.remove(this.manifestKey);
	  }
	  createManifestKeyFrom(e) {
	    return `@@auth0spajs@@::${e}`;
	  }
	}
	const $$2 = {
	    memory: () => new P$2().enclosedCache,
	    localstorage: () => new z$2()
	  },
	  q$1 = e => $$2[e],
	  Q$2 = t => {
	    const {
	        openUrl: i,
	        onRedirect: o
	      } = t,
	      n = e(t, ["openUrl", "onRedirect"]);
	    return Object.assign(Object.assign({}, n), {
	      openUrl: !1 === i || i ? i : o
	    });
	  },
	  ee$1 = new a();
	class te$1 {
	  constructor(e) {
	    let t, i;
	    if (this.userCache = new P$2().enclosedCache, this.defaultOptions = {
	      authorizationParams: {
	        scope: "openid profile email"
	      },
	      useRefreshTokensFallback: !1,
	      useFormData: !0
	    }, this._releaseLockOnPageHide = async () => {
	      await ee$1.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
	    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e), {
	      authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e.authorizationParams)
	    }), "undefined" != typeof window && (() => {
	      if (!w$2()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
	      if (void 0 === w$2().subtle) throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
	    })(), e.cache && e.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e.cache) i = e.cache;else {
	      if (t = e.cacheLocation || "memory", !q$1(t)) throw new Error(`Invalid cache location "${t}"`);
	      i = q$1(t)();
	    }
	    this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = !1 === e.legacySameSiteCookie ? X$2 : N$2, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = (e => `auth0.${e}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1;
	    const o = e.useCookiesForTransactions ? this.cookieStorage : J$1;
	    var n;
	    this.scope = j("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new Z$2(o, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c$1, this.cacheManager = new x$2(i, i.allKeys ? void 0 : new B$2(i, this.options.clientId), this.nowProvider), this.domainUrl = (n = this.options.domain, /^https?:\/\//.test(n) ? n : `https://${n}`), this.tokenIssuer = ((e, t) => e ? e.startsWith("https://") ? e : `https://${e}/` : `${t}/`)(this.options.issuer, this.domainUrl), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M$1());
	  }
	  _url(e) {
	    const t = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s)));
	    return `${this.domainUrl}${e}&auth0Client=${t}`;
	  }
	  _authorizeUrl(e) {
	    return this._url(`/authorize?${v$1(e)}`);
	  }
	  async _verifyIdToken(e, t, i) {
	    const o = await this.nowProvider();
	    return E$2({
	      iss: this.tokenIssuer,
	      aud: this.options.clientId,
	      id_token: e,
	      nonce: t,
	      organization: i,
	      leeway: this.options.leeway,
	      max_age: (n = this.options.authorizationParams.max_age, "string" != typeof n ? n : parseInt(n, 10) || void 0),
	      now: o
	    });
	    var n;
	  }
	  _processOrgHint(e) {
	    e ? this.cookieStorage.save(this.orgHintCookieName, e, {
	      daysUntilExpire: this.sessionCheckExpiryDays,
	      cookieDomain: this.options.cookieDomain
	    }) : this.cookieStorage.remove(this.orgHintCookieName, {
	      cookieDomain: this.options.cookieDomain
	    });
	  }
	  async _prepareAuthorizeUrl(e, t, i) {
	    const o = k$1(y()),
	      n = k$1(y()),
	      a = y(),
	      r = (e => {
	        const t = new Uint8Array(e);
	        return (e => {
	          const t = {
	            "+": "-",
	            "/": "_",
	            "=": ""
	          };
	          return e.replace(/[+/=]/g, e => t[e]);
	        })(window.btoa(String.fromCharCode(...Array.from(t))));
	      })(await (async e => {
	        const t = w$2().subtle.digest({
	          name: "SHA-256"
	        }, new TextEncoder().encode(e));
	        return await t;
	      })(a)),
	      s = ((e, t, i, o, n, a, r, s) => Object.assign(Object.assign(Object.assign({
	        client_id: e.clientId
	      }, e.authorizationParams), i), {
	        scope: j(t, i.scope),
	        response_type: "code",
	        response_mode: s || "query",
	        state: o,
	        nonce: n,
	        redirect_uri: r || e.authorizationParams.redirect_uri,
	        code_challenge: a,
	        code_challenge_method: "S256"
	      }))(this.options, this.scope, e, o, n, r, e.redirect_uri || this.options.authorizationParams.redirect_uri || i, null == t ? void 0 : t.response_mode),
	      c = this._authorizeUrl(s);
	    return {
	      nonce: n,
	      code_verifier: a,
	      scope: s.scope,
	      audience: s.audience || "default",
	      redirect_uri: s.redirect_uri,
	      state: o,
	      url: c
	    };
	  }
	  async loginWithPopup(e, t) {
	    var i;
	    if (e = e || {}, !(t = t || {}).popup && (t.popup = (e => {
	      const t = window.screenX + (window.innerWidth - 400) / 2,
	        i = window.screenY + (window.innerHeight - 600) / 2;
	      return window.open(e, "auth0:authorize:popup", `left=${t},top=${i},width=400,height=600,resizable,scrollbars=yes,status=1`);
	    })(""), !t.popup)) throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
	    const o = await this._prepareAuthorizeUrl(e.authorizationParams || {}, {
	      response_mode: "web_message"
	    }, window.location.origin);
	    t.popup.location.href = o.url;
	    const n = await (e => new Promise((t, i) => {
	      let o;
	      const n = setInterval(() => {
	          e.popup && e.popup.closed && (clearInterval(n), clearTimeout(a), window.removeEventListener("message", o, !1), i(new p$1(e.popup)));
	        }, 1e3),
	        a = setTimeout(() => {
	          clearInterval(n), i(new h$1(e.popup)), window.removeEventListener("message", o, !1);
	        }, 1e3 * (e.timeoutInSeconds || 60));
	      o = function (r) {
	        if (r.data && "authorization_response" === r.data.type) {
	          if (clearTimeout(a), clearInterval(n), window.removeEventListener("message", o, !1), e.popup.close(), r.data.response.error) return i(d$1.fromPayload(r.data.response));
	          t(r.data.response);
	        }
	      }, window.addEventListener("message", o);
	    }))(Object.assign(Object.assign({}, t), {
	      timeoutInSeconds: t.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60
	    }));
	    if (o.state !== n.state) throw new d$1("state_mismatch", "Invalid state");
	    const a = (null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.organization) || this.options.authorizationParams.organization;
	    await this._requestToken({
	      audience: o.audience,
	      scope: o.scope,
	      code_verifier: o.code_verifier,
	      grant_type: "authorization_code",
	      code: n.code,
	      redirect_uri: o.redirect_uri
	    }, {
	      nonceIn: o.nonce,
	      organization: a
	    });
	  }
	  async getUser() {
	    var e;
	    const t = await this._getIdTokenFromCache();
	    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.user;
	  }
	  async getIdTokenClaims() {
	    var e;
	    const t = await this._getIdTokenFromCache();
	    return null === (e = null == t ? void 0 : t.decodedToken) || void 0 === e ? void 0 : e.claims;
	  }
	  async loginWithRedirect(t = {}) {
	    var i;
	    const o = Q$2(t),
	      {
	        openUrl: n,
	        fragment: a,
	        appState: r
	      } = o,
	      s = e(o, ["openUrl", "fragment", "appState"]),
	      c = (null === (i = s.authorizationParams) || void 0 === i ? void 0 : i.organization) || this.options.authorizationParams.organization,
	      d = await this._prepareAuthorizeUrl(s.authorizationParams || {}),
	      {
	        url: u
	      } = d,
	      l = e(d, ["url"]);
	    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l), {
	      appState: r
	    }), c && {
	      organization: c
	    }));
	    const h = a ? `${u}#${a}` : u;
	    n ? await n(h) : window.location.assign(h);
	  }
	  async handleRedirectCallback(e = window.location.href) {
	    const t = e.split("?").slice(1);
	    if (0 === t.length) throw new Error("There are no query params available for parsing.");
	    const {
	        state: i,
	        code: o,
	        error: n,
	        error_description: a
	      } = (e => {
	        e.indexOf("#") > -1 && (e = e.substring(0, e.indexOf("#")));
	        const t = new URLSearchParams(e);
	        return {
	          state: t.get("state"),
	          code: t.get("code") || void 0,
	          error: t.get("error") || void 0,
	          error_description: t.get("error_description") || void 0
	        };
	      })(t.join("")),
	      r = this.transactionManager.get();
	    if (!r) throw new d$1("missing_transaction", "Invalid state");
	    if (this.transactionManager.remove(), n) throw new u(n, a || n, i, r.appState);
	    if (!r.code_verifier || r.state && r.state !== i) throw new d$1("state_mismatch", "Invalid state");
	    const s = r.organization,
	      c = r.nonce,
	      l = r.redirect_uri;
	    return await this._requestToken(Object.assign({
	      audience: r.audience,
	      scope: r.scope,
	      code_verifier: r.code_verifier,
	      grant_type: "authorization_code",
	      code: o
	    }, l ? {
	      redirect_uri: l
	    } : {}), {
	      nonceIn: c,
	      organization: s
	    }), {
	      appState: r.appState
	    };
	  }
	  async checkSession(e) {
	    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
	      if (!this.cookieStorage.get("auth0.is.authenticated")) return;
	      this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {
	        daysUntilExpire: this.sessionCheckExpiryDays,
	        cookieDomain: this.options.cookieDomain
	      }), this.cookieStorage.remove("auth0.is.authenticated");
	    }
	    try {
	      await this.getTokenSilently(e);
	    } catch (e) {}
	  }
	  async getTokenSilently(e = {}) {
	    var t;
	    const i = Object.assign(Object.assign({
	        cacheMode: "on"
	      }, e), {
	        authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {
	          scope: j(this.scope, null === (t = e.authorizationParams) || void 0 === t ? void 0 : t.scope)
	        })
	      }),
	      o = await ((e, t) => {
	        let i = A$1[t];
	        return i || (i = e().finally(() => {
	          delete A$1[t], i = null;
	        }), A$1[t] = i), i;
	      })(() => this._getTokenSilently(i), `${this.options.clientId}::${i.authorizationParams.audience}::${i.authorizationParams.scope}`);
	    return e.detailedResponse ? o : null == o ? void 0 : o.access_token;
	  }
	  async _getTokenSilently(t) {
	    const {
	        cacheMode: i
	      } = t,
	      o = e(t, ["cacheMode"]);
	    if ("off" !== i) {
	      const e = await this._getEntryFromCache({
	        scope: o.authorizationParams.scope,
	        audience: o.authorizationParams.audience || "default",
	        clientId: this.options.clientId
	      });
	      if (e) return e;
	    }
	    if ("cache-only" !== i) {
	      if (!(await (async (e, t = 3) => {
	        for (let i = 0; i < t; i++) if (await e()) return !0;
	        return !1;
	      })(() => ee$1.acquireLock("auth0.lock.getTokenSilently", 5e3), 10))) throw new l();
	      try {
	        if (window.addEventListener("pagehide", this._releaseLockOnPageHide), "off" !== i) {
	          const e = await this._getEntryFromCache({
	            scope: o.authorizationParams.scope,
	            audience: o.authorizationParams.audience || "default",
	            clientId: this.options.clientId
	          });
	          if (e) return e;
	        }
	        const e = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o) : await this._getTokenFromIFrame(o),
	          {
	            id_token: t,
	            access_token: n,
	            oauthTokenScope: a,
	            expires_in: r
	          } = e;
	        return Object.assign(Object.assign({
	          id_token: t,
	          access_token: n
	        }, a ? {
	          scope: a
	        } : null), {
	          expires_in: r
	        });
	      } finally {
	        await ee$1.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
	      }
	    }
	  }
	  async getTokenWithPopup(e = {}, t = {}) {
	    var i;
	    const o = Object.assign(Object.assign({}, e), {
	      authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e.authorizationParams), {
	        scope: j(this.scope, null === (i = e.authorizationParams) || void 0 === i ? void 0 : i.scope)
	      })
	    });
	    t = Object.assign(Object.assign({}, r), t), await this.loginWithPopup(o, t);
	    return (await this.cacheManager.get(new C$2({
	      scope: o.authorizationParams.scope,
	      audience: o.authorizationParams.audience || "default",
	      clientId: this.options.clientId
	    }))).access_token;
	  }
	  async isAuthenticated() {
	    return !!(await this.getUser());
	  }
	  _buildLogoutUrl(t) {
	    null !== t.clientId ? t.clientId = t.clientId || this.options.clientId : delete t.clientId;
	    const i = t.logoutParams || {},
	      {
	        federated: o
	      } = i,
	      n = e(i, ["federated"]),
	      a = o ? "&federated" : "";
	    return this._url(`/v2/logout?${v$1(Object.assign({
      clientId: t.clientId
    }, n))}`) + a;
	  }
	  async logout(t = {}) {
	    const i = Q$2(t),
	      {
	        openUrl: o
	      } = i,
	      n = e(i, ["openUrl"]);
	    null === t.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, {
	      cookieDomain: this.options.cookieDomain
	    }), this.cookieStorage.remove(this.isAuthenticatedCookieName, {
	      cookieDomain: this.options.cookieDomain
	    }), this.userCache.remove("@@user@@");
	    const a = this._buildLogoutUrl(n);
	    o ? await o(a) : !1 !== o && window.location.assign(a);
	  }
	  async _getTokenFromIFrame(e) {
	    const t = Object.assign(Object.assign({}, e.authorizationParams), {
	        prompt: "none"
	      }),
	      i = this.cookieStorage.get(this.orgHintCookieName);
	    i && !t.organization && (t.organization = i);
	    const {
	      url: o,
	      state: n,
	      nonce: a,
	      code_verifier: r,
	      redirect_uri: s,
	      scope: c,
	      audience: u
	    } = await this._prepareAuthorizeUrl(t, {
	      response_mode: "web_message"
	    }, window.location.origin);
	    try {
	      if (window.crossOriginIsolated) throw new d$1("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
	      const i = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds,
	        h = await ((e, t, i = 60) => new Promise((o, n) => {
	          const a = window.document.createElement("iframe");
	          a.setAttribute("width", "0"), a.setAttribute("height", "0"), a.style.display = "none";
	          const r = () => {
	            window.document.body.contains(a) && (window.document.body.removeChild(a), window.removeEventListener("message", s, !1));
	          };
	          let s;
	          const c = setTimeout(() => {
	            n(new l()), r();
	          }, 1e3 * i);
	          s = function (e) {
	            if (e.origin != t) return;
	            if (!e.data || "authorization_response" !== e.data.type) return;
	            const i = e.source;
	            i && i.close(), e.data.response.error ? n(d$1.fromPayload(e.data.response)) : o(e.data.response), clearTimeout(c), window.removeEventListener("message", s, !1), setTimeout(r, 2e3);
	          }, window.addEventListener("message", s, !1), window.document.body.appendChild(a), a.setAttribute("src", e);
	        }))(o, this.domainUrl, i);
	      if (n !== h.state) throw new d$1("state_mismatch", "Invalid state");
	      const p = await this._requestToken(Object.assign(Object.assign({}, e.authorizationParams), {
	        code_verifier: r,
	        code: h.code,
	        grant_type: "authorization_code",
	        redirect_uri: s,
	        timeout: e.authorizationParams.timeout || this.httpTimeoutMs
	      }), {
	        nonceIn: a,
	        organization: t.organization
	      });
	      return Object.assign(Object.assign({}, p), {
	        scope: c,
	        oauthTokenScope: p.scope,
	        audience: u
	      });
	    } catch (e) {
	      throw "login_required" === e.error && this.logout({
	        openUrl: !1
	      }), e;
	    }
	  }
	  async _getTokenUsingRefreshToken(e) {
	    const t = await this.cacheManager.get(new C$2({
	      scope: e.authorizationParams.scope,
	      audience: e.authorizationParams.audience || "default",
	      clientId: this.options.clientId
	    }));
	    if (!(t && t.refresh_token || this.worker)) {
	      if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e);
	      throw new f(e.authorizationParams.audience || "default", e.authorizationParams.scope);
	    }
	    const i = e.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin,
	      o = "number" == typeof e.timeoutInSeconds ? 1e3 * e.timeoutInSeconds : null;
	    try {
	      const n = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e.authorizationParams), {
	        grant_type: "refresh_token",
	        refresh_token: t && t.refresh_token,
	        redirect_uri: i
	      }), o && {
	        timeout: o
	      }));
	      return Object.assign(Object.assign({}, n), {
	        scope: e.authorizationParams.scope,
	        oauthTokenScope: n.scope,
	        audience: e.authorizationParams.audience || "default"
	      });
	    } catch (t) {
	      if ((t.message.indexOf("Missing Refresh Token") > -1 || t.message && t.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e);
	      throw t;
	    }
	  }
	  async _saveEntryInCache(t) {
	    const {
	        id_token: i,
	        decodedToken: o
	      } = t,
	      n = e(t, ["id_token", "decodedToken"]);
	    this.userCache.set("@@user@@", {
	      id_token: i,
	      decodedToken: o
	    }), await this.cacheManager.setIdToken(this.options.clientId, t.id_token, t.decodedToken), await this.cacheManager.set(n);
	  }
	  async _getIdTokenFromCache() {
	    const e = this.options.authorizationParams.audience || "default",
	      t = await this.cacheManager.getIdToken(new C$2({
	        clientId: this.options.clientId,
	        audience: e,
	        scope: this.scope
	      })),
	      i = this.userCache.get("@@user@@");
	    return t && t.id_token === (null == i ? void 0 : i.id_token) ? i : (this.userCache.set("@@user@@", t), t);
	  }
	  async _getEntryFromCache({
	    scope: e,
	    audience: t,
	    clientId: i
	  }) {
	    const o = await this.cacheManager.get(new C$2({
	      scope: e,
	      audience: t,
	      clientId: i
	    }), 60);
	    if (o && o.access_token) {
	      const {
	          access_token: e,
	          oauthTokenScope: t,
	          expires_in: i
	        } = o,
	        n = await this._getIdTokenFromCache();
	      return n && Object.assign(Object.assign({
	        id_token: n.id_token,
	        access_token: e
	      }, t ? {
	        scope: t
	      } : null), {
	        expires_in: i
	      });
	    }
	  }
	  async _requestToken(e, t) {
	    const {
	        nonceIn: i,
	        organization: o
	      } = t || {},
	      n = await T$1(Object.assign({
	        baseUrl: this.domainUrl,
	        client_id: this.options.clientId,
	        auth0Client: this.options.auth0Client,
	        useFormData: this.options.useFormData,
	        timeout: this.httpTimeoutMs
	      }, e), this.worker),
	      a = await this._verifyIdToken(n.id_token, i, o);
	    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n), {
	      decodedToken: a,
	      scope: e.scope,
	      audience: e.audience || "default"
	    }), n.scope ? {
	      oauthTokenScope: n.scope
	    } : null), {
	      client_id: this.options.clientId
	    })), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, {
	      daysUntilExpire: this.sessionCheckExpiryDays,
	      cookieDomain: this.options.cookieDomain
	    }), this._processOrgHint(o || a.claims.org_id), Object.assign(Object.assign({}, n), {
	      decodedToken: a
	    });
	  }
	}
	async function oe$1(e) {
	  const t = new te$1(e);
	  return await t.checkSession(), t;
	}

	var extend$2;
	var hasRequiredExtend;

	function requireExtend () {
		if (hasRequiredExtend) return extend$2;
		hasRequiredExtend = 1;

		var hasOwn = Object.prototype.hasOwnProperty;
		var toStr = Object.prototype.toString;
		var defineProperty = Object.defineProperty;
		var gOPD = Object.getOwnPropertyDescriptor;
		var isArray = function isArray(arr) {
		  if (typeof Array.isArray === 'function') {
		    return Array.isArray(arr);
		  }
		  return toStr.call(arr) === '[object Array]';
		};
		var isPlainObject = function isPlainObject(obj) {
		  if (!obj || toStr.call(obj) !== '[object Object]') {
		    return false;
		  }
		  var hasOwnConstructor = hasOwn.call(obj, 'constructor');
		  var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
		  // Not own constructor property must be Object
		  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		    return false;
		  }

		  // Own properties are enumerated firstly, so to speed up,
		  // if last one is own, then all properties are own.
		  var key;
		  for (key in obj) {/**/}
		  return typeof key === 'undefined' || hasOwn.call(obj, key);
		};

		// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
		var setProperty = function setProperty(target, options) {
		  if (defineProperty && options.name === '__proto__') {
		    defineProperty(target, options.name, {
		      enumerable: true,
		      configurable: true,
		      value: options.newValue,
		      writable: true
		    });
		  } else {
		    target[options.name] = options.newValue;
		  }
		};

		// Return undefined instead of __proto__ if '__proto__' is not an own property
		var getProperty = function getProperty(obj, name) {
		  if (name === '__proto__') {
		    if (!hasOwn.call(obj, name)) {
		      return void 0;
		    } else if (gOPD) {
		      // In early versions of node, obj['__proto__'] is buggy when obj has
		      // __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
		      return gOPD(obj, name).value;
		    }
		  }
		  return obj[name];
		};
		extend$2 = function extend() {
		  var options, name, src, copy, copyIsArray, clone;
		  var target = arguments[0];
		  var i = 1;
		  var length = arguments.length;
		  var deep = false;

		  // Handle a deep copy situation
		  if (typeof target === 'boolean') {
		    deep = target;
		    target = arguments[1] || {};
		    // skip the boolean and the target
		    i = 2;
		  }
		  if (target == null || typeof target !== 'object' && typeof target !== 'function') {
		    target = {};
		  }
		  for (; i < length; ++i) {
		    options = arguments[i];
		    // Only deal with non-null/undefined values
		    if (options != null) {
		      // Extend the base object
		      for (name in options) {
		        src = getProperty(target, name);
		        copy = getProperty(options, name);

		        // Prevent never-ending loop
		        if (target !== copy) {
		          // Recurse if we're merging plain objects or arrays
		          if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
		            if (copyIsArray) {
		              copyIsArray = false;
		              clone = src && isArray(src) ? src : [];
		            } else {
		              clone = src && isPlainObject(src) ? src : {};
		            }

		            // Never move original objects, clone them
		            setProperty(target, {
		              name: name,
		              newValue: extend(deep, clone, copy)
		            });

		            // Don't bring in undefined values
		          } else if (typeof copy !== 'undefined') {
		            setProperty(target, {
		              name: name,
		              newValue: copy
		            });
		          }
		        }
		      }
		    }
		  }

		  // Return the modified object
		  return target;
		};
		return extend$2;
	}

	var extendExports = requireExtend();
	var extend$1 = /*@__PURE__*/getDefaultExportFromCjs(extendExports);

	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {
	  toString
	} = Object.prototype;
	const {
	  getPrototypeOf
	} = Object;
	const kindOf = (cache => thing => {
	  const str = toString.call(thing);
	  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));
	const kindOfTest = type => {
	  type = type.toLowerCase();
	  return thing => kindOf(thing) === type;
	};
	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {
	  isArray
	} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = val && val.buffer && isArrayBuffer(val.buffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = thing => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = val => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }
	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = val => isObject(val) && isFunction(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = thing => {
	  let kind;
	  return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
	  // detect form-data instance
	  kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = str => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {
	  allOwnKeys = false
	} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }
	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }
	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;
	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}
	function findKey(obj, key) {
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}
	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
	})();
	const isContextDefined = context => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */
	) {
	  const {
	    caseless
	  } = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };
	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {
	  allOwnKeys
	} = {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {
	    allOwnKeys
	  });
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = content => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};
	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;
	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};

	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = thing => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[Symbol.iterator];
	  const iterator = generator.call(obj);
	  let result;
	  while ((result = iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];
	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }
	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');
	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
	    return p1.toUpperCase() + p2;
	  });
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({
	  hasOwnProperty
	}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');
	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};
	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });
	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = obj => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }
	    const value = obj[name];
	    if (!isFunction(value)) return;
	    descriptor.enumerable = false;
	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }
	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};
	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};
	  const define = arr => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };
	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
	  return obj;
	};
	const noop$1 = () => {};
	const toFiniteNumber = (value, defaultValue) => {
	  value = +value;
	  return Number.isFinite(value) ? value : defaultValue;
	};
	const ALPHA = 'abcdefghijklmnopqrstuvwxyz';
	const DIGIT = '0123456789';
	const ALPHABET = {
	  DIGIT,
	  ALPHA,
	  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
	};
	const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
	  let str = '';
	  const {
	    length
	  } = alphabet;
	  while (size--) {
	    str += alphabet[Math.random() * length | 0];
	  }
	  return str;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
	}
	const toJSONObject = obj => {
	  const stack = new Array(10);
	  const visit = (source, i) => {
	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }
	      if (!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};
	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });
	        stack[i] = undefined;
	        return target;
	      }
	    }
	    return source;
	  };
	  return visit(obj, 0);
	};
	const isAsyncFn = kindOfTest('AsyncFunction');
	const isThenable = thing => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
	var utils$2 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty,
	  // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop: noop$1,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  ALPHABET,
	  generateString,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError$1(message, code, config, request, response) {
	  Error.call(this);
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = new Error().stack;
	  }
	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  response && (this.response = response);
	}
	utils$2.inherits(AxiosError$1, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$2.toJSONObject(this.config),
	      code: this.code,
	      status: this.response && this.response.status ? this.response.status : null
	    };
	  }
	});
	const prototype$1 = AxiosError$1.prototype;
	const descriptors = {};
	['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {
	    value: code
	  };
	});
	Object.defineProperties(AxiosError$1, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {
	  value: true
	});

	// eslint-disable-next-line func-names
	AxiosError$1.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);
	  utils$2.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });
	  AxiosError$1.call(axiosError, error.message, code, config, request, response);
	  axiosError.cause = error;
	  axiosError.name = error.name;
	  customProps && Object.assign(axiosError, customProps);
	  return axiosError;
	};

	// eslint-disable-next-line strict
	var httpAdapter = null;

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$2.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$2.isArray(arr) && !arr.some(isVisitable);
	}
	const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData$1(obj, formData, options) {
	  if (!utils$2.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$2.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$2.isUndefined(source[option]);
	  });
	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
	  if (!utils$2.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }
	  function convertValue(value) {
	    if (value === null) return '';
	    if (utils$2.isDate(value)) {
	      return value.toISOString();
	    }
	    if (!useBlob && utils$2.isBlob(value)) {
	      throw new AxiosError$1('Blob is not supported. Use a Buffer instead.');
	    }
	    if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : bufferExports.Buffer.from(value);
	    }
	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;
	    if (value && !path && typeof value === 'object') {
	      if (utils$2.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, '[]')) && (arr = utils$2.toArray(value))) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);
	        arr.forEach(function each(el, index) {
	          !(utils$2.isUndefined(el) || el === null) && formData.append(
	          // eslint-disable-next-line no-nested-ternary
	          indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
	        });
	        return false;
	      }
	    }
	    if (isVisitable(value)) {
	      return true;
	    }
	    formData.append(renderKey(path, key, dots), convertValue(value));
	    return false;
	  }
	  const stack = [];
	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });
	  function build(value, path) {
	    if (utils$2.isUndefined(value)) return;
	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }
	    stack.push(value);
	    utils$2.forEach(value, function each(el, key) {
	      const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(formData, el, utils$2.isString(key) ? key.trim() : key, path, exposedHelpers);
	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });
	    stack.pop();
	  }
	  if (!utils$2.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }
	  build(obj);
	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$2(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];
	  params && toFormData$1(params, this, options);
	}
	const prototype = AxiosURLSearchParams.prototype;
	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};
	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function (value) {
	    return encoder.call(this, value, encode$2);
	  } : encode$2;
	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode$1(val) {
	  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?object} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  const _encode = options && options.encode || encode$1;
	  const serializeFn = options && options.serialize;
	  let serializedParams;
	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
	  }
	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");
	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }
	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$2.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}
	var InterceptorManager$1 = InterceptorManager;

	var transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

	var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

	var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

	var platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = (product => {
	  return hasBrowserEnv && ['ReactNative', 'NativeScript', 'NS'].indexOf(product) < 0;
	})(typeof navigator !== 'undefined' && navigator.product);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return typeof WorkerGlobalScope !== 'undefined' &&
	  // eslint-disable-next-line no-undef
	  self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
	})();

	var utils$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		hasBrowserEnv: hasBrowserEnv,
		hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
		hasStandardBrowserEnv: hasStandardBrowserEnv
	});

	var platform = {
	  ...utils$1,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData$1(data, new platform.classes.URLSearchParams(), Object.assign({
	    visitor: function (value, key, path, helpers) {
	      if (platform.isNode && utils$2.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }
	      return helpers.defaultVisitor.apply(this, arguments);
	    }
	  }, options));
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];
	    if (name === '__proto__') return true;
	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$2.isArray(target) ? target.length : name;
	    if (isLast) {
	      if (utils$2.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }
	      return !isNumericKey;
	    }
	    if (!target[name] || !utils$2.isObject(target[name])) {
	      target[name] = [];
	    }
	    const result = buildPath(path, value, target[name], index);
	    if (result && utils$2.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }
	    return !isNumericKey;
	  }
	  if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
	    const obj = {};
	    utils$2.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });
	    return obj;
	  }
	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$2.isString(rawValue)) {
	    try {
	      (parser || JSON.parse)(rawValue);
	      return utils$2.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }
	  return (encoder || JSON.stringify)(rawValue);
	}
	const defaults = {
	  transitional: transitionalDefaults,
	  adapter: ['xhr', 'http'],
	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$2.isObject(data);
	    if (isObjectPayload && utils$2.isHTMLForm(data)) {
	      data = new FormData(data);
	    }
	    const isFormData = utils$2.isFormData(data);
	    if (isFormData) {
	      if (!hasJSONContentType) {
	        return data;
	      }
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }
	    if (utils$2.isArrayBuffer(data) || utils$2.isBuffer(data) || utils$2.isStream(data) || utils$2.isFile(data) || utils$2.isBlob(data)) {
	      return data;
	    }
	    if (utils$2.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$2.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }
	    let isFileList;
	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }
	      if ((isFileList = utils$2.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;
	        return toFormData$1(isFileList ? {
	          'files[]': data
	        } : data, _FormData && new _FormData(), this.formSerializer);
	      }
	    }
	    if (isObjectPayload || hasJSONContentType) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }
	    return data;
	  }],
	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';
	    if (data && utils$2.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;
	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }
	    return data;
	  }],
	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,
	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',
	  maxContentLength: -1,
	  maxBodyLength: -1,
	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },
	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },
	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};
	utils$2.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], method => {
	  defaults.headers[method] = {};
	});
	var defaults$1 = defaults;

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$2.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;
	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();
	    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
	      return;
	    }
	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });
	  return parsed;
	};

	const $internals = Symbol('internals');
	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}
	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }
	  return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
	}
	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;
	  while (match = tokensRE.exec(str)) {
	    tokens[match[1]] = match[2];
	  }
	  return tokens;
	}
	const isValidHeaderName = str => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$2.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }
	  if (isHeaderNameFilter) {
	    value = header;
	  }
	  if (!utils$2.isString(value)) return;
	  if (utils$2.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }
	  if (utils$2.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}
	function formatHeader(header) {
	  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	    return char.toUpperCase() + str;
	  });
	}
	function buildAccessors(obj, header) {
	  const accessorName = utils$2.toCamelCase(' ' + header);
	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function (arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}
	class AxiosHeaders$1 {
	  constructor(headers) {
	    headers && this.set(headers);
	  }
	  set(header, valueOrRewrite, rewrite) {
	    const self = this;
	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);
	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }
	      const key = utils$2.findKey(self, lHeader);
	      if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }
	    const setHeaders = (headers, _rewrite) => utils$2.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
	    if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }
	    return this;
	  }
	  get(header, parser) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$2.findKey(this, header);
	      if (key) {
	        const value = this[key];
	        if (!parser) {
	          return value;
	        }
	        if (parser === true) {
	          return parseTokens(value);
	        }
	        if (utils$2.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }
	        if (utils$2.isRegExp(parser)) {
	          return parser.exec(value);
	        }
	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }
	  has(header, matcher) {
	    header = normalizeHeader(header);
	    if (header) {
	      const key = utils$2.findKey(this, header);
	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }
	    return false;
	  }
	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;
	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);
	      if (_header) {
	        const key = utils$2.findKey(self, _header);
	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];
	          deleted = true;
	        }
	      }
	    }
	    if (utils$2.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }
	    return deleted;
	  }
	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;
	    while (i--) {
	      const key = keys[i];
	      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }
	    return deleted;
	  }
	  normalize(format) {
	    const self = this;
	    const headers = {};
	    utils$2.forEach(this, (value, header) => {
	      const key = utils$2.findKey(headers, header);
	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }
	      const normalized = format ? formatHeader(header) : String(header).trim();
	      if (normalized !== header) {
	        delete self[header];
	      }
	      self[normalized] = normalizeValue(value);
	      headers[normalized] = true;
	    });
	    return this;
	  }
	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }
	  toJSON(asStrings) {
	    const obj = Object.create(null);
	    utils$2.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(', ') : value);
	    });
	    return obj;
	  }
	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }
	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }
	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }
	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }
	  static concat(first, ...targets) {
	    const computed = new this(first);
	    targets.forEach(target => computed.set(target));
	    return computed;
	  }
	  static accessor(header) {
	    const internals = this[$internals] = this[$internals] = {
	      accessors: {}
	    };
	    const accessors = internals.accessors;
	    const prototype = this.prototype;
	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);
	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }
	    utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
	    return this;
	  }
	}
	AxiosHeaders$1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$2.reduceDescriptors(AxiosHeaders$1.prototype, ({
	  value
	}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  };
	});
	utils$2.freezeMethods(AxiosHeaders$1);
	var AxiosHeaders$2 = AxiosHeaders$1;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults$1;
	  const context = response || config;
	  const headers = AxiosHeaders$2.from(context.headers);
	  let data = context.data;
	  utils$2.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });
	  headers.normalize();
	  return data;
	}

	function isCancel$1(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError$1(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError$1.call(this, message == null ? 'canceled' : message, AxiosError$1.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}
	utils$2.inherits(CanceledError$1, AxiosError$1, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError$1('Request failed with status code ' + response.status, [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
	  }
	}

	var cookies = platform.hasStandardBrowserEnv ?
	// Standard browser envs support document.cookie
	{
	  write(name, value, expires, path, domain, secure) {
	    const cookie = [name + '=' + encodeURIComponent(value)];
	    utils$2.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
	    utils$2.isString(path) && cookie.push('path=' + path);
	    utils$2.isString(domain) && cookie.push('domain=' + domain);
	    secure === true && cookie.push('secure');
	    document.cookie = cookie.join('; ');
	  },
	  read(name) {
	    const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	    return match ? decodeURIComponent(match[3]) : null;
	  },
	  remove(name) {
	    this.write(name, '', Date.now() - 86400000);
	  }
	} :
	// Non-standard browser env (web workers, react-native) lack needed support.
	{
	  write() {},
	  read() {
	    return null;
	  },
	  remove() {}
	};

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL) {
	  if (baseURL && !isAbsoluteURL(requestedURL)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	var isURLSameOrigin = platform.hasStandardBrowserEnv ?
	// Standard browser envs have full support of the APIs needed to test
	// whether the request URL is of the same origin as current location.
	function standardBrowserEnv() {
	  const msie = /(msie|trident)/i.test(navigator.userAgent);
	  const urlParsingNode = document.createElement('a');
	  let originURL;

	  /**
	  * Parse a URL to discover its components
	  *
	  * @param {String} url The URL to be parsed
	  * @returns {Object}
	  */
	  function resolveURL(url) {
	    let href = url;
	    if (msie) {
	      // IE needs attribute set twice to normalize properties
	      urlParsingNode.setAttribute('href', href);
	      href = urlParsingNode.href;
	    }
	    urlParsingNode.setAttribute('href', href);

	    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	    return {
	      href: urlParsingNode.href,
	      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	      host: urlParsingNode.host,
	      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	      hostname: urlParsingNode.hostname,
	      port: urlParsingNode.port,
	      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
	    };
	  }
	  originURL = resolveURL(window.location.href);

	  /**
	  * Determine if a URL shares the same origin as the current location
	  *
	  * @param {String} requestURL The URL to test
	  * @returns {boolean} True if URL shares the same origin, otherwise false
	  */
	  return function isURLSameOrigin(requestURL) {
	    const parsed = utils$2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
	    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
	  };
	}() :
	// Non standard browser envs (web workers, react-native) lack needed support.
	function nonStandardBrowserEnv() {
	  return function isURLSameOrigin() {
	    return true;
	  };
	}();

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;
	  min = min !== undefined ? min : 1000;
	  return function push(chunkLength) {
	    const now = Date.now();
	    const startedAt = timestamps[tail];
	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }
	    bytes[head] = chunkLength;
	    timestamps[head] = now;
	    let i = tail;
	    let bytesCount = 0;
	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }
	    head = (head + 1) % samplesCount;
	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }
	    if (now - firstSampleTS < min) {
	      return;
	    }
	    const passed = startedAt && now - startedAt;
	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	function progressEventReducer(listener, isDownloadStream) {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);
	  return e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;
	    bytesNotified = loaded;
	    const data = {
	      loaded,
	      total,
	      progress: total ? loaded / total : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e
	    };
	    data[isDownloadStream ? 'download' : 'upload'] = true;
	    listener(data);
	  };
	}
	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
	var xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    let requestData = config.data;
	    const requestHeaders = AxiosHeaders$2.from(config.headers).normalize();
	    let {
	      responseType,
	      withXSRFToken
	    } = config;
	    let onCanceled;
	    function done() {
	      if (config.cancelToken) {
	        config.cancelToken.unsubscribe(onCanceled);
	      }
	      if (config.signal) {
	        config.signal.removeEventListener('abort', onCanceled);
	      }
	    }
	    let contentType;
	    if (utils$2.isFormData(requestData)) {
	      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	        requestHeaders.setContentType(false); // Let the browser set it
	      } else if ((contentType = requestHeaders.getContentType()) !== false) {
	        // fix semicolon duplication issue for ReactNative FormData implementation
	        const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
	        requestHeaders.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
	      }
	    }
	    let request = new XMLHttpRequest();

	    // HTTP basic authentication
	    if (config.auth) {
	      const username = config.auth.username || '';
	      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
	      requestHeaders.set('Authorization', 'Basic ' + btoa(username + ':' + password));
	    }
	    const fullPath = buildFullPath(config.baseURL, config.url);
	    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;
	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders$2.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };
	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }
	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }
	      reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = config.transitional || transitionalDefaults;
	      if (config.timeoutErrorMessage) {
	        timeoutErrorMessage = config.timeoutErrorMessage;
	      }
	      reject(new AxiosError$1(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (platform.hasStandardBrowserEnv) {
	      withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
	      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
	        // Add xsrf header
	        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
	        if (xsrfValue) {
	          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
	        }
	      }
	    }

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$2.isUndefined(config.withCredentials)) {
	      request.withCredentials = !!config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = config.responseType;
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', progressEventReducer(config.onDownloadProgress, true));
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', progressEventReducer(config.onUploadProgress));
	    }
	    if (config.cancelToken || config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };
	      config.cancelToken && config.cancelToken.subscribe(onCanceled);
	      if (config.signal) {
	        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
	      }
	    }
	    const protocol = parseProtocol(fullPath);
	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError$1('Unsupported protocol ' + protocol + ':', AxiosError$1.ERR_BAD_REQUEST, config));
	      return;
	    }

	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter
	};
	utils$2.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {
	        value
	      });
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {
	      value
	    });
	  }
	});
	const renderReason = reason => `- ${reason}`;
	const isResolvedHandle = adapter => utils$2.isFunction(adapter) || adapter === null || adapter === false;
	var adapters = {
	  getAdapter: adapters => {
	    adapters = utils$2.isArray(adapters) ? adapters : [adapters];
	    const {
	      length
	    } = adapters;
	    let nameOrAdapter;
	    let adapter;
	    const rejectedReasons = {};
	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters[i];
	      let id;
	      adapter = nameOrAdapter;
	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
	        if (adapter === undefined) {
	          throw new AxiosError$1(`Unknown adapter '${id}'`);
	        }
	      }
	      if (adapter) {
	        break;
	      }
	      rejectedReasons[id || '#' + i] = adapter;
	    }
	    if (!adapter) {
	      const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));
	      let s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
	      throw new AxiosError$1(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');
	    }
	    return adapter;
	  },
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError$1(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);
	  config.headers = AxiosHeaders$2.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(config, config.transformRequest);
	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }
	  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(config, config.transformResponse, response);
	    response.headers = AxiosHeaders$2.from(response.headers);
	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel$1(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(config, config.transformResponse, reason.response);
	        reason.response.headers = AxiosHeaders$2.from(reason.response.headers);
	      }
	    }
	    return Promise.reject(reason);
	  });
	}

	const headersToObject = thing => thing instanceof AxiosHeaders$2 ? thing.toJSON() : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig$1(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};
	  function getMergedValue(target, source, caseless) {
	    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
	      return utils$2.merge.call({
	        caseless
	      }, target, source);
	    } else if (utils$2.isPlainObject(source)) {
	      return utils$2.merge({}, source);
	    } else if (utils$2.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, caseless) {
	    if (!utils$2.isUndefined(b)) {
	      return getMergedValue(a, b, caseless);
	    } else if (!utils$2.isUndefined(a)) {
	      return getMergedValue(undefined, a, caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$2.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$2.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$2.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }
	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
	  };
	  utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    utils$2.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
	  });
	  return config;
	}

	const VERSION$1 = "1.6.5";

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});
	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION$1 + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError$1(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError$1.ERR_DEPRECATED);
	    }
	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
	    }
	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError$1('options must be an object', AxiosError$1.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError$1('option ' + opt + ' must be ' + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError$1('Unknown option ' + opt, AxiosError$1.ERR_BAD_OPTION);
	    }
	  }
	}
	var validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	class Axios$1 {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig;
	    this.interceptors = {
	      request: new InterceptorManager$1(),
	      response: new InterceptorManager$1()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }
	    config = mergeConfig$1(this.defaults, config);
	    const {
	      transitional,
	      paramsSerializer,
	      headers
	    } = config;
	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }
	    if (paramsSerializer != null) {
	      if (utils$2.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$2.merge(headers.common, headers[config.method]);
	    headers && utils$2.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], method => {
	      delete headers[method];
	    });
	    config.headers = AxiosHeaders$2.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }
	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });
	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });
	    let promise;
	    let i = 0;
	    let len;
	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift.apply(chain, requestInterceptorChain);
	      chain.push.apply(chain, responseInterceptorChain);
	      len = chain.length;
	      promise = Promise.resolve(config);
	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }
	      return promise;
	    }
	    len = requestInterceptorChain.length;
	    let newConfig = config;
	    i = 0;
	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }
	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }
	    i = 0;
	    len = responseInterceptorChain.length;
	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }
	    return promise;
	  }
	  getUri(config) {
	    config = mergeConfig$1(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}

	// Provide aliases for supported request methods
	utils$2.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios$1.prototype[method] = function (url, config) {
	    return this.request(mergeConfig$1(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});
	utils$2.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig$1(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }
	  Axios$1.prototype[method] = generateHTTPMethod();
	  Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
	});
	var Axios$2 = Axios$1;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	class CancelToken$1 {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }
	    let resolvePromise;
	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });
	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;
	      let i = token._listeners.length;
	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);
	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };
	      return promise;
	    };
	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }
	      token.reason = new CanceledError$1(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }
	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken$1(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}
	var CancelToken$2 = CancelToken$1;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread$1(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError$1(payload) {
	  return utils$2.isObject(payload) && payload.isAxiosError === true;
	}

	const HttpStatusCode$1 = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511
	};
	Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
	  HttpStatusCode$1[value] = key;
	});
	var HttpStatusCode$2 = HttpStatusCode$1;

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios$2(defaultConfig);
	  const instance = bind(Axios$2.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$2.extend(instance, Axios$2.prototype, context, {
	    allOwnKeys: true
	  });

	  // Copy context to instance
	  utils$2.extend(instance, context, null, {
	    allOwnKeys: true
	  });

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
	  };
	  return instance;
	}

	// Create the default instance to be exported
	const axios = createInstance(defaults$1);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios$2;

	// Expose Cancel & CancelToken
	axios.CanceledError = CanceledError$1;
	axios.CancelToken = CancelToken$2;
	axios.isCancel = isCancel$1;
	axios.VERSION = VERSION$1;
	axios.toFormData = toFormData$1;

	// Expose AxiosError class
	axios.AxiosError = AxiosError$1;

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = spread$1;

	// Expose isAxiosError
	axios.isAxiosError = isAxiosError$1;

	// Expose mergeConfig
	axios.mergeConfig = mergeConfig$1;
	axios.AxiosHeaders = AxiosHeaders$2;
	axios.formToJSON = thing => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
	axios.getAdapter = adapters.getAdapter;
	axios.HttpStatusCode = HttpStatusCode$2;
	axios.default = axios;

	// this module should only have a default export
	var axios3 = axios;

	// This module is intended to unwrap Axios default export as named.
	// Keep top-level export same with static properties
	// so that it can keep same with es module or cjs
	const {
	  Axios,
	  AxiosError,
	  CanceledError,
	  isCancel,
	  CancelToken,
	  VERSION,
	  all,
	  Cancel,
	  isAxiosError,
	  spread,
	  toFormData,
	  AxiosHeaders,
	  HttpStatusCode,
	  formToJSON,
	  getAdapter,
	  mergeConfig
	} = axios3;

	var base64JsExports = requireBase64Js();

	var xr = Object.create;
	var it$1 = Object.defineProperty;
	var mr$1 = Object.getOwnPropertyDescriptor;
	var Br$1 = Object.getOwnPropertyNames;
	var Er$1 = Object.getPrototypeOf,
	  br$1 = Object.prototype.hasOwnProperty;
	var T = (e, t) => () => (t || e((t = {
	    exports: {}
	  }).exports, t), t.exports),
	  Ar$1 = (e, t) => {
	    for (var r in t) it$1(e, r, {
	      get: t[r],
	      enumerable: !0
	    });
	  },
	  Tr$1 = (e, t, r, n) => {
	    if (t && typeof t == "object" || typeof t == "function") for (let i of Br$1(t)) !br$1.call(e, i) && i !== r && it$1(e, i, {
	      get: () => t[i],
	      enumerable: !(n = mr$1(t, i)) || n.enumerable
	    });
	    return e;
	  };
	var C$1 = (e, t, r) => (r = e != null ? xr(Er$1(e)) : {}, Tr$1(t || !e || !e.__esModule ? it$1(r, "default", {
	  value: e,
	  enumerable: !0
	}) : r, e));
	var Rt$1 = T(st => {

	  Object.defineProperty(st, "__esModule", {
	    value: !0
	  });
	  function Ir(e) {
	    var t = 4,
	      r = e.length,
	      n = r % t;
	    if (!n) return e;
	    var i = r,
	      o = t - n,
	      s = r + o,
	      u = bufferExports.Buffer.alloc(s);
	    for (u.write(e); o--;) u.write("=", i++);
	    return u.toString();
	  }
	  st.default = Ir;
	});
	var Dt$1 = T(ht => {

	  Object.defineProperty(ht, "__esModule", {
	    value: !0
	  });
	  var Sr = Rt$1();
	  function Ct(e, t) {
	    return t === void 0 && (t = "utf8"), bufferExports.Buffer.isBuffer(e) ? at(e.toString("base64")) : at(bufferExports.Buffer.from(e, t).toString("base64"));
	  }
	  function Ur(e, t) {
	    return t === void 0 && (t = "utf8"), bufferExports.Buffer.from(ut(e), "base64").toString(t);
	  }
	  function ut(e) {
	    return e = e.toString(), Sr.default(e).replace(/\-/g, "+").replace(/_/g, "/");
	  }
	  function at(e) {
	    return e.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	  }
	  function Fr(e) {
	    return bufferExports.Buffer.from(ut(e), "base64");
	  }
	  var O = Ct;
	  O.encode = Ct;
	  O.decode = Ur;
	  O.toBase64 = ut;
	  O.fromBase64 = at;
	  O.toBuffer = Fr;
	  ht.default = O;
	});
	var z$1 = T((me, V) => {
	  V.exports = Dt$1().default;
	  V.exports.default = V.exports;
	});
	var ct$1 = T(J => {

	  J.byteLength = _r;
	  J.toByteArray = Cr;
	  J.fromByteArray = Nr;
	  var b = [],
	    m = [],
	    Lr = typeof Uint8Array < "u" ? Uint8Array : Array,
	    ft = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	  for (D = 0, Pt = ft.length; D < Pt; ++D) b[D] = ft[D], m[ft.charCodeAt(D)] = D;
	  var D, Pt;
	  m["-".charCodeAt(0)] = 62;
	  m["_".charCodeAt(0)] = 63;
	  function Nt(e) {
	    var t = e.length;
	    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
	    var r = e.indexOf("=");
	    r === -1 && (r = t);
	    var n = r === t ? 0 : 4 - r % 4;
	    return [r, n];
	  }
	  function _r(e) {
	    var t = Nt(e),
	      r = t[0],
	      n = t[1];
	    return (r + n) * 3 / 4 - n;
	  }
	  function Rr(e, t, r) {
	    return (t + r) * 3 / 4 - r;
	  }
	  function Cr(e) {
	    var t,
	      r = Nt(e),
	      n = r[0],
	      i = r[1],
	      o = new Lr(Rr(e, n, i)),
	      s = 0,
	      u = i > 0 ? n - 4 : n,
	      h;
	    for (h = 0; h < u; h += 4) t = m[e.charCodeAt(h)] << 18 | m[e.charCodeAt(h + 1)] << 12 | m[e.charCodeAt(h + 2)] << 6 | m[e.charCodeAt(h + 3)], o[s++] = t >> 16 & 255, o[s++] = t >> 8 & 255, o[s++] = t & 255;
	    return i === 2 && (t = m[e.charCodeAt(h)] << 2 | m[e.charCodeAt(h + 1)] >> 4, o[s++] = t & 255), i === 1 && (t = m[e.charCodeAt(h)] << 10 | m[e.charCodeAt(h + 1)] << 4 | m[e.charCodeAt(h + 2)] >> 2, o[s++] = t >> 8 & 255, o[s++] = t & 255), o;
	  }
	  function Dr(e) {
	    return b[e >> 18 & 63] + b[e >> 12 & 63] + b[e >> 6 & 63] + b[e & 63];
	  }
	  function Pr(e, t, r) {
	    for (var n, i = [], o = t; o < r; o += 3) n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (e[o + 2] & 255), i.push(Dr(n));
	    return i.join("");
	  }
	  function Nr(e) {
	    for (var t, r = e.length, n = r % 3, i = [], o = 16383, s = 0, u = r - n; s < u; s += o) i.push(Pr(e, s, s + o > u ? u : s + o));
	    return n === 1 ? (t = e[r - 1], i.push(b[t >> 2] + b[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(b[t >> 10] + b[t >> 4 & 63] + b[t << 2 & 63] + "=")), i.join("");
	  }
	});
	var pt$1 = T(g => {

	  Object.defineProperty(g, "__esModule", {
	    value: !0
	  });
	  g.b64UrlDecode = g.b64UrlEncode = g.bufferTob64Url = g.bufferTob64 = g.b64UrlToBuffer = g.stringToB64Url = g.stringToBuffer = g.bufferToString = g.b64UrlToString = g.concatBuffers = void 0;
	  var kt = ct$1();
	  function kr(e) {
	    let t = 0;
	    for (let i = 0; i < e.length; i++) t += e[i].byteLength;
	    let r = new Uint8Array(t),
	      n = 0;
	    r.set(new Uint8Array(e[0]), n), n += e[0].byteLength;
	    for (let i = 1; i < e.length; i++) r.set(new Uint8Array(e[i]), n), n += e[i].byteLength;
	    return r;
	  }
	  g.concatBuffers = kr;
	  function Mr(e) {
	    let t = $t(e);
	    return Mt(t);
	  }
	  g.b64UrlToString = Mr;
	  function Mt(e) {
	    return new TextDecoder("utf-8", {
	      fatal: !0
	    }).decode(e);
	  }
	  g.bufferToString = Mt;
	  function Ot(e) {
	    return new TextEncoder().encode(e);
	  }
	  g.stringToBuffer = Ot;
	  function Or(e) {
	    return Ht(Ot(e));
	  }
	  g.stringToB64Url = Or;
	  function $t(e) {
	    return new Uint8Array(kt.toByteArray(qt(e)));
	  }
	  g.b64UrlToBuffer = $t;
	  function Kt(e) {
	    return kt.fromByteArray(new Uint8Array(e));
	  }
	  g.bufferTob64 = Kt;
	  function Ht(e) {
	    return jt(Kt(e));
	  }
	  g.bufferTob64Url = Ht;
	  function jt(e) {
	    return e.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
	  }
	  g.b64UrlEncode = jt;
	  function qt(e) {
	    e = e.replace(/\-/g, "+").replace(/\_/g, "/");
	    let t;
	    return e.length % 4 == 0 ? t = 0 : t = 4 - e.length % 4, e.concat("=".repeat(t));
	  }
	  g.b64UrlDecode = qt;
	});
	var Yt$1 = T(gt => {

	  Object.defineProperty(gt, "__esModule", {
	    value: !0
	  });
	  var F = pt$1(),
	    lt = class {
	      keyLength = 4096;
	      publicExponent = 65537;
	      hashAlgorithm = "sha256";
	      driver;
	      constructor() {
	        if (!this.detectWebCrypto()) throw new Error("SubtleCrypto not available!");
	        this.driver = crypto.subtle;
	      }
	      async generateJWK() {
	        let t = await this.driver.generateKey({
	            name: "RSA-PSS",
	            modulusLength: 4096,
	            publicExponent: new Uint8Array([1, 0, 1]),
	            hash: {
	              name: "SHA-256"
	            }
	          }, !0, ["sign"]),
	          r = await this.driver.exportKey("jwk", t.privateKey);
	        return {
	          kty: r.kty,
	          e: r.e,
	          n: r.n,
	          d: r.d,
	          p: r.p,
	          q: r.q,
	          dp: r.dp,
	          dq: r.dq,
	          qi: r.qi
	        };
	      }
	      async sign(t, r, {
	        saltLength: n
	      } = {}) {
	        let i = await this.driver.sign({
	          name: "RSA-PSS",
	          saltLength: 32
	        }, await this.jwkToCryptoKey(t), r);
	        return new Uint8Array(i);
	      }
	      async hash(t, r = "SHA-256") {
	        let n = await this.driver.digest(r, t);
	        return new Uint8Array(n);
	      }
	      async verify(t, r, n) {
	        let i = {
	            kty: "RSA",
	            e: "AQAB",
	            n: t
	          },
	          o = await this.jwkToPublicCryptoKey(i),
	          s = await this.driver.digest("SHA-256", r),
	          u = await this.driver.verify({
	            name: "RSA-PSS",
	            saltLength: 0
	          }, o, n, r),
	          h = await this.driver.verify({
	            name: "RSA-PSS",
	            saltLength: 32
	          }, o, n, r),
	          p = await this.driver.verify({
	            name: "RSA-PSS",
	            saltLength: Math.ceil((o.algorithm.modulusLength - 1) / 8) - s.byteLength - 2
	          }, o, n, r);
	        return u || h || p;
	      }
	      async jwkToCryptoKey(t) {
	        return this.driver.importKey("jwk", t, {
	          name: "RSA-PSS",
	          hash: {
	            name: "SHA-256"
	          }
	        }, !1, ["sign"]);
	      }
	      async jwkToPublicCryptoKey(t) {
	        return this.driver.importKey("jwk", t, {
	          name: "RSA-PSS",
	          hash: {
	            name: "SHA-256"
	          }
	        }, !1, ["verify"]);
	      }
	      detectWebCrypto() {
	        if (typeof crypto > "u") return !1;
	        let t = crypto?.subtle;
	        return t === void 0 ? !1 : ["generateKey", "importKey", "exportKey", "digest", "sign"].every(n => typeof t[n] == "function");
	      }
	      async encrypt(t, r, n) {
	        let i = await this.driver.importKey("raw", typeof r == "string" ? F.stringToBuffer(r) : r, {
	            name: "PBKDF2",
	            length: 32
	          }, !1, ["deriveKey"]),
	          o = await this.driver.deriveKey({
	            name: "PBKDF2",
	            salt: n ? F.stringToBuffer(n) : F.stringToBuffer("salt"),
	            iterations: 1e5,
	            hash: "SHA-256"
	          }, i, {
	            name: "AES-CBC",
	            length: 256
	          }, !1, ["encrypt", "decrypt"]),
	          s = new Uint8Array(16);
	        crypto.getRandomValues(s);
	        let u = await this.driver.encrypt({
	          name: "AES-CBC",
	          iv: s
	        }, o, t);
	        return F.concatBuffers([s, u]);
	      }
	      async decrypt(t, r, n) {
	        let i = await this.driver.importKey("raw", typeof r == "string" ? F.stringToBuffer(r) : r, {
	            name: "PBKDF2",
	            length: 32
	          }, !1, ["deriveKey"]),
	          o = await this.driver.deriveKey({
	            name: "PBKDF2",
	            salt: n ? F.stringToBuffer(n) : F.stringToBuffer("salt"),
	            iterations: 1e5,
	            hash: "SHA-256"
	          }, i, {
	            name: "AES-CBC",
	            length: 256
	          }, !1, ["encrypt", "decrypt"]),
	          s = t.slice(0, 16),
	          u = await this.driver.decrypt({
	            name: "AES-CBC",
	            iv: s
	          }, o, t.slice(16));
	        return F.concatBuffers([u]);
	      }
	    };
	  gt.default = lt;
	});
	var zt$1 = T(mt => {
	  mt.read = function (e, t, r, n, i) {
	    var o,
	      s,
	      u = i * 8 - n - 1,
	      h = (1 << u) - 1,
	      p = h >> 1,
	      f = -7,
	      c = r ? i - 1 : 0,
	      U = r ? -1 : 1,
	      l = e[t + c];
	    for (c += U, o = l & (1 << -f) - 1, l >>= -f, f += u; f > 0; o = o * 256 + e[t + c], c += U, f -= 8);
	    for (s = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; s = s * 256 + e[t + c], c += U, f -= 8);
	    if (o === 0) o = 1 - p;else {
	      if (o === h) return s ? NaN : (l ? -1 : 1) * (1 / 0);
	      s = s + Math.pow(2, n), o = o - p;
	    }
	    return (l ? -1 : 1) * s * Math.pow(2, o - n);
	  };
	  mt.write = function (e, t, r, n, i, o) {
	    var s,
	      u,
	      h,
	      p = o * 8 - i - 1,
	      f = (1 << p) - 1,
	      c = f >> 1,
	      U = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
	      l = n ? 0 : o - 1,
	      R = n ? 1 : -1,
	      G = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
	    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, s = f) : (s = Math.floor(Math.log(t) / Math.LN2), t * (h = Math.pow(2, -s)) < 1 && (s--, h *= 2), s + c >= 1 ? t += U / h : t += U * Math.pow(2, 1 - c), t * h >= 2 && (s++, h /= 2), s + c >= f ? (u = 0, s = f) : s + c >= 1 ? (u = (t * h - 1) * Math.pow(2, i), s = s + c) : (u = t * Math.pow(2, c - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + l] = u & 255, l += R, u /= 256, i -= 8);
	    for (s = s << i | u, p += i; p > 0; e[r + l] = s & 255, l += R, s /= 256, p -= 8);
	    e[r + l - R] |= G * 128;
	  };
	});
	var nt$1 = T(q => {

	  var Bt = ct$1(),
	    H = zt$1(),
	    Jt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
	  q.Buffer = a;
	  q.SlowBuffer = Vr;
	  q.INSPECT_MAX_BYTES = 50;
	  var rt = 2147483647;
	  q.kMaxLength = rt;
	  a.TYPED_ARRAY_SUPPORT = qr();
	  !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
	  function qr() {
	    try {
	      let e = new Uint8Array(1),
	        t = {
	          foo: function () {
	            return 42;
	          }
	        };
	      return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
	    } catch {
	      return !1;
	    }
	  }
	  Object.defineProperty(a.prototype, "parent", {
	    enumerable: !0,
	    get: function () {
	      if (a.isBuffer(this)) return this.buffer;
	    }
	  });
	  Object.defineProperty(a.prototype, "offset", {
	    enumerable: !0,
	    get: function () {
	      if (a.isBuffer(this)) return this.byteOffset;
	    }
	  });
	  function S(e) {
	    if (e > rt) throw new RangeError('The value "' + e + '" is invalid for option "size"');
	    let t = new Uint8Array(e);
	    return Object.setPrototypeOf(t, a.prototype), t;
	  }
	  function a(e, t, r) {
	    if (typeof e == "number") {
	      if (typeof t == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
	      return Tt(e);
	    }
	    return tr(e, t, r);
	  }
	  a.poolSize = 8192;
	  function tr(e, t, r) {
	    if (typeof e == "string") return Yr(e, t);
	    if (ArrayBuffer.isView(e)) return vr(e);
	    if (e == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
	    if (A(e, ArrayBuffer) || e && A(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (A(e, SharedArrayBuffer) || e && A(e.buffer, SharedArrayBuffer))) return bt(e, t, r);
	    if (typeof e == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
	    let n = e.valueOf && e.valueOf();
	    if (n != null && n !== e) return a.from(n, t, r);
	    let i = Wr(e);
	    if (i) return i;
	    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function") return a.from(e[Symbol.toPrimitive]("string"), t, r);
	    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
	  }
	  a.from = function (e, t, r) {
	    return tr(e, t, r);
	  };
	  Object.setPrototypeOf(a.prototype, Uint8Array.prototype);
	  Object.setPrototypeOf(a, Uint8Array);
	  function rr(e) {
	    if (typeof e != "number") throw new TypeError('"size" argument must be of type number');
	    if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"');
	  }
	  function Gr(e, t, r) {
	    return rr(e), e <= 0 ? S(e) : t !== void 0 ? typeof r == "string" ? S(e).fill(t, r) : S(e).fill(t) : S(e);
	  }
	  a.alloc = function (e, t, r) {
	    return Gr(e, t, r);
	  };
	  function Tt(e) {
	    return rr(e), S(e < 0 ? 0 : It(e) | 0);
	  }
	  a.allocUnsafe = function (e) {
	    return Tt(e);
	  };
	  a.allocUnsafeSlow = function (e) {
	    return Tt(e);
	  };
	  function Yr(e, t) {
	    if ((typeof t != "string" || t === "") && (t = "utf8"), !a.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
	    let r = er(e, t) | 0,
	      n = S(r),
	      i = n.write(e, t);
	    return i !== r && (n = n.slice(0, i)), n;
	  }
	  function Et(e) {
	    let t = e.length < 0 ? 0 : It(e.length) | 0,
	      r = S(t);
	    for (let n = 0; n < t; n += 1) r[n] = e[n] & 255;
	    return r;
	  }
	  function vr(e) {
	    if (A(e, Uint8Array)) {
	      let t = new Uint8Array(e);
	      return bt(t.buffer, t.byteOffset, t.byteLength);
	    }
	    return Et(e);
	  }
	  function bt(e, t, r) {
	    if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
	    if (e.byteLength < t + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
	    let n;
	    return t === void 0 && r === void 0 ? n = new Uint8Array(e) : r === void 0 ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, a.prototype), n;
	  }
	  function Wr(e) {
	    if (a.isBuffer(e)) {
	      let t = It(e.length) | 0,
	        r = S(t);
	      return r.length === 0 || e.copy(r, 0, 0, t), r;
	    }
	    if (e.length !== void 0) return typeof e.length != "number" || Ut(e.length) ? S(0) : Et(e);
	    if (e.type === "Buffer" && Array.isArray(e.data)) return Et(e.data);
	  }
	  function It(e) {
	    if (e >= rt) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + rt.toString(16) + " bytes");
	    return e | 0;
	  }
	  function Vr(e) {
	    return +e != e && (e = 0), a.alloc(+e);
	  }
	  a.isBuffer = function (t) {
	    return t != null && t._isBuffer === !0 && t !== a.prototype;
	  };
	  a.compare = function (t, r) {
	    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), A(r, Uint8Array) && (r = a.from(r, r.offset, r.byteLength)), !a.isBuffer(t) || !a.isBuffer(r)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
	    if (t === r) return 0;
	    let n = t.length,
	      i = r.length;
	    for (let o = 0, s = Math.min(n, i); o < s; ++o) if (t[o] !== r[o]) {
	      n = t[o], i = r[o];
	      break;
	    }
	    return n < i ? -1 : i < n ? 1 : 0;
	  };
	  a.isEncoding = function (t) {
	    switch (String(t).toLowerCase()) {
	      case "hex":
	      case "utf8":
	      case "utf-8":
	      case "ascii":
	      case "latin1":
	      case "binary":
	      case "base64":
	      case "ucs2":
	      case "ucs-2":
	      case "utf16le":
	      case "utf-16le":
	        return !0;
	      default:
	        return !1;
	    }
	  };
	  a.concat = function (t, r) {
	    if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
	    if (t.length === 0) return a.alloc(0);
	    let n;
	    if (r === void 0) for (r = 0, n = 0; n < t.length; ++n) r += t[n].length;
	    let i = a.allocUnsafe(r),
	      o = 0;
	    for (n = 0; n < t.length; ++n) {
	      let s = t[n];
	      if (A(s, Uint8Array)) o + s.length > i.length ? (a.isBuffer(s) || (s = a.from(s)), s.copy(i, o)) : Uint8Array.prototype.set.call(i, s, o);else if (a.isBuffer(s)) s.copy(i, o);else throw new TypeError('"list" argument must be an Array of Buffers');
	      o += s.length;
	    }
	    return i;
	  };
	  function er(e, t) {
	    if (a.isBuffer(e)) return e.length;
	    if (ArrayBuffer.isView(e) || A(e, ArrayBuffer)) return e.byteLength;
	    if (typeof e != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
	    let r = e.length,
	      n = arguments.length > 2 && arguments[2] === !0;
	    if (!n && r === 0) return 0;
	    let i = !1;
	    for (;;) switch (t) {
	      case "ascii":
	      case "latin1":
	      case "binary":
	        return r;
	      case "utf8":
	      case "utf-8":
	        return At(e).length;
	      case "ucs2":
	      case "ucs-2":
	      case "utf16le":
	      case "utf-16le":
	        return r * 2;
	      case "hex":
	        return r >>> 1;
	      case "base64":
	        return cr(e).length;
	      default:
	        if (i) return n ? -1 : At(e).length;
	        t = ("" + t).toLowerCase(), i = !0;
	    }
	  }
	  a.byteLength = er;
	  function zr(e, t, r) {
	    let n = !1;
	    if ((t === void 0 || t < 0) && (t = 0), t > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t)) return "";
	    for (e || (e = "utf8");;) switch (e) {
	      case "hex":
	        return oe(this, t, r);
	      case "utf8":
	      case "utf-8":
	        return ir(this, t, r);
	      case "ascii":
	        return ne(this, t, r);
	      case "latin1":
	      case "binary":
	        return ie(this, t, r);
	      case "base64":
	        return re(this, t, r);
	      case "ucs2":
	      case "ucs-2":
	      case "utf16le":
	      case "utf-16le":
	        return se(this, t, r);
	      default:
	        if (n) throw new TypeError("Unknown encoding: " + e);
	        e = (e + "").toLowerCase(), n = !0;
	    }
	  }
	  a.prototype._isBuffer = !0;
	  function k(e, t, r) {
	    let n = e[t];
	    e[t] = e[r], e[r] = n;
	  }
	  a.prototype.swap16 = function () {
	    let t = this.length;
	    if (t % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
	    for (let r = 0; r < t; r += 2) k(this, r, r + 1);
	    return this;
	  };
	  a.prototype.swap32 = function () {
	    let t = this.length;
	    if (t % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
	    for (let r = 0; r < t; r += 4) k(this, r, r + 3), k(this, r + 1, r + 2);
	    return this;
	  };
	  a.prototype.swap64 = function () {
	    let t = this.length;
	    if (t % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
	    for (let r = 0; r < t; r += 8) k(this, r, r + 7), k(this, r + 1, r + 6), k(this, r + 2, r + 5), k(this, r + 3, r + 4);
	    return this;
	  };
	  a.prototype.toString = function () {
	    let t = this.length;
	    return t === 0 ? "" : arguments.length === 0 ? ir(this, 0, t) : zr.apply(this, arguments);
	  };
	  a.prototype.toLocaleString = a.prototype.toString;
	  a.prototype.equals = function (t) {
	    if (!a.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
	    return this === t ? !0 : a.compare(this, t) === 0;
	  };
	  a.prototype.inspect = function () {
	    let t = "",
	      r = q.INSPECT_MAX_BYTES;
	    return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
	  };
	  Jt && (a.prototype[Jt] = a.prototype.inspect);
	  a.prototype.compare = function (t, r, n, i, o) {
	    if (A(t, Uint8Array) && (t = a.from(t, t.offset, t.byteLength)), !a.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
	    if (r === void 0 && (r = 0), n === void 0 && (n = t ? t.length : 0), i === void 0 && (i = 0), o === void 0 && (o = this.length), r < 0 || n > t.length || i < 0 || o > this.length) throw new RangeError("out of range index");
	    if (i >= o && r >= n) return 0;
	    if (i >= o) return -1;
	    if (r >= n) return 1;
	    if (r >>>= 0, n >>>= 0, i >>>= 0, o >>>= 0, this === t) return 0;
	    let s = o - i,
	      u = n - r,
	      h = Math.min(s, u),
	      p = this.slice(i, o),
	      f = t.slice(r, n);
	    for (let c = 0; c < h; ++c) if (p[c] !== f[c]) {
	      s = p[c], u = f[c];
	      break;
	    }
	    return s < u ? -1 : u < s ? 1 : 0;
	  };
	  function nr(e, t, r, n, i) {
	    if (e.length === 0) return -1;
	    if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Ut(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
	      if (i) return -1;
	      r = e.length - 1;
	    } else if (r < 0) if (i) r = 0;else return -1;
	    if (typeof t == "string" && (t = a.from(t, n)), a.isBuffer(t)) return t.length === 0 ? -1 : Xt(e, t, r, n, i);
	    if (typeof t == "number") return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : Xt(e, [t], r, n, i);
	    throw new TypeError("val must be string, number or Buffer");
	  }
	  function Xt(e, t, r, n, i) {
	    let o = 1,
	      s = e.length,
	      u = t.length;
	    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
	      if (e.length < 2 || t.length < 2) return -1;
	      o = 2, s /= 2, u /= 2, r /= 2;
	    }
	    function h(f, c) {
	      return o === 1 ? f[c] : f.readUInt16BE(c * o);
	    }
	    let p;
	    if (i) {
	      let f = -1;
	      for (p = r; p < s; p++) if (h(e, p) === h(t, f === -1 ? 0 : p - f)) {
	        if (f === -1 && (f = p), p - f + 1 === u) return f * o;
	      } else f !== -1 && (p -= p - f), f = -1;
	    } else for (r + u > s && (r = s - u), p = r; p >= 0; p--) {
	      let f = !0;
	      for (let c = 0; c < u; c++) if (h(e, p + c) !== h(t, c)) {
	        f = !1;
	        break;
	      }
	      if (f) return p;
	    }
	    return -1;
	  }
	  a.prototype.includes = function (t, r, n) {
	    return this.indexOf(t, r, n) !== -1;
	  };
	  a.prototype.indexOf = function (t, r, n) {
	    return nr(this, t, r, n, !0);
	  };
	  a.prototype.lastIndexOf = function (t, r, n) {
	    return nr(this, t, r, n, !1);
	  };
	  function Jr(e, t, r, n) {
	    r = Number(r) || 0;
	    let i = e.length - r;
	    n ? (n = Number(n), n > i && (n = i)) : n = i;
	    let o = t.length;
	    n > o / 2 && (n = o / 2);
	    let s;
	    for (s = 0; s < n; ++s) {
	      let u = parseInt(t.substr(s * 2, 2), 16);
	      if (Ut(u)) return s;
	      e[r + s] = u;
	    }
	    return s;
	  }
	  function Xr(e, t, r, n) {
	    return et(At(t, e.length - r), e, r, n);
	  }
	  function Zr(e, t, r, n) {
	    return et(fe(t), e, r, n);
	  }
	  function Qr(e, t, r, n) {
	    return et(cr(t), e, r, n);
	  }
	  function te(e, t, r, n) {
	    return et(ce(t, e.length - r), e, r, n);
	  }
	  a.prototype.write = function (t, r, n, i) {
	    if (r === void 0) i = "utf8", n = this.length, r = 0;else if (n === void 0 && typeof r == "string") i = r, n = this.length, r = 0;else if (isFinite(r)) r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
	    let o = this.length - r;
	    if ((n === void 0 || n > o) && (n = o), t.length > 0 && (n < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
	    i || (i = "utf8");
	    let s = !1;
	    for (;;) switch (i) {
	      case "hex":
	        return Jr(this, t, r, n);
	      case "utf8":
	      case "utf-8":
	        return Xr(this, t, r, n);
	      case "ascii":
	      case "latin1":
	      case "binary":
	        return Zr(this, t, r, n);
	      case "base64":
	        return Qr(this, t, r, n);
	      case "ucs2":
	      case "ucs-2":
	      case "utf16le":
	      case "utf-16le":
	        return te(this, t, r, n);
	      default:
	        if (s) throw new TypeError("Unknown encoding: " + i);
	        i = ("" + i).toLowerCase(), s = !0;
	    }
	  };
	  a.prototype.toJSON = function () {
	    return {
	      type: "Buffer",
	      data: Array.prototype.slice.call(this._arr || this, 0)
	    };
	  };
	  function re(e, t, r) {
	    return t === 0 && r === e.length ? Bt.fromByteArray(e) : Bt.fromByteArray(e.slice(t, r));
	  }
	  function ir(e, t, r) {
	    r = Math.min(e.length, r);
	    let n = [],
	      i = t;
	    for (; i < r;) {
	      let o = e[i],
	        s = null,
	        u = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
	      if (i + u <= r) {
	        let h, p, f, c;
	        switch (u) {
	          case 1:
	            o < 128 && (s = o);
	            break;
	          case 2:
	            h = e[i + 1], (h & 192) === 128 && (c = (o & 31) << 6 | h & 63, c > 127 && (s = c));
	            break;
	          case 3:
	            h = e[i + 1], p = e[i + 2], (h & 192) === 128 && (p & 192) === 128 && (c = (o & 15) << 12 | (h & 63) << 6 | p & 63, c > 2047 && (c < 55296 || c > 57343) && (s = c));
	            break;
	          case 4:
	            h = e[i + 1], p = e[i + 2], f = e[i + 3], (h & 192) === 128 && (p & 192) === 128 && (f & 192) === 128 && (c = (o & 15) << 18 | (h & 63) << 12 | (p & 63) << 6 | f & 63, c > 65535 && c < 1114112 && (s = c));
	        }
	      }
	      s === null ? (s = 65533, u = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), i += u;
	    }
	    return ee(n);
	  }
	  var Zt = 4096;
	  function ee(e) {
	    let t = e.length;
	    if (t <= Zt) return String.fromCharCode.apply(String, e);
	    let r = "",
	      n = 0;
	    for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += Zt));
	    return r;
	  }
	  function ne(e, t, r) {
	    let n = "";
	    r = Math.min(e.length, r);
	    for (let i = t; i < r; ++i) n += String.fromCharCode(e[i] & 127);
	    return n;
	  }
	  function ie(e, t, r) {
	    let n = "";
	    r = Math.min(e.length, r);
	    for (let i = t; i < r; ++i) n += String.fromCharCode(e[i]);
	    return n;
	  }
	  function oe(e, t, r) {
	    let n = e.length;
	    (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
	    let i = "";
	    for (let o = t; o < r; ++o) i += pe[e[o]];
	    return i;
	  }
	  function se(e, t, r) {
	    let n = e.slice(t, r),
	      i = "";
	    for (let o = 0; o < n.length - 1; o += 2) i += String.fromCharCode(n[o] + n[o + 1] * 256);
	    return i;
	  }
	  a.prototype.slice = function (t, r) {
	    let n = this.length;
	    t = ~~t, r = r === void 0 ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
	    let i = this.subarray(t, r);
	    return Object.setPrototypeOf(i, a.prototype), i;
	  };
	  function y(e, t, r) {
	    if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
	    if (e + t > r) throw new RangeError("Trying to access beyond buffer length");
	  }
	  a.prototype.readUintLE = a.prototype.readUIntLE = function (t, r, n) {
	    t = t >>> 0, r = r >>> 0, n || y(t, r, this.length);
	    let i = this[t],
	      o = 1,
	      s = 0;
	    for (; ++s < r && (o *= 256);) i += this[t + s] * o;
	    return i;
	  };
	  a.prototype.readUintBE = a.prototype.readUIntBE = function (t, r, n) {
	    t = t >>> 0, r = r >>> 0, n || y(t, r, this.length);
	    let i = this[t + --r],
	      o = 1;
	    for (; r > 0 && (o *= 256);) i += this[t + --r] * o;
	    return i;
	  };
	  a.prototype.readUint8 = a.prototype.readUInt8 = function (t, r) {
	    return t = t >>> 0, r || y(t, 1, this.length), this[t];
	  };
	  a.prototype.readUint16LE = a.prototype.readUInt16LE = function (t, r) {
	    return t = t >>> 0, r || y(t, 2, this.length), this[t] | this[t + 1] << 8;
	  };
	  a.prototype.readUint16BE = a.prototype.readUInt16BE = function (t, r) {
	    return t = t >>> 0, r || y(t, 2, this.length), this[t] << 8 | this[t + 1];
	  };
	  a.prototype.readUint32LE = a.prototype.readUInt32LE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
	  };
	  a.prototype.readUint32BE = a.prototype.readUInt32BE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
	  };
	  a.prototype.readBigUInt64LE = L(function (t) {
	    t = t >>> 0, j(t, "offset");
	    let r = this[t],
	      n = this[t + 7];
	    (r === void 0 || n === void 0) && W(t, this.length - 8);
	    let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24,
	      o = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
	    return BigInt(i) + (BigInt(o) << BigInt(32));
	  });
	  a.prototype.readBigUInt64BE = L(function (t) {
	    t = t >>> 0, j(t, "offset");
	    let r = this[t],
	      n = this[t + 7];
	    (r === void 0 || n === void 0) && W(t, this.length - 8);
	    let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t],
	      o = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
	    return (BigInt(i) << BigInt(32)) + BigInt(o);
	  });
	  a.prototype.readIntLE = function (t, r, n) {
	    t = t >>> 0, r = r >>> 0, n || y(t, r, this.length);
	    let i = this[t],
	      o = 1,
	      s = 0;
	    for (; ++s < r && (o *= 256);) i += this[t + s] * o;
	    return o *= 128, i >= o && (i -= Math.pow(2, 8 * r)), i;
	  };
	  a.prototype.readIntBE = function (t, r, n) {
	    t = t >>> 0, r = r >>> 0, n || y(t, r, this.length);
	    let i = r,
	      o = 1,
	      s = this[t + --i];
	    for (; i > 0 && (o *= 256);) s += this[t + --i] * o;
	    return o *= 128, s >= o && (s -= Math.pow(2, 8 * r)), s;
	  };
	  a.prototype.readInt8 = function (t, r) {
	    return t = t >>> 0, r || y(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
	  };
	  a.prototype.readInt16LE = function (t, r) {
	    t = t >>> 0, r || y(t, 2, this.length);
	    let n = this[t] | this[t + 1] << 8;
	    return n & 32768 ? n | 4294901760 : n;
	  };
	  a.prototype.readInt16BE = function (t, r) {
	    t = t >>> 0, r || y(t, 2, this.length);
	    let n = this[t + 1] | this[t] << 8;
	    return n & 32768 ? n | 4294901760 : n;
	  };
	  a.prototype.readInt32LE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
	  };
	  a.prototype.readInt32BE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
	  };
	  a.prototype.readBigInt64LE = L(function (t) {
	    t = t >>> 0, j(t, "offset");
	    let r = this[t],
	      n = this[t + 7];
	    (r === void 0 || n === void 0) && W(t, this.length - 8);
	    let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
	    return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
	  });
	  a.prototype.readBigInt64BE = L(function (t) {
	    t = t >>> 0, j(t, "offset");
	    let r = this[t],
	      n = this[t + 7];
	    (r === void 0 || n === void 0) && W(t, this.length - 8);
	    let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
	    return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
	  });
	  a.prototype.readFloatLE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), H.read(this, t, !0, 23, 4);
	  };
	  a.prototype.readFloatBE = function (t, r) {
	    return t = t >>> 0, r || y(t, 4, this.length), H.read(this, t, !1, 23, 4);
	  };
	  a.prototype.readDoubleLE = function (t, r) {
	    return t = t >>> 0, r || y(t, 8, this.length), H.read(this, t, !0, 52, 8);
	  };
	  a.prototype.readDoubleBE = function (t, r) {
	    return t = t >>> 0, r || y(t, 8, this.length), H.read(this, t, !1, 52, 8);
	  };
	  function d(e, t, r, n, i, o) {
	    if (!a.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
	    if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
	    if (r + n > e.length) throw new RangeError("Index out of range");
	  }
	  a.prototype.writeUintLE = a.prototype.writeUIntLE = function (t, r, n, i) {
	    if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
	      let u = Math.pow(2, 8 * n) - 1;
	      d(this, t, r, n, u, 0);
	    }
	    let o = 1,
	      s = 0;
	    for (this[r] = t & 255; ++s < n && (o *= 256);) this[r + s] = t / o & 255;
	    return r + n;
	  };
	  a.prototype.writeUintBE = a.prototype.writeUIntBE = function (t, r, n, i) {
	    if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
	      let u = Math.pow(2, 8 * n) - 1;
	      d(this, t, r, n, u, 0);
	    }
	    let o = n - 1,
	      s = 1;
	    for (this[r + o] = t & 255; --o >= 0 && (s *= 256);) this[r + o] = t / s & 255;
	    return r + n;
	  };
	  a.prototype.writeUint8 = a.prototype.writeUInt8 = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
	  };
	  a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
	  };
	  a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
	  };
	  a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
	  };
	  a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
	  };
	  function or(e, t, r, n, i) {
	    fr(t, n, i, e, r, 7);
	    let o = Number(t & BigInt(4294967295));
	    e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o, o = o >> 8, e[r++] = o;
	    let s = Number(t >> BigInt(32) & BigInt(4294967295));
	    return e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s, s = s >> 8, e[r++] = s, r;
	  }
	  function sr(e, t, r, n, i) {
	    fr(t, n, i, e, r, 7);
	    let o = Number(t & BigInt(4294967295));
	    e[r + 7] = o, o = o >> 8, e[r + 6] = o, o = o >> 8, e[r + 5] = o, o = o >> 8, e[r + 4] = o;
	    let s = Number(t >> BigInt(32) & BigInt(4294967295));
	    return e[r + 3] = s, s = s >> 8, e[r + 2] = s, s = s >> 8, e[r + 1] = s, s = s >> 8, e[r] = s, r + 8;
	  }
	  a.prototype.writeBigUInt64LE = L(function (t, r = 0) {
	    return or(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
	  });
	  a.prototype.writeBigUInt64BE = L(function (t, r = 0) {
	    return sr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
	  });
	  a.prototype.writeIntLE = function (t, r, n, i) {
	    if (t = +t, r = r >>> 0, !i) {
	      let h = Math.pow(2, 8 * n - 1);
	      d(this, t, r, n, h - 1, -h);
	    }
	    let o = 0,
	      s = 1,
	      u = 0;
	    for (this[r] = t & 255; ++o < n && (s *= 256);) t < 0 && u === 0 && this[r + o - 1] !== 0 && (u = 1), this[r + o] = (t / s >> 0) - u & 255;
	    return r + n;
	  };
	  a.prototype.writeIntBE = function (t, r, n, i) {
	    if (t = +t, r = r >>> 0, !i) {
	      let h = Math.pow(2, 8 * n - 1);
	      d(this, t, r, n, h - 1, -h);
	    }
	    let o = n - 1,
	      s = 1,
	      u = 0;
	    for (this[r + o] = t & 255; --o >= 0 && (s *= 256);) t < 0 && u === 0 && this[r + o + 1] !== 0 && (u = 1), this[r + o] = (t / s >> 0) - u & 255;
	    return r + n;
	  };
	  a.prototype.writeInt8 = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
	  };
	  a.prototype.writeInt16LE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
	  };
	  a.prototype.writeInt16BE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
	  };
	  a.prototype.writeInt32LE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
	  };
	  a.prototype.writeInt32BE = function (t, r, n) {
	    return t = +t, r = r >>> 0, n || d(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
	  };
	  a.prototype.writeBigInt64LE = L(function (t, r = 0) {
	    return or(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
	  });
	  a.prototype.writeBigInt64BE = L(function (t, r = 0) {
	    return sr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
	  });
	  function ar(e, t, r, n, i, o) {
	    if (r + n > e.length) throw new RangeError("Index out of range");
	    if (r < 0) throw new RangeError("Index out of range");
	  }
	  function ur(e, t, r, n, i) {
	    return t = +t, r = r >>> 0, i || ar(e, t, r, 4), H.write(e, t, r, n, 23, 4), r + 4;
	  }
	  a.prototype.writeFloatLE = function (t, r, n) {
	    return ur(this, t, r, !0, n);
	  };
	  a.prototype.writeFloatBE = function (t, r, n) {
	    return ur(this, t, r, !1, n);
	  };
	  function hr(e, t, r, n, i) {
	    return t = +t, r = r >>> 0, i || ar(e, t, r, 8), H.write(e, t, r, n, 52, 8), r + 8;
	  }
	  a.prototype.writeDoubleLE = function (t, r, n) {
	    return hr(this, t, r, !0, n);
	  };
	  a.prototype.writeDoubleBE = function (t, r, n) {
	    return hr(this, t, r, !1, n);
	  };
	  a.prototype.copy = function (t, r, n, i) {
	    if (!a.isBuffer(t)) throw new TypeError("argument should be a Buffer");
	    if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0) return 0;
	    if (r < 0) throw new RangeError("targetStart out of bounds");
	    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
	    if (i < 0) throw new RangeError("sourceEnd out of bounds");
	    i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
	    let o = i - n;
	    return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o;
	  };
	  a.prototype.fill = function (t, r, n, i) {
	    if (typeof t == "string") {
	      if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
	      if (typeof i == "string" && !a.isEncoding(i)) throw new TypeError("Unknown encoding: " + i);
	      if (t.length === 1) {
	        let s = t.charCodeAt(0);
	        (i === "utf8" && s < 128 || i === "latin1") && (t = s);
	      }
	    } else typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
	    if (r < 0 || this.length < r || this.length < n) throw new RangeError("Out of range index");
	    if (n <= r) return this;
	    r = r >>> 0, n = n === void 0 ? this.length : n >>> 0, t || (t = 0);
	    let o;
	    if (typeof t == "number") for (o = r; o < n; ++o) this[o] = t;else {
	      let s = a.isBuffer(t) ? t : a.from(t, i),
	        u = s.length;
	      if (u === 0) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
	      for (o = 0; o < n - r; ++o) this[o + r] = s[o % u];
	    }
	    return this;
	  };
	  var K = {};
	  function St(e, t, r) {
	    K[e] = class extends r {
	      constructor() {
	        super(), Object.defineProperty(this, "message", {
	          value: t.apply(this, arguments),
	          writable: !0,
	          configurable: !0
	        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
	      }
	      get code() {
	        return e;
	      }
	      set code(i) {
	        Object.defineProperty(this, "code", {
	          configurable: !0,
	          enumerable: !0,
	          value: i,
	          writable: !0
	        });
	      }
	      toString() {
	        return `${this.name} [${e}]: ${this.message}`;
	      }
	    };
	  }
	  St("ERR_BUFFER_OUT_OF_BOUNDS", function (e) {
	    return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
	  }, RangeError);
	  St("ERR_INVALID_ARG_TYPE", function (e, t) {
	    return `The "${e}" argument must be of type number. Received type ${typeof t}`;
	  }, TypeError);
	  St("ERR_OUT_OF_RANGE", function (e, t, r) {
	    let n = `The value of "${e}" is out of range.`,
	      i = r;
	    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Qt(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Qt(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
	  }, RangeError);
	  function Qt(e) {
	    let t = "",
	      r = e.length,
	      n = e[0] === "-" ? 1 : 0;
	    for (; r >= n + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
	    return `${e.slice(0, r)}${t}`;
	  }
	  function ae(e, t, r) {
	    j(t, "offset"), (e[t] === void 0 || e[t + r] === void 0) && W(t, e.length - (r + 1));
	  }
	  function fr(e, t, r, n, i, o) {
	    if (e > r || e < t) {
	      let s = typeof t == "bigint" ? "n" : "",
	        u;
	      throw o > 3 ? t === 0 || t === BigInt(0) ? u = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : u = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : u = `>= ${t}${s} and <= ${r}${s}`, new K.ERR_OUT_OF_RANGE("value", u, e);
	    }
	    ae(n, i, o);
	  }
	  function j(e, t) {
	    if (typeof e != "number") throw new K.ERR_INVALID_ARG_TYPE(t, "number", e);
	  }
	  function W(e, t, r) {
	    throw Math.floor(e) !== e ? (j(e, r), new K.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new K.ERR_BUFFER_OUT_OF_BOUNDS() : new K.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
	  }
	  var ue = /[^+/0-9A-Za-z-_]/g;
	  function he(e) {
	    if (e = e.split("=")[0], e = e.trim().replace(ue, ""), e.length < 2) return "";
	    for (; e.length % 4 !== 0;) e = e + "=";
	    return e;
	  }
	  function At(e, t) {
	    t = t || 1 / 0;
	    let r,
	      n = e.length,
	      i = null,
	      o = [];
	    for (let s = 0; s < n; ++s) {
	      if (r = e.charCodeAt(s), r > 55295 && r < 57344) {
	        if (!i) {
	          if (r > 56319) {
	            (t -= 3) > -1 && o.push(239, 191, 189);
	            continue;
	          } else if (s + 1 === n) {
	            (t -= 3) > -1 && o.push(239, 191, 189);
	            continue;
	          }
	          i = r;
	          continue;
	        }
	        if (r < 56320) {
	          (t -= 3) > -1 && o.push(239, 191, 189), i = r;
	          continue;
	        }
	        r = (i - 55296 << 10 | r - 56320) + 65536;
	      } else i && (t -= 3) > -1 && o.push(239, 191, 189);
	      if (i = null, r < 128) {
	        if ((t -= 1) < 0) break;
	        o.push(r);
	      } else if (r < 2048) {
	        if ((t -= 2) < 0) break;
	        o.push(r >> 6 | 192, r & 63 | 128);
	      } else if (r < 65536) {
	        if ((t -= 3) < 0) break;
	        o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
	      } else if (r < 1114112) {
	        if ((t -= 4) < 0) break;
	        o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
	      } else throw new Error("Invalid code point");
	    }
	    return o;
	  }
	  function fe(e) {
	    let t = [];
	    for (let r = 0; r < e.length; ++r) t.push(e.charCodeAt(r) & 255);
	    return t;
	  }
	  function ce(e, t) {
	    let r,
	      n,
	      i,
	      o = [];
	    for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n);
	    return o;
	  }
	  function cr(e) {
	    return Bt.toByteArray(he(e));
	  }
	  function et(e, t, r, n) {
	    let i;
	    for (i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
	    return i;
	  }
	  function A(e, t) {
	    return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
	  }
	  function Ut(e) {
	    return e !== e;
	  }
	  var pe = function () {
	    let e = "0123456789abcdef",
	      t = new Array(256);
	    for (let r = 0; r < 16; ++r) {
	      let n = r * 16;
	      for (let i = 0; i < 16; ++i) t[n + i] = e[r] + e[i];
	    }
	    return t;
	  }();
	  function L(e) {
	    return typeof BigInt > "u" ? le : e;
	  }
	  function le() {
	    throw new Error("BigInt not supported");
	  }
	});
	var pr$1 = T((Je, Ft) => {
	  typeof window < "u" ? (window.global = window, global.fetch = window.fetch, Ft.exports = {
	    Buffer: nt$1().Buffer,
	    Crypto: window.crypto
	  }) : Ft.exports = {
	    Buffer: nt$1().Buffer,
	    Crypto: crypto
	  };
	});
	var Lt$1 = {};
	Ar$1(Lt$1, {
	  AVSCTap: () => $$1,
	  ArweaveSigner: () => N$1,
	  DataItem: () => _$1,
	  MAX_TAG_BYTES: () => tt$1,
	  MIN_BINARY_SIZE: () => gr$1,
	  SIG_CONFIG: () => P$1,
	  SignatureConfig: () => B$1,
	  Signer: () => ot$1,
	  createData: () => ge$1,
	  deserializeTags: () => Q$1,
	  indexToType: () => wt$1,
	  serializeTags: () => dt$1,
	  tagsExceedLimit: () => jr$1
	});
	var ot$1 = class {
	  signer;
	  publicKey;
	  signatureType;
	  signatureLength;
	  ownerLength;
	  pem;
	  static verify(t, r, n, i) {
	    throw new Error("You must implement verify method on child");
	  }
	};
	var vt$1 = C$1(z$1(), 1);
	var w$1 = C$1(pt$1(), 1);
	async function X$1(e) {
	  if (Array.isArray(e)) {
	    let i = (0, w$1.concatBuffers)([(0, w$1.stringToBuffer)("list"), (0, w$1.stringToBuffer)(e.length.toString())]);
	    return await Gt$1(e, await x$1().hash(i, "SHA-384"));
	  }
	  let t = e,
	    r = (0, w$1.concatBuffers)([(0, w$1.stringToBuffer)("blob"), (0, w$1.stringToBuffer)(t.byteLength.toString())]),
	    n = (0, w$1.concatBuffers)([await x$1().hash(r, "SHA-384"), await x$1().hash(t, "SHA-384")]);
	  return await x$1().hash(n, "SHA-384");
	}
	async function Gt$1(e, t) {
	  if (e.length < 1) return t;
	  let r = (0, w$1.concatBuffers)([t, await X$1(e[0])]),
	    n = await x$1().hash(r, "SHA-384");
	  return await Gt$1(e.slice(1), n);
	}
	var Z$1 = C$1(Yt$1(), 1),
	  $r$1 = Z$1.default.default ? Z$1.default.default : Z$1.default,
	  yt = class extends $r$1 {
	    getPublicKey(t) {
	      throw new Error("Unimplemented");
	    }
	  },
	  Kr$1;
	function x$1() {
	  return Kr$1 ??= new yt();
	}
	var B$1;
	(function (e) {
	  e[e.ARWEAVE = 1] = "ARWEAVE", e[e.ED25519 = 2] = "ED25519", e[e.ETHEREUM = 3] = "ETHEREUM", e[e.SOLANA = 4] = "SOLANA", e[e.INJECTEDAPTOS = 5] = "INJECTEDAPTOS", e[e.MULTIAPTOS = 6] = "MULTIAPTOS", e[e.TYPEDETHEREUM = 7] = "TYPEDETHEREUM";
	})(B$1 || (B$1 = {}));
	var P$1 = {
	  [B$1.ARWEAVE]: {
	    sigLength: 512,
	    pubLength: 512,
	    sigName: "arweave"
	  },
	  [B$1.ED25519]: {
	    sigLength: 64,
	    pubLength: 32,
	    sigName: "ed25519"
	  },
	  [B$1.ETHEREUM]: {
	    sigLength: 65,
	    pubLength: 65,
	    sigName: "ethereum"
	  },
	  [B$1.SOLANA]: {
	    sigLength: 64,
	    pubLength: 32,
	    sigName: "solana"
	  },
	  [B$1.INJECTEDAPTOS]: {
	    sigLength: 64,
	    pubLength: 32,
	    sigName: "injectedAptos"
	  },
	  [B$1.MULTIAPTOS]: {
	    sigLength: 64 * 32 + 4,
	    pubLength: 32 * 32 + 1,
	    sigName: "multiAptos"
	  },
	  [B$1.TYPEDETHEREUM]: {
	    sigLength: 65,
	    pubLength: 42,
	    sigName: "typedEthereum"
	  }
	};
	var N$1 = class {
	  signatureType = 1;
	  ownerLength = P$1[1].pubLength;
	  signatureLength = P$1[1].sigLength;
	  jwk;
	  pk;
	  constructor(t) {
	    this.pk = t.n, this.jwk = t;
	  }
	  get publicKey() {
	    return vt$1.default.toBuffer(this.pk);
	  }
	  sign(t) {
	    return x$1().sign(this.jwk, t);
	  }
	  static async verify(t, r, n) {
	    return await x$1().verify(t, r, n);
	  }
	};
	var wt$1 = {
	  1: N$1
	};
	var E$1 = C$1(z$1(), 1);
	async function v(e) {
	  return X$1([(0, w$1.stringToBuffer)("dataitem"), (0, w$1.stringToBuffer)("1"), (0, w$1.stringToBuffer)(e.signatureType.toString()), e.rawOwner, e.rawTarget, e.rawAnchor, e.rawTags, e.rawData]);
	}
	async function Hr$1(e, t) {
	  let r = await v(e),
	    n = await t.sign(r),
	    i = await x$1().hash(n);
	  return {
	    signature: bufferExports.Buffer.from(n),
	    id: bufferExports.Buffer.from(i)
	  };
	}
	async function Wt$1(e, t) {
	  let {
	    signature: r,
	    id: n
	  } = await Hr$1(e, t);
	  return e.getRaw().set(r, 2), n;
	}
	var $$1 = class {
	  buf;
	  pos;
	  constructor(t = bufferExports.Buffer.alloc(tt$1), r = 0) {
	    this.buf = t, this.pos = r;
	  }
	  writeTags(t) {
	    if (!Array.isArray(t)) throw new Error("input must be array");
	    let r = t.length,
	      n;
	    if (r) for (this.writeLong(r), n = 0; n < r; n++) {
	      let i = t[n];
	      if (i?.name === void 0 || i?.value === void 0) throw new Error(`Invalid tag format for ${i}, expected {name:string, value: string}`);
	      this.writeString(i.name), this.writeString(i.value);
	    }
	    this.writeLong(0);
	  }
	  toBuffer() {
	    let t = bufferExports.Buffer.alloc(this.pos);
	    if (this.pos > this.buf.length) throw new Error(`Too many tag bytes (${this.pos} > ${this.buf.length})`);
	    return this.buf.copy(t, 0, 0, this.pos), t;
	  }
	  tagsExceedLimit() {
	    return this.pos > this.buf.length;
	  }
	  writeLong(t) {
	    let r = this.buf,
	      n,
	      i;
	    if (t >= -1073741824 && t < 1073741824) {
	      i = t >= 0 ? t << 1 : ~t << 1 | 1;
	      do r[this.pos] = i & 127, i >>= 7; while (i && (r[this.pos++] |= 128));
	    } else {
	      n = t >= 0 ? t * 2 : -t * 2 - 1;
	      do r[this.pos] = n & 127, n /= 128; while (n >= 1 && (r[this.pos++] |= 128));
	    }
	    this.pos++, this.buf = r;
	  }
	  writeString(t) {
	    let r = bufferExports.Buffer.byteLength(t),
	      n = this.buf;
	    this.writeLong(r);
	    let i = this.pos;
	    if (this.pos += r, !(this.pos > n.length)) {
	      if (r > 64) this.buf.write(t, this.pos - r, r, "utf8");else {
	        let o, s, u, h;
	        for (o = 0, s = r; o < s; o++) u = t.charCodeAt(o), u < 128 ? n[i++] = u : u < 2048 ? (n[i++] = u >> 6 | 192, n[i++] = u & 63 | 128) : (u & 64512) === 55296 && ((h = t.charCodeAt(o + 1)) & 64512) === 56320 ? (u = 65536 + ((u & 1023) << 10) + (h & 1023), o++, n[i++] = u >> 18 | 240, n[i++] = u >> 12 & 63 | 128, n[i++] = u >> 6 & 63 | 128, n[i++] = u & 63 | 128) : (n[i++] = u >> 12 | 224, n[i++] = u >> 6 & 63 | 128, n[i++] = u & 63 | 128);
	      }
	      this.buf = n;
	    }
	  }
	  readLong() {
	    let t = 0,
	      r = 0,
	      n = this.buf,
	      i,
	      o,
	      s,
	      u;
	    do i = n[this.pos++], o = i & 128, t |= (i & 127) << r, r += 7; while (o && r < 28);
	    if (o) {
	      s = t, u = 268435456;
	      do i = n[this.pos++], s += (i & 127) * u, u *= 128; while (i & 128);
	      return (s % 2 ? -(s + 1) : s) / 2;
	    }
	    return t >> 1 ^ -(t & 1);
	  }
	  skipLong() {
	    let t = this.buf;
	    for (; t[this.pos++] & 128;);
	  }
	  readTags() {
	    let t = [],
	      r;
	    for (; r = this.readLong();) for (r < 0 && (r = -r, this.skipLong()); r--;) {
	      let n = this.readString(),
	        i = this.readString();
	      t.push({
	        name: n,
	        value: i
	      });
	    }
	    return t;
	  }
	  readString() {
	    let t = this.readLong(),
	      r = this.pos,
	      n = this.buf;
	    if (this.pos += t, !(this.pos > n.length)) return this.buf.slice(r, r + t).toString();
	  }
	};
	function dt$1(e) {
	  let t = new $$1();
	  return t.writeTags(e), t.toBuffer();
	}
	function jr$1(e) {
	  let t = new $$1();
	  return t.writeTags(e), t.tagsExceedLimit();
	}
	function Q$1(e) {
	  return new $$1(e).readTags();
	}
	function I$1(e) {
	  let t = 0;
	  for (let r = e.length - 1; r >= 0; r--) t = t * 256 + e[r];
	  return t;
	}
	function Vt$1(e) {
	  if (e > (2 ^ 32 - 1)) throw new Error("Short too long");
	  let t = [0, 0];
	  for (let r = 0; r < t.length; r++) {
	    let n = e & 255;
	    t[r] = n, e = (e - n) / 256;
	  }
	  return Uint8Array.from(t);
	}
	function xt(e) {
	  let t = [0, 0, 0, 0, 0, 0, 0, 0];
	  for (let r = 0; r < t.length; r++) {
	    let n = e & 255;
	    t[r] = n, e = (e - n) / 256;
	  }
	  return Uint8Array.from(t);
	}
	var lr$1 = C$1(pr$1(), 1),
	  M = C$1(nt$1(), 1),
	  tt$1 = 4096,
	  gr$1 = 80,
	  _$1 = class {
	    binary;
	    _id;
	    constructor(t) {
	      this.binary = t;
	    }
	    static isDataItem(t) {
	      return t.binary !== void 0;
	    }
	    get signatureType() {
	      let t = I$1(this.binary.subarray(0, 2));
	      if (B$1?.[t] !== void 0) return t;
	      throw new Error("Unknown signature type: " + t);
	    }
	    async isValid() {
	      return _$1.verify(this.binary);
	    }
	    get id() {
	      return (async () => E$1.default.encode(await this.rawId))();
	    }
	    set id(t) {
	      this._id = E$1.default.toBuffer(t);
	    }
	    get rawId() {
	      return (async () => M.Buffer.from(await lr$1.Crypto.subtle.digest("SHA-256", this.rawSignature)))();
	    }
	    set rawId(t) {
	      this._id = t;
	    }
	    get rawSignature() {
	      return this.binary.subarray(2, 2 + this.signatureLength);
	    }
	    get signature() {
	      return E$1.default.encode(this.rawSignature);
	    }
	    set rawOwner(t) {
	      if (t.byteLength != this.ownerLength) throw new Error(`Expected raw owner (pubkey) to be ${this.ownerLength} bytes, got ${t.byteLength} bytes.`);
	      this.binary.set(t, 2 + this.signatureLength);
	    }
	    get rawOwner() {
	      return this.binary.subarray(2 + this.signatureLength, 2 + this.signatureLength + this.ownerLength);
	    }
	    get signatureLength() {
	      return P$1[this.signatureType].sigLength;
	    }
	    get owner() {
	      return E$1.default.encode(this.rawOwner);
	    }
	    get ownerLength() {
	      return P$1[this.signatureType].pubLength;
	    }
	    get rawTarget() {
	      let t = this.getTargetStart();
	      return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M.Buffer.alloc(0);
	    }
	    get target() {
	      return E$1.default.encode(this.rawTarget);
	    }
	    get rawAnchor() {
	      let t = this.getAnchorStart();
	      return this.binary[t] == 1 ? this.binary.subarray(t + 1, t + 33) : M.Buffer.alloc(0);
	    }
	    get anchor() {
	      return this.rawAnchor.toString();
	    }
	    get rawTags() {
	      let t = this.getTagsStart(),
	        r = I$1(this.binary.subarray(t + 8, t + 16));
	      return this.binary.subarray(t + 16, t + 16 + r);
	    }
	    get tags() {
	      let t = this.getTagsStart();
	      if (I$1(this.binary.subarray(t, t + 8)) == 0) return [];
	      let n = I$1(this.binary.subarray(t + 8, t + 16));
	      return Q$1(M.Buffer.from(this.binary.subarray(t + 16, t + 16 + n)));
	    }
	    get tagsB64Url() {
	      return this.tags.map(r => ({
	        name: E$1.default.encode(r.name),
	        value: E$1.default.encode(r.value)
	      }));
	    }
	    getStartOfData() {
	      let t = this.getTagsStart(),
	        r = this.binary.subarray(t + 8, t + 16),
	        n = I$1(r);
	      return t + 16 + n;
	    }
	    get rawData() {
	      let t = this.getTagsStart(),
	        r = this.binary.subarray(t + 8, t + 16),
	        n = I$1(r),
	        i = t + 16 + n;
	      return this.binary.subarray(i, this.binary.length);
	    }
	    get data() {
	      return E$1.default.encode(this.rawData);
	    }
	    getRaw() {
	      return this.binary;
	    }
	    async sign(t) {
	      return this._id = await Wt$1(this, t), this.rawId;
	    }
	    async setSignature(t) {
	      this.binary.set(t, 2), this._id = M.Buffer.from(await x$1().hash(t));
	    }
	    isSigned() {
	      return (this._id?.length ?? 0) > 0;
	    }
	    toJSON() {
	      return {
	        signature: this.signature,
	        owner: this.owner,
	        target: this.target,
	        tags: this.tags.map(t => ({
	          name: E$1.default.encode(t.name),
	          value: E$1.default.encode(t.value)
	        })),
	        data: this.data
	      };
	    }
	    static async verify(t) {
	      if (t.byteLength < gr$1) return !1;
	      let r = new _$1(t),
	        n = r.signatureType,
	        i = r.getTagsStart(),
	        o = I$1(t.subarray(i, i + 8)),
	        s = t.subarray(i + 8, i + 16),
	        u = I$1(s);
	      if (u > tt$1) return !1;
	      if (o > 0) try {
	        if (Q$1(M.Buffer.from(t.subarray(i + 16, i + 16 + u))).length !== o) return !1;
	      } catch {
	        return !1;
	      }
	      let h = wt$1[n],
	        p = await v(r);
	      return await h.verify(r.rawOwner, p, r.rawSignature);
	    }
	    async getSignatureData() {
	      return v(this);
	    }
	    getTagsStart() {
	      let t = this.getTargetStart(),
	        r = this.binary[t] == 1,
	        n = t + (r ? 33 : 1),
	        i = this.binary[n] == 1;
	      return n += i ? 33 : 1, n;
	    }
	    getTargetStart() {
	      return 2 + this.signatureLength + this.ownerLength;
	    }
	    getAnchorStart() {
	      let t = this.getTargetStart() + 1,
	        r = this.binary[this.getTargetStart()] == 1;
	      return t += r ? 32 : 0, t;
	    }
	  };
	var yr$1 = C$1(z$1(), 1);
	function ge$1(e, t, r) {
	  let n = t.publicKey,
	    i = r?.target ? yr$1.default.toBuffer(r.target) : null,
	    o = 1 + (i?.byteLength ?? 0),
	    s = r?.anchor ? bufferExports.Buffer.from(r.anchor) : null,
	    u = 1 + (s?.byteLength ?? 0),
	    h = (r?.tags?.length ?? 0) > 0 ? dt$1(r.tags) : null,
	    p = 16 + (h ? h.byteLength : 0),
	    f = bufferExports.Buffer.from(e),
	    c = f.byteLength,
	    U = 2 + t.signatureLength + t.ownerLength + o + u + p + c,
	    l = bufferExports.Buffer.alloc(U);
	  if (l.set(Vt$1(t.signatureType), 0), l.set(new Uint8Array(t.signatureLength).fill(0), 2), n.byteLength !== t.ownerLength) throw new Error(`Owner must be ${t.ownerLength} bytes, but was incorrectly ${n.byteLength}`);
	  l.set(n, 2 + t.signatureLength);
	  let R = 2 + t.signatureLength + t.ownerLength;
	  if (l[R] = i ? 1 : 0, i) {
	    if (i.byteLength !== 32) throw new Error(`Target must be 32 bytes but was incorrectly ${i.byteLength}`);
	    l.set(i, R + 1);
	  }
	  let G = R + o,
	    Y = G + 1;
	  if (l[G] = s ? 1 : 0, s) {
	    if (Y += s.byteLength, s.byteLength !== 32) throw new Error("Anchor must be 32 bytes");
	    l.set(s, G + 1);
	  }
	  l.set(xt(r?.tags?.length ?? 0), Y);
	  let wr = xt(h?.byteLength ?? 0);
	  l.set(wr, Y + 8), h && l.set(h, Y + 16);
	  let dr = Y + p;
	  return l.set(f, dr), new _$1(l);
	}
	var _t$1 = {
	  ...Lt$1
	};
	globalThis.arbundles ??= _t$1;
	/*! Bundled license information:

	ieee754/index.js:
	  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

	buffer/index.js:
	  (*!
	   * The buffer module from node.js, for the browser.
	   *
	   * @author   Feross Aboukhadijeh <https://feross.org>
	   * @license  MIT
	   *)
	*/

	var web = {};

	var common = {};

	var ar$1 = {};

	var bignumber$1 = {exports: {}};

	var bignumber = bignumber$1.exports;

	var hasRequiredBignumber;

	function requireBignumber () {
		if (hasRequiredBignumber) return bignumber$1.exports;
		hasRequiredBignumber = 1;
		(function (module) {
			(function (globalObject) {

			  /*
			   *      bignumber.js v9.1.2
			   *      A JavaScript library for arbitrary-precision arithmetic.
			   *      https://github.com/MikeMcl/bignumber.js
			   *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
			   *      MIT Licensed.
			   *
			   *      BigNumber.prototype methods     |  BigNumber methods
			   *                                      |
			   *      absoluteValue            abs    |  clone
			   *      comparedTo                      |  config               set
			   *      decimalPlaces            dp     |      DECIMAL_PLACES
			   *      dividedBy                div    |      ROUNDING_MODE
			   *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
			   *      exponentiatedBy          pow    |      RANGE
			   *      integerValue                    |      CRYPTO
			   *      isEqualTo                eq     |      MODULO_MODE
			   *      isFinite                        |      POW_PRECISION
			   *      isGreaterThan            gt     |      FORMAT
			   *      isGreaterThanOrEqualTo   gte    |      ALPHABET
			   *      isInteger                       |  isBigNumber
			   *      isLessThan               lt     |  maximum              max
			   *      isLessThanOrEqualTo      lte    |  minimum              min
			   *      isNaN                           |  random
			   *      isNegative                      |  sum
			   *      isPositive                      |
			   *      isZero                          |
			   *      minus                           |
			   *      modulo                   mod    |
			   *      multipliedBy             times  |
			   *      negated                         |
			   *      plus                            |
			   *      precision                sd     |
			   *      shiftedBy                       |
			   *      squareRoot               sqrt   |
			   *      toExponential                   |
			   *      toFixed                         |
			   *      toFormat                        |
			   *      toFraction                      |
			   *      toJSON                          |
			   *      toNumber                        |
			   *      toPrecision                     |
			   *      toString                        |
			   *      valueOf                         |
			   *
			   */
			  var BigNumber,
			    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
			    mathceil = Math.ceil,
			    mathfloor = Math.floor,
			    bignumberError = '[BigNumber Error] ',
			    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
			    BASE = 1e14,
			    LOG_BASE = 14,
			    MAX_SAFE_INTEGER = 0x1fffffffffffff,
			    // 2^53 - 1
			    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
			    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
			    SQRT_BASE = 1e7,
			    // EDITABLE
			    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
			    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
			    MAX = 1E9; // 0 to MAX_INT32

			  /*
			   * Create and return a BigNumber constructor.
			   */
			  function clone(configObject) {
			    var div,
			      convertBase,
			      parseNumeric,
			      P = BigNumber.prototype = {
			        constructor: BigNumber,
			        toString: null,
			        valueOf: null
			      },
			      ONE = new BigNumber(1),
			      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------

			      // The default values below must be integers within the inclusive ranges stated.
			      // The values can also be changed at run-time using BigNumber.set.

			      // The maximum number of decimal places for operations involving division.
			      DECIMAL_PLACES = 20,
			      // 0 to MAX

			      // The rounding mode used when rounding to the above decimal places, and when using
			      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
			      // UP         0 Away from zero.
			      // DOWN       1 Towards zero.
			      // CEIL       2 Towards +Infinity.
			      // FLOOR      3 Towards -Infinity.
			      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
			      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
			      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
			      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
			      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
			      ROUNDING_MODE = 4,
			      // 0 to 8

			      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

			      // The exponent value at and beneath which toString returns exponential notation.
			      // Number type: -7
			      TO_EXP_NEG = -7,
			      // 0 to -MAX

			      // The exponent value at and above which toString returns exponential notation.
			      // Number type: 21
			      TO_EXP_POS = 21,
			      // 0 to MAX

			      // RANGE : [MIN_EXP, MAX_EXP]

			      // The minimum exponent value, beneath which underflow to zero occurs.
			      // Number type: -324  (5e-324)
			      MIN_EXP = -1e7,
			      // -1 to -MAX

			      // The maximum exponent value, above which overflow to Infinity occurs.
			      // Number type:  308  (1.7976931348623157e+308)
			      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
			      MAX_EXP = 1e7,
			      // 1 to MAX

			      // Whether to use cryptographically-secure random number generation, if available.
			      CRYPTO = false,
			      // true or false

			      // The modulo mode used when calculating the modulus: a mod n.
			      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
			      // The remainder (r) is calculated as: r = a - n * q.
			      //
			      // UP        0 The remainder is positive if the dividend is negative, else is negative.
			      // DOWN      1 The remainder has the same sign as the dividend.
			      //             This modulo mode is commonly known as 'truncated division' and is
			      //             equivalent to (a % n) in JavaScript.
			      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
			      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
			      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
			      //             The remainder is always positive.
			      //
			      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
			      // modes are commonly used for the modulus operation.
			      // Although the other rounding modes can also be used, they may not give useful results.
			      MODULO_MODE = 1,
			      // 0 to 9

			      // The maximum number of significant digits of the result of the exponentiatedBy operation.
			      // If POW_PRECISION is 0, there will be unlimited significant digits.
			      POW_PRECISION = 0,
			      // 0 to MAX

			      // The format specification used by the BigNumber.prototype.toFormat method.
			      FORMAT = {
			        prefix: '',
			        groupSize: 3,
			        secondaryGroupSize: 0,
			        groupSeparator: ',',
			        decimalSeparator: '.',
			        fractionGroupSize: 0,
			        fractionGroupSeparator: '\xA0',
			        // non-breaking space
			        suffix: ''
			      },
			      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
			      // '-', '.', whitespace, or repeated character.
			      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
			      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
			      alphabetHasNormalDecimalDigits = true;

			    //------------------------------------------------------------------------------------------

			    // CONSTRUCTOR

			    /*
			     * The BigNumber constructor and exported function.
			     * Create and return a new instance of a BigNumber object.
			     *
			     * v {number|string|BigNumber} A numeric value.
			     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
			     */
			    function BigNumber(v, b) {
			      var alphabet,
			        c,
			        caseChanged,
			        e,
			        i,
			        isNum,
			        len,
			        str,
			        x = this;

			      // Enable constructor call without `new`.
			      if (!(x instanceof BigNumber)) return new BigNumber(v, b);
			      if (b == null) {
			        if (v && v._isBigNumber === true) {
			          x.s = v.s;
			          if (!v.c || v.e > MAX_EXP) {
			            x.c = x.e = null;
			          } else if (v.e < MIN_EXP) {
			            x.c = [x.e = 0];
			          } else {
			            x.e = v.e;
			            x.c = v.c.slice();
			          }
			          return;
			        }
			        if ((isNum = typeof v == 'number') && v * 0 == 0) {
			          // Use `1 / n` to handle minus zero also.
			          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

			          // Fast path for integers, where n < 2147483648 (2**31).
			          if (v === ~~v) {
			            for (e = 0, i = v; i >= 10; i /= 10, e++);
			            if (e > MAX_EXP) {
			              x.c = x.e = null;
			            } else {
			              x.e = e;
			              x.c = [v];
			            }
			            return;
			          }
			          str = String(v);
			        } else {
			          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
			          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
			        }

			        // Decimal point?
			        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

			        // Exponential form?
			        if ((i = str.search(/e/i)) > 0) {
			          // Determine exponent.
			          if (e < 0) e = i;
			          e += +str.slice(i + 1);
			          str = str.substring(0, i);
			        } else if (e < 0) {
			          // Integer.
			          e = str.length;
			        }
			      } else {
			        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
			        intCheck(b, 2, ALPHABET.length, 'Base');

			        // Allow exponential notation to be used with base 10 argument, while
			        // also rounding to DECIMAL_PLACES as with other bases.
			        if (b == 10 && alphabetHasNormalDecimalDigits) {
			          x = new BigNumber(v);
			          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
			        }
			        str = String(v);
			        if (isNum = typeof v == 'number') {
			          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
			          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
			          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

			          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
			          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
			            throw Error(tooManyDigits + v);
			          }
			        } else {
			          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
			        }
			        alphabet = ALPHABET.slice(0, b);
			        e = i = 0;

			        // Check that str is a valid base b number.
			        // Don't use RegExp, so alphabet can contain special characters.
			        for (len = str.length; i < len; i++) {
			          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
			            if (c == '.') {
			              // If '.' is not the first character and it has not be found before.
			              if (i > e) {
			                e = len;
			                continue;
			              }
			            } else if (!caseChanged) {
			              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
			              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
			                caseChanged = true;
			                i = -1;
			                e = 0;
			                continue;
			              }
			            }
			            return parseNumeric(x, String(v), isNum, b);
			          }
			        }

			        // Prevent later check for length on converted number.
			        isNum = false;
			        str = convertBase(str, b, 10, x.s);

			        // Decimal point?
			        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
			      }

			      // Determine leading zeros.
			      for (i = 0; str.charCodeAt(i) === 48; i++);

			      // Determine trailing zeros.
			      for (len = str.length; str.charCodeAt(--len) === 48;);
			      if (str = str.slice(i, ++len)) {
			        len -= i;

			        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
			        if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
			          throw Error(tooManyDigits + x.s * v);
			        }

			        // Overflow?
			        if ((e = e - i - 1) > MAX_EXP) {
			          // Infinity.
			          x.c = x.e = null;

			          // Underflow?
			        } else if (e < MIN_EXP) {
			          // Zero.
			          x.c = [x.e = 0];
			        } else {
			          x.e = e;
			          x.c = [];

			          // Transform base

			          // e is the base 10 exponent.
			          // i is where to slice str to get the first element of the coefficient array.
			          i = (e + 1) % LOG_BASE;
			          if (e < 0) i += LOG_BASE; // i < 1

			          if (i < len) {
			            if (i) x.c.push(+str.slice(0, i));
			            for (len -= LOG_BASE; i < len;) {
			              x.c.push(+str.slice(i, i += LOG_BASE));
			            }
			            i = LOG_BASE - (str = str.slice(i)).length;
			          } else {
			            i -= len;
			          }
			          for (; i--; str += '0');
			          x.c.push(+str);
			        }
			      } else {
			        // Zero.
			        x.c = [x.e = 0];
			      }
			    }

			    // CONSTRUCTOR PROPERTIES

			    BigNumber.clone = clone;
			    BigNumber.ROUND_UP = 0;
			    BigNumber.ROUND_DOWN = 1;
			    BigNumber.ROUND_CEIL = 2;
			    BigNumber.ROUND_FLOOR = 3;
			    BigNumber.ROUND_HALF_UP = 4;
			    BigNumber.ROUND_HALF_DOWN = 5;
			    BigNumber.ROUND_HALF_EVEN = 6;
			    BigNumber.ROUND_HALF_CEIL = 7;
			    BigNumber.ROUND_HALF_FLOOR = 8;
			    BigNumber.EUCLID = 9;

			    /*
			     * Configure infrequently-changing library-wide settings.
			     *
			     * Accept an object with the following optional properties (if the value of a property is
			     * a number, it must be an integer within the inclusive range stated):
			     *
			     *   DECIMAL_PLACES   {number}           0 to MAX
			     *   ROUNDING_MODE    {number}           0 to 8
			     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
			     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
			     *   CRYPTO           {boolean}          true or false
			     *   MODULO_MODE      {number}           0 to 9
			     *   POW_PRECISION       {number}           0 to MAX
			     *   ALPHABET         {string}           A string of two or more unique characters which does
			     *                                       not contain '.'.
			     *   FORMAT           {object}           An object with some of the following properties:
			     *     prefix                 {string}
			     *     groupSize              {number}
			     *     secondaryGroupSize     {number}
			     *     groupSeparator         {string}
			     *     decimalSeparator       {string}
			     *     fractionGroupSize      {number}
			     *     fractionGroupSeparator {string}
			     *     suffix                 {string}
			     *
			     * (The values assigned to the above FORMAT object properties are not checked for validity.)
			     *
			     * E.g.
			     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
			     *
			     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
			     *
			     * Return an object with the properties current values.
			     */
			    BigNumber.config = BigNumber.set = function (obj) {
			      var p, v;
			      if (obj != null) {
			        if (typeof obj == 'object') {
			          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
			          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
			          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
			            v = obj[p];
			            intCheck(v, 0, MAX, p);
			            DECIMAL_PLACES = v;
			          }

			          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
			          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
			          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
			            v = obj[p];
			            intCheck(v, 0, 8, p);
			            ROUNDING_MODE = v;
			          }

			          // EXPONENTIAL_AT {number|number[]}
			          // Integer, -MAX to MAX inclusive or
			          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
			          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
			          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
			            v = obj[p];
			            if (v && v.pop) {
			              intCheck(v[0], -MAX, 0, p);
			              intCheck(v[1], 0, MAX, p);
			              TO_EXP_NEG = v[0];
			              TO_EXP_POS = v[1];
			            } else {
			              intCheck(v, -MAX, MAX, p);
			              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
			            }
			          }

			          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
			          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
			          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
			          if (obj.hasOwnProperty(p = 'RANGE')) {
			            v = obj[p];
			            if (v && v.pop) {
			              intCheck(v[0], -MAX, -1, p);
			              intCheck(v[1], 1, MAX, p);
			              MIN_EXP = v[0];
			              MAX_EXP = v[1];
			            } else {
			              intCheck(v, -MAX, MAX, p);
			              if (v) {
			                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
			              } else {
			                throw Error(bignumberError + p + ' cannot be zero: ' + v);
			              }
			            }
			          }

			          // CRYPTO {boolean} true or false.
			          // '[BigNumber Error] CRYPTO not true or false: {v}'
			          // '[BigNumber Error] crypto unavailable'
			          if (obj.hasOwnProperty(p = 'CRYPTO')) {
			            v = obj[p];
			            if (v === !!v) {
			              if (v) {
			                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
			                  CRYPTO = v;
			                } else {
			                  CRYPTO = !v;
			                  throw Error(bignumberError + 'crypto unavailable');
			                }
			              } else {
			                CRYPTO = v;
			              }
			            } else {
			              throw Error(bignumberError + p + ' not true or false: ' + v);
			            }
			          }

			          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
			          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
			          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
			            v = obj[p];
			            intCheck(v, 0, 9, p);
			            MODULO_MODE = v;
			          }

			          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
			          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
			          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
			            v = obj[p];
			            intCheck(v, 0, MAX, p);
			            POW_PRECISION = v;
			          }

			          // FORMAT {object}
			          // '[BigNumber Error] FORMAT not an object: {v}'
			          if (obj.hasOwnProperty(p = 'FORMAT')) {
			            v = obj[p];
			            if (typeof v == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
			          }

			          // ALPHABET {string}
			          // '[BigNumber Error] ALPHABET invalid: {v}'
			          if (obj.hasOwnProperty(p = 'ALPHABET')) {
			            v = obj[p];

			            // Disallow if less than two characters,
			            // or if it contains '+', '-', '.', whitespace, or a repeated character.
			            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
			              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
			              ALPHABET = v;
			            } else {
			              throw Error(bignumberError + p + ' invalid: ' + v);
			            }
			          }
			        } else {
			          // '[BigNumber Error] Object expected: {v}'
			          throw Error(bignumberError + 'Object expected: ' + obj);
			        }
			      }
			      return {
			        DECIMAL_PLACES: DECIMAL_PLACES,
			        ROUNDING_MODE: ROUNDING_MODE,
			        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
			        RANGE: [MIN_EXP, MAX_EXP],
			        CRYPTO: CRYPTO,
			        MODULO_MODE: MODULO_MODE,
			        POW_PRECISION: POW_PRECISION,
			        FORMAT: FORMAT,
			        ALPHABET: ALPHABET
			      };
			    };

			    /*
			     * Return true if v is a BigNumber instance, otherwise return false.
			     *
			     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
			     *
			     * v {any}
			     *
			     * '[BigNumber Error] Invalid BigNumber: {v}'
			     */
			    BigNumber.isBigNumber = function (v) {
			      if (!v || v._isBigNumber !== true) return false;
			      if (!BigNumber.DEBUG) return true;
			      var i,
			        n,
			        c = v.c,
			        e = v.e,
			        s = v.s;
			      out: if ({}.toString.call(c) == '[object Array]') {
			        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
			          // If the first element is zero, the BigNumber value must be zero.
			          if (c[0] === 0) {
			            if (e === 0 && c.length === 1) return true;
			            break out;
			          }

			          // Calculate number of digits that c[0] should have, based on the exponent.
			          i = (e + 1) % LOG_BASE;
			          if (i < 1) i += LOG_BASE;

			          // Calculate number of digits of c[0].
			          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
			          if (String(c[0]).length == i) {
			            for (i = 0; i < c.length; i++) {
			              n = c[i];
			              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
			            }

			            // Last element cannot be zero, unless it is the only element.
			            if (n !== 0) return true;
			          }
			        }

			        // Infinity/NaN
			      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
			        return true;
			      }
			      throw Error(bignumberError + 'Invalid BigNumber: ' + v);
			    };

			    /*
			     * Return a new BigNumber whose value is the maximum of the arguments.
			     *
			     * arguments {number|string|BigNumber}
			     */
			    BigNumber.maximum = BigNumber.max = function () {
			      return maxOrMin(arguments, -1);
			    };

			    /*
			     * Return a new BigNumber whose value is the minimum of the arguments.
			     *
			     * arguments {number|string|BigNumber}
			     */
			    BigNumber.minimum = BigNumber.min = function () {
			      return maxOrMin(arguments, 1);
			    };

			    /*
			     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
			     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
			     * zeros are produced).
			     *
			     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
			     * '[BigNumber Error] crypto unavailable'
			     */
			    BigNumber.random = function () {
			      var pow2_53 = 0x20000000000000;

			      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
			      // Check if Math.random() produces more than 32 bits of randomness.
			      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
			      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
			      var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
			        return mathfloor(Math.random() * pow2_53);
			      } : function () {
			        return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
			      };
			      return function (dp) {
			        var a,
			          b,
			          e,
			          k,
			          v,
			          i = 0,
			          c = [],
			          rand = new BigNumber(ONE);
			        if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
			        k = mathceil(dp / LOG_BASE);
			        if (CRYPTO) {
			          // Browsers supporting crypto.getRandomValues.
			          if (crypto.getRandomValues) {
			            a = crypto.getRandomValues(new Uint32Array(k *= 2));
			            for (; i < k;) {
			              // 53 bits:
			              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
			              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
			              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
			              //                                     11111 11111111 11111111
			              // 0x20000 is 2^21.
			              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

			              // Rejection sampling:
			              // 0 <= v < 9007199254740992
			              // Probability that v >= 9e15, is
			              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
			              if (v >= 9e15) {
			                b = crypto.getRandomValues(new Uint32Array(2));
			                a[i] = b[0];
			                a[i + 1] = b[1];
			              } else {
			                // 0 <= v <= 8999999999999999
			                // 0 <= (v % 1e14) <= 99999999999999
			                c.push(v % 1e14);
			                i += 2;
			              }
			            }
			            i = k / 2;

			            // Node.js supporting crypto.randomBytes.
			          } else if (crypto.randomBytes) {
			            // buffer
			            a = crypto.randomBytes(k *= 7);
			            for (; i < k;) {
			              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
			              // 0x100000000 is 2^32, 0x1000000 is 2^24
			              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
			              // 0 <= v < 9007199254740992
			              v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
			              if (v >= 9e15) {
			                crypto.randomBytes(7).copy(a, i);
			              } else {
			                // 0 <= (v % 1e14) <= 99999999999999
			                c.push(v % 1e14);
			                i += 7;
			              }
			            }
			            i = k / 7;
			          } else {
			            CRYPTO = false;
			            throw Error(bignumberError + 'crypto unavailable');
			          }
			        }

			        // Use Math.random.
			        if (!CRYPTO) {
			          for (; i < k;) {
			            v = random53bitInt();
			            if (v < 9e15) c[i++] = v % 1e14;
			          }
			        }
			        k = c[--i];
			        dp %= LOG_BASE;

			        // Convert trailing digits to zeros according to dp.
			        if (k && dp) {
			          v = POWS_TEN[LOG_BASE - dp];
			          c[i] = mathfloor(k / v) * v;
			        }

			        // Remove trailing elements which are zero.
			        for (; c[i] === 0; c.pop(), i--);

			        // Zero?
			        if (i < 0) {
			          c = [e = 0];
			        } else {
			          // Remove leading elements which are zero and adjust exponent accordingly.
			          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

			          // Count the digits of the first element of c to determine leading zeros, and...
			          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

			          // adjust the exponent accordingly.
			          if (i < LOG_BASE) e -= LOG_BASE - i;
			        }
			        rand.e = e;
			        rand.c = c;
			        return rand;
			      };
			    }();

			    /*
			     * Return a BigNumber whose value is the sum of the arguments.
			     *
			     * arguments {number|string|BigNumber}
			     */
			    BigNumber.sum = function () {
			      var i = 1,
			        args = arguments,
			        sum = new BigNumber(args[0]);
			      for (; i < args.length;) sum = sum.plus(args[i++]);
			      return sum;
			    };

			    // PRIVATE FUNCTIONS

			    // Called by BigNumber and BigNumber.prototype.toString.
			    convertBase = function () {
			      var decimal = '0123456789';

			      /*
			       * Convert string of baseIn to an array of numbers of baseOut.
			       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
			       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
			       */
			      function toBaseOut(str, baseIn, baseOut, alphabet) {
			        var j,
			          arr = [0],
			          arrL,
			          i = 0,
			          len = str.length;
			        for (; i < len;) {
			          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
			          arr[0] += alphabet.indexOf(str.charAt(i++));
			          for (j = 0; j < arr.length; j++) {
			            if (arr[j] > baseOut - 1) {
			              if (arr[j + 1] == null) arr[j + 1] = 0;
			              arr[j + 1] += arr[j] / baseOut | 0;
			              arr[j] %= baseOut;
			            }
			          }
			        }
			        return arr.reverse();
			      }

			      // Convert a numeric string of baseIn to a numeric string of baseOut.
			      // If the caller is toString, we are converting from base 10 to baseOut.
			      // If the caller is BigNumber, we are converting from baseIn to base 10.
			      return function (str, baseIn, baseOut, sign, callerIsToString) {
			        var alphabet,
			          d,
			          e,
			          k,
			          r,
			          x,
			          xc,
			          y,
			          i = str.indexOf('.'),
			          dp = DECIMAL_PLACES,
			          rm = ROUNDING_MODE;

			        // Non-integer.
			        if (i >= 0) {
			          k = POW_PRECISION;

			          // Unlimited precision.
			          POW_PRECISION = 0;
			          str = str.replace('.', '');
			          y = new BigNumber(baseIn);
			          x = y.pow(str.length - i);
			          POW_PRECISION = k;

			          // Convert str as if an integer, then restore the fraction part by dividing the
			          // result by its base raised to a power.

			          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
			          y.e = y.c.length;
			        }

			        // Convert the number as integer.

			        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));

			        // xc now represents str as an integer and converted to baseOut. e is the exponent.
			        e = k = xc.length;

			        // Remove trailing zeros.
			        for (; xc[--k] == 0; xc.pop());

			        // Zero?
			        if (!xc[0]) return alphabet.charAt(0);

			        // Does str represent an integer? If so, no need for the division.
			        if (i < 0) {
			          --e;
			        } else {
			          x.c = xc;
			          x.e = e;

			          // The sign is needed for correct rounding.
			          x.s = sign;
			          x = div(x, y, dp, rm, baseOut);
			          xc = x.c;
			          r = x.r;
			          e = x.e;
			        }

			        // xc now represents str converted to baseOut.

			        // THe index of the rounding digit.
			        d = e + dp + 1;

			        // The rounding digit: the digit to the right of the digit that may be rounded up.
			        i = xc[d];

			        // Look at the rounding digits and mode to determine whether to round up.

			        k = baseOut / 2;
			        r = r || d < 0 || xc[d + 1] != null;
			        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));

			        // If the index of the rounding digit is not greater than zero, or xc represents
			        // zero, then the result of the base conversion is zero or, if rounding up, a value
			        // such as 0.00001.
			        if (d < 1 || !xc[0]) {
			          // 1^-dp or 0
			          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
			        } else {
			          // Truncate xc to the required number of decimal places.
			          xc.length = d;

			          // Round up?
			          if (r) {
			            // Rounding up may mean the previous digit has to be rounded up and so on.
			            for (--baseOut; ++xc[--d] > baseOut;) {
			              xc[d] = 0;
			              if (!d) {
			                ++e;
			                xc = [1].concat(xc);
			              }
			            }
			          }

			          // Determine trailing zeros.
			          for (k = xc.length; !xc[--k];);

			          // E.g. [4, 11, 15] becomes 4bf.
			          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

			          // Add leading zeros, decimal point and trailing zeros as required.
			          str = toFixedPoint(str, e, alphabet.charAt(0));
			        }

			        // The caller will add the sign.
			        return str;
			      };
			    }();

			    // Perform division in the specified base. Called by div and convertBase.
			    div = function () {
			      // Assume non-zero x and k.
			      function multiply(x, k, base) {
			        var m,
			          temp,
			          xlo,
			          xhi,
			          carry = 0,
			          i = x.length,
			          klo = k % SQRT_BASE,
			          khi = k / SQRT_BASE | 0;
			        for (x = x.slice(); i--;) {
			          xlo = x[i] % SQRT_BASE;
			          xhi = x[i] / SQRT_BASE | 0;
			          m = khi * xlo + xhi * klo;
			          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
			          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
			          x[i] = temp % base;
			        }
			        if (carry) x = [carry].concat(x);
			        return x;
			      }
			      function compare(a, b, aL, bL) {
			        var i, cmp;
			        if (aL != bL) {
			          cmp = aL > bL ? 1 : -1;
			        } else {
			          for (i = cmp = 0; i < aL; i++) {
			            if (a[i] != b[i]) {
			              cmp = a[i] > b[i] ? 1 : -1;
			              break;
			            }
			          }
			        }
			        return cmp;
			      }
			      function subtract(a, b, aL, base) {
			        var i = 0;

			        // Subtract b from a.
			        for (; aL--;) {
			          a[aL] -= i;
			          i = a[aL] < b[aL] ? 1 : 0;
			          a[aL] = i * base + a[aL] - b[aL];
			        }

			        // Remove leading zeros.
			        for (; !a[0] && a.length > 1; a.splice(0, 1));
			      }

			      // x: dividend, y: divisor.
			      return function (x, y, dp, rm, base) {
			        var cmp,
			          e,
			          i,
			          more,
			          n,
			          prod,
			          prodL,
			          q,
			          qc,
			          rem,
			          remL,
			          rem0,
			          xi,
			          xL,
			          yc0,
			          yL,
			          yz,
			          s = x.s == y.s ? 1 : -1,
			          xc = x.c,
			          yc = y.c;

			        // Either NaN, Infinity or 0?
			        if (!xc || !xc[0] || !yc || !yc[0]) {
			          return new BigNumber(
			          // Return NaN if either NaN, or both Infinity or 0.
			          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :
			          // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
			          xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
			        }
			        q = new BigNumber(s);
			        qc = q.c = [];
			        e = x.e - y.e;
			        s = dp + e + 1;
			        if (!base) {
			          base = BASE;
			          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
			          s = s / LOG_BASE | 0;
			        }

			        // Result exponent may be one less then the current value of e.
			        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
			        for (i = 0; yc[i] == (xc[i] || 0); i++);
			        if (yc[i] > (xc[i] || 0)) e--;
			        if (s < 0) {
			          qc.push(1);
			          more = true;
			        } else {
			          xL = xc.length;
			          yL = yc.length;
			          i = 0;
			          s += 2;

			          // Normalise xc and yc so highest order digit of yc is >= base / 2.

			          n = mathfloor(base / (yc[0] + 1));

			          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
			          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
			          if (n > 1) {
			            yc = multiply(yc, n, base);
			            xc = multiply(xc, n, base);
			            yL = yc.length;
			            xL = xc.length;
			          }
			          xi = yL;
			          rem = xc.slice(0, yL);
			          remL = rem.length;

			          // Add zeros to make remainder as long as divisor.
			          for (; remL < yL; rem[remL++] = 0);
			          yz = yc.slice();
			          yz = [0].concat(yz);
			          yc0 = yc[0];
			          if (yc[1] >= base / 2) yc0++;
			          // Not necessary, but to prevent trial digit n > base, when using base 3.
			          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

			          do {
			            n = 0;

			            // Compare divisor and remainder.
			            cmp = compare(yc, rem, yL, remL);

			            // If divisor < remainder.
			            if (cmp < 0) {
			              // Calculate trial digit, n.

			              rem0 = rem[0];
			              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

			              // n is how many times the divisor goes into the current remainder.
			              n = mathfloor(rem0 / yc0);

			              //  Algorithm:
			              //  product = divisor multiplied by trial digit (n).
			              //  Compare product and remainder.
			              //  If product is greater than remainder:
			              //    Subtract divisor from product, decrement trial digit.
			              //  Subtract product from remainder.
			              //  If product was less than remainder at the last compare:
			              //    Compare new remainder and divisor.
			              //    If remainder is greater than divisor:
			              //      Subtract divisor from remainder, increment trial digit.

			              if (n > 1) {
			                // n may be > base only when base is 3.
			                if (n >= base) n = base - 1;

			                // product = divisor * trial digit.
			                prod = multiply(yc, n, base);
			                prodL = prod.length;
			                remL = rem.length;

			                // Compare product and remainder.
			                // If product > remainder then trial digit n too high.
			                // n is 1 too high about 5% of the time, and is not known to have
			                // ever been more than 1 too high.
			                while (compare(prod, rem, prodL, remL) == 1) {
			                  n--;

			                  // Subtract divisor from product.
			                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
			                  prodL = prod.length;
			                  cmp = 1;
			                }
			              } else {
			                // n is 0 or 1, cmp is -1.
			                // If n is 0, there is no need to compare yc and rem again below,
			                // so change cmp to 1 to avoid it.
			                // If n is 1, leave cmp as -1, so yc and rem are compared again.
			                if (n == 0) {
			                  // divisor < remainder, so n must be at least 1.
			                  cmp = n = 1;
			                }

			                // product = divisor
			                prod = yc.slice();
			                prodL = prod.length;
			              }
			              if (prodL < remL) prod = [0].concat(prod);

			              // Subtract product from remainder.
			              subtract(rem, prod, remL, base);
			              remL = rem.length;

			              // If product was < remainder.
			              if (cmp == -1) {
			                // Compare divisor and new remainder.
			                // If divisor < new remainder, subtract divisor from remainder.
			                // Trial digit n too low.
			                // n is 1 too low about 5% of the time, and very rarely 2 too low.
			                while (compare(yc, rem, yL, remL) < 1) {
			                  n++;

			                  // Subtract divisor from remainder.
			                  subtract(rem, yL < remL ? yz : yc, remL, base);
			                  remL = rem.length;
			                }
			              }
			            } else if (cmp === 0) {
			              n++;
			              rem = [0];
			            } // else cmp === 1 and n will be 0

			            // Add the next digit, n, to the result array.
			            qc[i++] = n;

			            // Update the remainder.
			            if (rem[0]) {
			              rem[remL++] = xc[xi] || 0;
			            } else {
			              rem = [xc[xi]];
			              remL = 1;
			            }
			          } while ((xi++ < xL || rem[0] != null) && s--);
			          more = rem[0] != null;

			          // Leading zero?
			          if (!qc[0]) qc.splice(0, 1);
			        }
			        if (base == BASE) {
			          // To calculate q.e, first get the number of digits of qc[0].
			          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
			          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

			          // Caller is convertBase.
			        } else {
			          q.e = e;
			          q.r = +more;
			        }
			        return q;
			      };
			    }();

			    /*
			     * Return a string representing the value of BigNumber n in fixed-point or exponential
			     * notation rounded to the specified decimal places or significant digits.
			     *
			     * n: a BigNumber.
			     * i: the index of the last digit required (i.e. the digit that may be rounded up).
			     * rm: the rounding mode.
			     * id: 1 (toExponential) or 2 (toPrecision).
			     */
			    function format(n, i, rm, id) {
			      var c0, e, ne, len, str;
			      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
			      if (!n.c) return n.toString();
			      c0 = n.c[0];
			      ne = n.e;
			      if (i == null) {
			        str = coeffToString(n.c);
			        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
			      } else {
			        n = round(new BigNumber(n), i, rm);

			        // n.e may have changed if the value was rounded up.
			        e = n.e;
			        str = coeffToString(n.c);
			        len = str.length;

			        // toPrecision returns exponential notation if the number of significant digits
			        // specified is less than the number of digits necessary to represent the integer
			        // part of the value in fixed-point notation.

			        // Exponential notation.
			        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
			          // Append zeros?
			          for (; len < i; str += '0', len++);
			          str = toExponential(str, e);

			          // Fixed-point notation.
			        } else {
			          i -= ne;
			          str = toFixedPoint(str, e, '0');

			          // Append zeros?
			          if (e + 1 > len) {
			            if (--i > 0) for (str += '.'; i--; str += '0');
			          } else {
			            i += e - len;
			            if (i > 0) {
			              if (e + 1 == len) str += '.';
			              for (; i--; str += '0');
			            }
			          }
			        }
			      }
			      return n.s < 0 && c0 ? '-' + str : str;
			    }

			    // Handle BigNumber.max and BigNumber.min.
			    // If any number is NaN, return NaN.
			    function maxOrMin(args, n) {
			      var k,
			        y,
			        i = 1,
			        x = new BigNumber(args[0]);
			      for (; i < args.length; i++) {
			        y = new BigNumber(args[i]);
			        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
			          x = y;
			        }
			      }
			      return x;
			    }

			    /*
			     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
			     * Called by minus, plus and times.
			     */
			    function normalise(n, c, e) {
			      var i = 1,
			        j = c.length;

			      // Remove trailing zeros.
			      for (; !c[--j]; c.pop());

			      // Calculate the base 10 exponent. First get the number of digits of c[0].
			      for (j = c[0]; j >= 10; j /= 10, i++);

			      // Overflow?
			      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
			        // Infinity.
			        n.c = n.e = null;

			        // Underflow?
			      } else if (e < MIN_EXP) {
			        // Zero.
			        n.c = [n.e = 0];
			      } else {
			        n.e = e;
			        n.c = c;
			      }
			      return n;
			    }

			    // Handle values that fail the validity test in BigNumber.
			    parseNumeric = function () {
			      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
			        dotAfter = /^([^.]+)\.$/,
			        dotBefore = /^\.([^.]+)$/,
			        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
			        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
			      return function (x, str, isNum, b) {
			        var base,
			          s = isNum ? str : str.replace(whitespaceOrPlus, '');

			        // No exception on ±Infinity or NaN.
			        if (isInfinityOrNaN.test(s)) {
			          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
			        } else {
			          if (!isNum) {
			            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
			            s = s.replace(basePrefix, function (m, p1, p2) {
			              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
			              return !b || b == base ? p1 : m;
			            });
			            if (b) {
			              base = b;

			              // E.g. '1.' to '1', '.1' to '0.1'
			              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
			            }
			            if (str != s) return new BigNumber(s, base);
			          }

			          // '[BigNumber Error] Not a number: {n}'
			          // '[BigNumber Error] Not a base {b} number: {n}'
			          if (BigNumber.DEBUG) {
			            throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
			          }

			          // NaN
			          x.s = null;
			        }
			        x.c = x.e = null;
			      };
			    }();

			    /*
			     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
			     * If r is truthy, it is known that there are more digits after the rounding digit.
			     */
			    function round(x, sd, rm, r) {
			      var d,
			        i,
			        j,
			        k,
			        n,
			        ni,
			        rd,
			        xc = x.c,
			        pows10 = POWS_TEN;

			      // if x is not Infinity or NaN...
			      if (xc) {
			        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
			        // n is a base 1e14 number, the value of the element of array x.c containing rd.
			        // ni is the index of n within x.c.
			        // d is the number of digits of n.
			        // i is the index of rd within n including leading zeros.
			        // j is the actual index of rd within n (if < 0, rd is a leading zero).
			        out: {
			          // Get the number of digits of the first element of xc.
			          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
			          i = sd - d;

			          // If the rounding digit is in the first element of xc...
			          if (i < 0) {
			            i += LOG_BASE;
			            j = sd;
			            n = xc[ni = 0];

			            // Get the rounding digit at index j of n.
			            rd = mathfloor(n / pows10[d - j - 1] % 10);
			          } else {
			            ni = mathceil((i + 1) / LOG_BASE);
			            if (ni >= xc.length) {
			              if (r) {
			                // Needed by sqrt.
			                for (; xc.length <= ni; xc.push(0));
			                n = rd = 0;
			                d = 1;
			                i %= LOG_BASE;
			                j = i - LOG_BASE + 1;
			              } else {
			                break out;
			              }
			            } else {
			              n = k = xc[ni];

			              // Get the number of digits of n.
			              for (d = 1; k >= 10; k /= 10, d++);

			              // Get the index of rd within n.
			              i %= LOG_BASE;

			              // Get the index of rd within n, adjusted for leading zeros.
			              // The number of leading zeros of n is given by LOG_BASE - d.
			              j = i - LOG_BASE + d;

			              // Get the rounding digit at index j of n.
			              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
			            }
			          }
			          r = r || sd < 0 ||
			          // Are there any non-zero digits after the rounding digit?
			          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
			          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
			          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
			          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&
			          // Check whether the digit to the left of the rounding digit is odd.
			          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
			          if (sd < 1 || !xc[0]) {
			            xc.length = 0;
			            if (r) {
			              // Convert sd to decimal places.
			              sd -= x.e + 1;

			              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
			              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
			              x.e = -sd || 0;
			            } else {
			              // Zero.
			              xc[0] = x.e = 0;
			            }
			            return x;
			          }

			          // Remove excess digits.
			          if (i == 0) {
			            xc.length = ni;
			            k = 1;
			            ni--;
			          } else {
			            xc.length = ni + 1;
			            k = pows10[LOG_BASE - i];

			            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
			            // j > 0 means i > number of leading zeros of n.
			            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
			          }

			          // Round up?
			          if (r) {
			            for (;;) {
			              // If the digit to be rounded up is in the first element of xc...
			              if (ni == 0) {
			                // i will be the length of xc[0] before k is added.
			                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
			                j = xc[0] += k;
			                for (k = 1; j >= 10; j /= 10, k++);

			                // if i != k the length has increased.
			                if (i != k) {
			                  x.e++;
			                  if (xc[0] == BASE) xc[0] = 1;
			                }
			                break;
			              } else {
			                xc[ni] += k;
			                if (xc[ni] != BASE) break;
			                xc[ni--] = 0;
			                k = 1;
			              }
			            }
			          }

			          // Remove trailing zeros.
			          for (i = xc.length; xc[--i] === 0; xc.pop());
			        }

			        // Overflow? Infinity.
			        if (x.e > MAX_EXP) {
			          x.c = x.e = null;

			          // Underflow? Zero.
			        } else if (x.e < MIN_EXP) {
			          x.c = [x.e = 0];
			        }
			      }
			      return x;
			    }
			    function valueOf(n) {
			      var str,
			        e = n.e;
			      if (e === null) return n.toString();
			      str = coeffToString(n.c);
			      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
			      return n.s < 0 ? '-' + str : str;
			    }

			    // PROTOTYPE/INSTANCE METHODS

			    /*
			     * Return a new BigNumber whose value is the absolute value of this BigNumber.
			     */
			    P.absoluteValue = P.abs = function () {
			      var x = new BigNumber(this);
			      if (x.s < 0) x.s = 1;
			      return x;
			    };

			    /*
			     * Return
			     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
			     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
			     *   0 if they have the same value,
			     *   or null if the value of either is NaN.
			     */
			    P.comparedTo = function (y, b) {
			      return compare(this, new BigNumber(y, b));
			    };

			    /*
			     * If dp is undefined or null or true or false, return the number of decimal places of the
			     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
			     *
			     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
			     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
			     * ROUNDING_MODE if rm is omitted.
			     *
			     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
			     */
			    P.decimalPlaces = P.dp = function (dp, rm) {
			      var c,
			        n,
			        v,
			        x = this;
			      if (dp != null) {
			        intCheck(dp, 0, MAX);
			        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
			        return round(new BigNumber(x), dp + x.e + 1, rm);
			      }
			      if (!(c = x.c)) return null;
			      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

			      // Subtract the number of trailing zeros of the last number.
			      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
			      if (n < 0) n = 0;
			      return n;
			    };

			    /*
			     *  n / 0 = I
			     *  n / N = N
			     *  n / I = 0
			     *  0 / n = 0
			     *  0 / 0 = N
			     *  0 / N = N
			     *  0 / I = 0
			     *  N / n = N
			     *  N / 0 = N
			     *  N / N = N
			     *  N / I = N
			     *  I / n = I
			     *  I / 0 = I
			     *  I / N = N
			     *  I / I = N
			     *
			     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
			     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
			     */
			    P.dividedBy = P.div = function (y, b) {
			      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
			    };

			    /*
			     * Return a new BigNumber whose value is the integer part of dividing the value of this
			     * BigNumber by the value of BigNumber(y, b).
			     */
			    P.dividedToIntegerBy = P.idiv = function (y, b) {
			      return div(this, new BigNumber(y, b), 0, 1);
			    };

			    /*
			     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
			     *
			     * If m is present, return the result modulo m.
			     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
			     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
			     *
			     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
			     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
			     *
			     * n {number|string|BigNumber} The exponent. An integer.
			     * [m] {number|string|BigNumber} The modulus.
			     *
			     * '[BigNumber Error] Exponent not an integer: {n}'
			     */
			    P.exponentiatedBy = P.pow = function (n, m) {
			      var half,
			        isModExp,
			        i,
			        k,
			        more,
			        nIsBig,
			        nIsNeg,
			        nIsOdd,
			        y,
			        x = this;
			      n = new BigNumber(n);

			      // Allow NaN and ±Infinity, but not other non-integers.
			      if (n.c && !n.isInteger()) {
			        throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
			      }
			      if (m != null) m = new BigNumber(m);

			      // Exponent of MAX_SAFE_INTEGER is 15.
			      nIsBig = n.e > 14;

			      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
			      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
			        // The sign of the result of pow when x is negative depends on the evenness of n.
			        // If +n overflows to ±Infinity, the evenness of n would be not be known.
			        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
			        return m ? y.mod(m) : y;
			      }
			      nIsNeg = n.s < 0;
			      if (m) {
			        // x % m returns NaN if abs(m) is zero, or m is NaN.
			        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
			        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
			        if (isModExp) x = x.mod(m);

			        // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
			        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
			      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
			      // [1, 240000000]
			      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
			      // [80000000000000]  [99999750000000]
			      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
			        // If x is negative and n is odd, k = -0, else k = 0.
			        k = x.s < 0 && isOdd(n) ? -0 : 0;

			        // If x >= 1, k = ±Infinity.
			        if (x.e > -1) k = 1 / k;

			        // If n is negative return ±0, else return ±Infinity.
			        return new BigNumber(nIsNeg ? 1 / k : k);
			      } else if (POW_PRECISION) {
			        // Truncating each coefficient array to a length of k after each multiplication
			        // equates to truncating significant digits to POW_PRECISION + [28, 41],
			        // i.e. there will be a minimum of 28 guard digits retained.
			        k = mathceil(POW_PRECISION / LOG_BASE + 2);
			      }
			      if (nIsBig) {
			        half = new BigNumber(0.5);
			        if (nIsNeg) n.s = 1;
			        nIsOdd = isOdd(n);
			      } else {
			        i = Math.abs(+valueOf(n));
			        nIsOdd = i % 2;
			      }
			      y = new BigNumber(ONE);

			      // Performs 54 loop iterations for n of 9007199254740991.
			      for (;;) {
			        if (nIsOdd) {
			          y = y.times(x);
			          if (!y.c) break;
			          if (k) {
			            if (y.c.length > k) y.c.length = k;
			          } else if (isModExp) {
			            y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
			          }
			        }
			        if (i) {
			          i = mathfloor(i / 2);
			          if (i === 0) break;
			          nIsOdd = i % 2;
			        } else {
			          n = n.times(half);
			          round(n, n.e + 1, 1);
			          if (n.e > 14) {
			            nIsOdd = isOdd(n);
			          } else {
			            i = +valueOf(n);
			            if (i === 0) break;
			            nIsOdd = i % 2;
			          }
			        }
			        x = x.times(x);
			        if (k) {
			          if (x.c && x.c.length > k) x.c.length = k;
			        } else if (isModExp) {
			          x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
			        }
			      }
			      if (isModExp) return y;
			      if (nIsNeg) y = ONE.div(y);
			      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
			    };

			    /*
			     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
			     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
			     *
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
			     */
			    P.integerValue = function (rm) {
			      var n = new BigNumber(this);
			      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
			      return round(n, n.e + 1, rm);
			    };

			    /*
			     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
			     * otherwise return false.
			     */
			    P.isEqualTo = P.eq = function (y, b) {
			      return compare(this, new BigNumber(y, b)) === 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is a finite number, otherwise return false.
			     */
			    P.isFinite = function () {
			      return !!this.c;
			    };

			    /*
			     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
			     * otherwise return false.
			     */
			    P.isGreaterThan = P.gt = function (y, b) {
			      return compare(this, new BigNumber(y, b)) > 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is greater than or equal to the value of
			     * BigNumber(y, b), otherwise return false.
			     */
			    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
			      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is an integer, otherwise return false.
			     */
			    P.isInteger = function () {
			      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
			    };

			    /*
			     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
			     * otherwise return false.
			     */
			    P.isLessThan = P.lt = function (y, b) {
			      return compare(this, new BigNumber(y, b)) < 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is less than or equal to the value of
			     * BigNumber(y, b), otherwise return false.
			     */
			    P.isLessThanOrEqualTo = P.lte = function (y, b) {
			      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is NaN, otherwise return false.
			     */
			    P.isNaN = function () {
			      return !this.s;
			    };

			    /*
			     * Return true if the value of this BigNumber is negative, otherwise return false.
			     */
			    P.isNegative = function () {
			      return this.s < 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is positive, otherwise return false.
			     */
			    P.isPositive = function () {
			      return this.s > 0;
			    };

			    /*
			     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
			     */
			    P.isZero = function () {
			      return !!this.c && this.c[0] == 0;
			    };

			    /*
			     *  n - 0 = n
			     *  n - N = N
			     *  n - I = -I
			     *  0 - n = -n
			     *  0 - 0 = 0
			     *  0 - N = N
			     *  0 - I = -I
			     *  N - n = N
			     *  N - 0 = N
			     *  N - N = N
			     *  N - I = N
			     *  I - n = I
			     *  I - 0 = I
			     *  I - N = N
			     *  I - I = N
			     *
			     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
			     * BigNumber(y, b).
			     */
			    P.minus = function (y, b) {
			      var i,
			        j,
			        t,
			        xLTy,
			        x = this,
			        a = x.s;
			      y = new BigNumber(y, b);
			      b = y.s;

			      // Either NaN?
			      if (!a || !b) return new BigNumber(NaN);

			      // Signs differ?
			      if (a != b) {
			        y.s = -b;
			        return x.plus(y);
			      }
			      var xe = x.e / LOG_BASE,
			        ye = y.e / LOG_BASE,
			        xc = x.c,
			        yc = y.c;
			      if (!xe || !ye) {
			        // Either Infinity?
			        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

			        // Either zero?
			        if (!xc[0] || !yc[0]) {
			          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
			          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :
			          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
			          ROUNDING_MODE == 3 ? -0 : 0);
			        }
			      }
			      xe = bitFloor(xe);
			      ye = bitFloor(ye);
			      xc = xc.slice();

			      // Determine which is the bigger number.
			      if (a = xe - ye) {
			        if (xLTy = a < 0) {
			          a = -a;
			          t = xc;
			        } else {
			          ye = xe;
			          t = yc;
			        }
			        t.reverse();

			        // Prepend zeros to equalise exponents.
			        for (b = a; b--; t.push(0));
			        t.reverse();
			      } else {
			        // Exponents equal. Check digit by digit.
			        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
			        for (a = b = 0; b < j; b++) {
			          if (xc[b] != yc[b]) {
			            xLTy = xc[b] < yc[b];
			            break;
			          }
			        }
			      }

			      // x < y? Point xc to the array of the bigger number.
			      if (xLTy) {
			        t = xc;
			        xc = yc;
			        yc = t;
			        y.s = -y.s;
			      }
			      b = (j = yc.length) - (i = xc.length);

			      // Append zeros to xc if shorter.
			      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
			      if (b > 0) for (; b--; xc[i++] = 0);
			      b = BASE - 1;

			      // Subtract yc from xc.
			      for (; j > a;) {
			        if (xc[--j] < yc[j]) {
			          for (i = j; i && !xc[--i]; xc[i] = b);
			          --xc[i];
			          xc[j] += BASE;
			        }
			        xc[j] -= yc[j];
			      }

			      // Remove leading zeros and adjust exponent accordingly.
			      for (; xc[0] == 0; xc.splice(0, 1), --ye);

			      // Zero?
			      if (!xc[0]) {
			        // Following IEEE 754 (2008) 6.3,
			        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
			        y.s = ROUNDING_MODE == 3 ? -1 : 1;
			        y.c = [y.e = 0];
			        return y;
			      }

			      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
			      // for finite x and y.
			      return normalise(y, xc, ye);
			    };

			    /*
			     *   n % 0 =  N
			     *   n % N =  N
			     *   n % I =  n
			     *   0 % n =  0
			     *  -0 % n = -0
			     *   0 % 0 =  N
			     *   0 % N =  N
			     *   0 % I =  0
			     *   N % n =  N
			     *   N % 0 =  N
			     *   N % N =  N
			     *   N % I =  N
			     *   I % n =  N
			     *   I % 0 =  N
			     *   I % N =  N
			     *   I % I =  N
			     *
			     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
			     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
			     */
			    P.modulo = P.mod = function (y, b) {
			      var q,
			        s,
			        x = this;
			      y = new BigNumber(y, b);

			      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
			      if (!x.c || !y.s || y.c && !y.c[0]) {
			        return new BigNumber(NaN);

			        // Return x if y is Infinity or x is zero.
			      } else if (!y.c || x.c && !x.c[0]) {
			        return new BigNumber(x);
			      }
			      if (MODULO_MODE == 9) {
			        // Euclidian division: q = sign(y) * floor(x / abs(y))
			        // r = x - qy    where  0 <= r < abs(y)
			        s = y.s;
			        y.s = 1;
			        q = div(x, y, 0, 3);
			        y.s = s;
			        q.s *= s;
			      } else {
			        q = div(x, y, 0, MODULO_MODE);
			      }
			      y = x.minus(q.times(y));

			      // To match JavaScript %, ensure sign of zero is sign of dividend.
			      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
			      return y;
			    };

			    /*
			     *  n * 0 = 0
			     *  n * N = N
			     *  n * I = I
			     *  0 * n = 0
			     *  0 * 0 = 0
			     *  0 * N = N
			     *  0 * I = N
			     *  N * n = N
			     *  N * 0 = N
			     *  N * N = N
			     *  N * I = N
			     *  I * n = I
			     *  I * 0 = N
			     *  I * N = N
			     *  I * I = I
			     *
			     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
			     * of BigNumber(y, b).
			     */
			    P.multipliedBy = P.times = function (y, b) {
			      var c,
			        e,
			        i,
			        j,
			        k,
			        m,
			        xcL,
			        xlo,
			        xhi,
			        ycL,
			        ylo,
			        yhi,
			        zc,
			        base,
			        sqrtBase,
			        x = this,
			        xc = x.c,
			        yc = (y = new BigNumber(y, b)).c;

			      // Either NaN, ±Infinity or ±0?
			      if (!xc || !yc || !xc[0] || !yc[0]) {
			        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
			        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
			          y.c = y.e = y.s = null;
			        } else {
			          y.s *= x.s;

			          // Return ±Infinity if either is ±Infinity.
			          if (!xc || !yc) {
			            y.c = y.e = null;

			            // Return ±0 if either is ±0.
			          } else {
			            y.c = [0];
			            y.e = 0;
			          }
			        }
			        return y;
			      }
			      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
			      y.s *= x.s;
			      xcL = xc.length;
			      ycL = yc.length;

			      // Ensure xc points to longer array and xcL to its length.
			      if (xcL < ycL) {
			        zc = xc;
			        xc = yc;
			        yc = zc;
			        i = xcL;
			        xcL = ycL;
			        ycL = i;
			      }

			      // Initialise the result array with zeros.
			      for (i = xcL + ycL, zc = []; i--; zc.push(0));
			      base = BASE;
			      sqrtBase = SQRT_BASE;
			      for (i = ycL; --i >= 0;) {
			        c = 0;
			        ylo = yc[i] % sqrtBase;
			        yhi = yc[i] / sqrtBase | 0;
			        for (k = xcL, j = i + k; j > i;) {
			          xlo = xc[--k] % sqrtBase;
			          xhi = xc[k] / sqrtBase | 0;
			          m = yhi * xlo + xhi * ylo;
			          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
			          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
			          zc[j--] = xlo % base;
			        }
			        zc[j] = c;
			      }
			      if (c) {
			        ++e;
			      } else {
			        zc.splice(0, 1);
			      }
			      return normalise(y, zc, e);
			    };

			    /*
			     * Return a new BigNumber whose value is the value of this BigNumber negated,
			     * i.e. multiplied by -1.
			     */
			    P.negated = function () {
			      var x = new BigNumber(this);
			      x.s = -x.s || null;
			      return x;
			    };

			    /*
			     *  n + 0 = n
			     *  n + N = N
			     *  n + I = I
			     *  0 + n = n
			     *  0 + 0 = 0
			     *  0 + N = N
			     *  0 + I = I
			     *  N + n = N
			     *  N + 0 = N
			     *  N + N = N
			     *  N + I = N
			     *  I + n = I
			     *  I + 0 = I
			     *  I + N = N
			     *  I + I = I
			     *
			     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
			     * BigNumber(y, b).
			     */
			    P.plus = function (y, b) {
			      var t,
			        x = this,
			        a = x.s;
			      y = new BigNumber(y, b);
			      b = y.s;

			      // Either NaN?
			      if (!a || !b) return new BigNumber(NaN);

			      // Signs differ?
			      if (a != b) {
			        y.s = -b;
			        return x.minus(y);
			      }
			      var xe = x.e / LOG_BASE,
			        ye = y.e / LOG_BASE,
			        xc = x.c,
			        yc = y.c;
			      if (!xe || !ye) {
			        // Return ±Infinity if either ±Infinity.
			        if (!xc || !yc) return new BigNumber(a / 0);

			        // Either zero?
			        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
			        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
			      }
			      xe = bitFloor(xe);
			      ye = bitFloor(ye);
			      xc = xc.slice();

			      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
			      if (a = xe - ye) {
			        if (a > 0) {
			          ye = xe;
			          t = yc;
			        } else {
			          a = -a;
			          t = xc;
			        }
			        t.reverse();
			        for (; a--; t.push(0));
			        t.reverse();
			      }
			      a = xc.length;
			      b = yc.length;

			      // Point xc to the longer array, and b to the shorter length.
			      if (a - b < 0) {
			        t = yc;
			        yc = xc;
			        xc = t;
			        b = a;
			      }

			      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
			      for (a = 0; b;) {
			        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
			        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
			      }
			      if (a) {
			        xc = [a].concat(xc);
			        ++ye;
			      }

			      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
			      // ye = MAX_EXP + 1 possible
			      return normalise(y, xc, ye);
			    };

			    /*
			     * If sd is undefined or null or true or false, return the number of significant digits of
			     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
			     * If sd is true include integer-part trailing zeros in the count.
			     *
			     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
			     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
			     * ROUNDING_MODE if rm is omitted.
			     *
			     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
			     *                     boolean: whether to count integer-part trailing zeros: true or false.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
			     */
			    P.precision = P.sd = function (sd, rm) {
			      var c,
			        n,
			        v,
			        x = this;
			      if (sd != null && sd !== !!sd) {
			        intCheck(sd, 1, MAX);
			        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
			        return round(new BigNumber(x), sd, rm);
			      }
			      if (!(c = x.c)) return null;
			      v = c.length - 1;
			      n = v * LOG_BASE + 1;
			      if (v = c[v]) {
			        // Subtract the number of trailing zeros of the last element.
			        for (; v % 10 == 0; v /= 10, n--);

			        // Add the number of digits of the first element.
			        for (v = c[0]; v >= 10; v /= 10, n++);
			      }
			      if (sd && x.e + 1 > n) n = x.e + 1;
			      return n;
			    };

			    /*
			     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
			     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
			     *
			     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
			     */
			    P.shiftedBy = function (k) {
			      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
			      return this.times('1e' + k);
			    };

			    /*
			     *  sqrt(-n) =  N
			     *  sqrt(N) =  N
			     *  sqrt(-I) =  N
			     *  sqrt(I) =  I
			     *  sqrt(0) =  0
			     *  sqrt(-0) = -0
			     *
			     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
			     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
			     */
			    P.squareRoot = P.sqrt = function () {
			      var m,
			        n,
			        r,
			        rep,
			        t,
			        x = this,
			        c = x.c,
			        s = x.s,
			        e = x.e,
			        dp = DECIMAL_PLACES + 4,
			        half = new BigNumber('0.5');

			      // Negative/NaN/Infinity/zero?
			      if (s !== 1 || !c || !c[0]) {
			        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
			      }

			      // Initial estimate.
			      s = Math.sqrt(+valueOf(x));

			      // Math.sqrt underflow/overflow?
			      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
			      if (s == 0 || s == 1 / 0) {
			        n = coeffToString(c);
			        if ((n.length + e) % 2 == 0) n += '0';
			        s = Math.sqrt(+n);
			        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
			        if (s == 1 / 0) {
			          n = '5e' + e;
			        } else {
			          n = s.toExponential();
			          n = n.slice(0, n.indexOf('e') + 1) + e;
			        }
			        r = new BigNumber(n);
			      } else {
			        r = new BigNumber(s + '');
			      }

			      // Check for zero.
			      // r could be zero if MIN_EXP is changed after the this value was created.
			      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
			      // coeffToString to throw.
			      if (r.c[0]) {
			        e = r.e;
			        s = e + dp;
			        if (s < 3) s = 0;

			        // Newton-Raphson iteration.
			        for (;;) {
			          t = r;
			          r = half.times(t.plus(div(x, t, dp, 1)));
			          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
			            // The exponent of r may here be one less than the final result exponent,
			            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
			            // are indexed correctly.
			            if (r.e < e) --s;
			            n = n.slice(s - 3, s + 1);

			            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
			            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
			            // iteration.
			            if (n == '9999' || !rep && n == '4999') {
			              // On the first iteration only, check to see if rounding up gives the
			              // exact result as the nines may infinitely repeat.
			              if (!rep) {
			                round(t, t.e + DECIMAL_PLACES + 2, 0);
			                if (t.times(t).eq(x)) {
			                  r = t;
			                  break;
			                }
			              }
			              dp += 4;
			              s += 4;
			              rep = 1;
			            } else {
			              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
			              // result. If not, then there are further digits and m will be truthy.
			              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
			                // Truncate to the first rounding digit.
			                round(r, r.e + DECIMAL_PLACES + 2, 1);
			                m = !r.times(r).eq(x);
			              }
			              break;
			            }
			          }
			        }
			      }
			      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
			    };

			    /*
			     * Return a string representing the value of this BigNumber in exponential notation and
			     * rounded using ROUNDING_MODE to dp fixed decimal places.
			     *
			     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
			     */
			    P.toExponential = function (dp, rm) {
			      if (dp != null) {
			        intCheck(dp, 0, MAX);
			        dp++;
			      }
			      return format(this, dp, rm, 1);
			    };

			    /*
			     * Return a string representing the value of this BigNumber in fixed-point notation rounding
			     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
			     *
			     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
			     * but e.g. (-0.00001).toFixed(0) is '-0'.
			     *
			     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
			     */
			    P.toFixed = function (dp, rm) {
			      if (dp != null) {
			        intCheck(dp, 0, MAX);
			        dp = dp + this.e + 1;
			      }
			      return format(this, dp, rm);
			    };

			    /*
			     * Return a string representing the value of this BigNumber in fixed-point notation rounded
			     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
			     * of the format or FORMAT object (see BigNumber.set).
			     *
			     * The formatting object may contain some or all of the properties shown below.
			     *
			     * FORMAT = {
			     *   prefix: '',
			     *   groupSize: 3,
			     *   secondaryGroupSize: 0,
			     *   groupSeparator: ',',
			     *   decimalSeparator: '.',
			     *   fractionGroupSize: 0,
			     *   fractionGroupSeparator: '\xA0',      // non-breaking space
			     *   suffix: ''
			     * };
			     *
			     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     * [format] {object} Formatting options. See FORMAT pbject above.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
			     * '[BigNumber Error] Argument not an object: {format}'
			     */
			    P.toFormat = function (dp, rm, format) {
			      var str,
			        x = this;
			      if (format == null) {
			        if (dp != null && rm && typeof rm == 'object') {
			          format = rm;
			          rm = null;
			        } else if (dp && typeof dp == 'object') {
			          format = dp;
			          dp = rm = null;
			        } else {
			          format = FORMAT;
			        }
			      } else if (typeof format != 'object') {
			        throw Error(bignumberError + 'Argument not an object: ' + format);
			      }
			      str = x.toFixed(dp, rm);
			      if (x.c) {
			        var i,
			          arr = str.split('.'),
			          g1 = +format.groupSize,
			          g2 = +format.secondaryGroupSize,
			          groupSeparator = format.groupSeparator || '',
			          intPart = arr[0],
			          fractionPart = arr[1],
			          isNeg = x.s < 0,
			          intDigits = isNeg ? intPart.slice(1) : intPart,
			          len = intDigits.length;
			        if (g2) {
			          i = g1;
			          g1 = g2;
			          g2 = i;
			          len -= i;
			        }
			        if (g1 > 0 && len > 0) {
			          i = len % g1 || g1;
			          intPart = intDigits.substr(0, i);
			          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
			          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
			          if (isNeg) intPart = '-' + intPart;
			        }
			        str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
			      }
			      return (format.prefix || '') + str + (format.suffix || '');
			    };

			    /*
			     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
			     * fraction with an integer numerator and an integer denominator.
			     * The denominator will be a positive non-zero value less than or equal to the specified
			     * maximum denominator. If a maximum denominator is not specified, the denominator will be
			     * the lowest value necessary to represent the number exactly.
			     *
			     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
			     *
			     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
			     */
			    P.toFraction = function (md) {
			      var d,
			        d0,
			        d1,
			        d2,
			        e,
			        exp,
			        n,
			        n0,
			        n1,
			        q,
			        r,
			        s,
			        x = this,
			        xc = x.c;
			      if (md != null) {
			        n = new BigNumber(md);

			        // Throw if md is less than one or is not an integer, unless it is Infinity.
			        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
			          throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
			        }
			      }
			      if (!xc) return new BigNumber(x);
			      d = new BigNumber(ONE);
			      n1 = d0 = new BigNumber(ONE);
			      d1 = n0 = new BigNumber(ONE);
			      s = coeffToString(xc);

			      // Determine initial denominator.
			      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
			      e = d.e = s.length - x.e - 1;
			      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
			      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
			      exp = MAX_EXP;
			      MAX_EXP = 1 / 0;
			      n = new BigNumber(s);

			      // n0 = d1 = 0
			      n0.c[0] = 0;
			      for (;;) {
			        q = div(n, d, 0, 1);
			        d2 = d0.plus(q.times(d1));
			        if (d2.comparedTo(md) == 1) break;
			        d0 = d1;
			        d1 = d2;
			        n1 = n0.plus(q.times(d2 = n1));
			        n0 = d2;
			        d = n.minus(q.times(d2 = d));
			        n = d2;
			      }
			      d2 = div(md.minus(d0), d1, 0, 1);
			      n0 = n0.plus(d2.times(n1));
			      d0 = d0.plus(d2.times(d1));
			      n0.s = n1.s = x.s;
			      e = e * 2;

			      // Determine which fraction is closer to x, n0/d0 or n1/d1
			      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
			      MAX_EXP = exp;
			      return r;
			    };

			    /*
			     * Return the value of this BigNumber converted to a number primitive.
			     */
			    P.toNumber = function () {
			      return +valueOf(this);
			    };

			    /*
			     * Return a string representing the value of this BigNumber rounded to sd significant digits
			     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
			     * necessary to represent the integer part of the value in fixed-point notation, then use
			     * exponential notation.
			     *
			     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
			     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
			     *
			     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
			     */
			    P.toPrecision = function (sd, rm) {
			      if (sd != null) intCheck(sd, 1, MAX);
			      return format(this, sd, rm, 2);
			    };

			    /*
			     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
			     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
			     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
			     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
			     * TO_EXP_NEG, return exponential notation.
			     *
			     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
			     *
			     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
			     */
			    P.toString = function (b) {
			      var str,
			        n = this,
			        s = n.s,
			        e = n.e;

			      // Infinity or NaN?
			      if (e === null) {
			        if (s) {
			          str = 'Infinity';
			          if (s < 0) str = '-' + str;
			        } else {
			          str = 'NaN';
			        }
			      } else {
			        if (b == null) {
			          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
			        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
			          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
			          str = toFixedPoint(coeffToString(n.c), n.e, '0');
			        } else {
			          intCheck(b, 2, ALPHABET.length, 'Base');
			          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
			        }
			        if (s < 0 && n.c[0]) str = '-' + str;
			      }
			      return str;
			    };

			    /*
			     * Return as toString, but do not accept a base argument, and include the minus sign for
			     * negative zero.
			     */
			    P.valueOf = P.toJSON = function () {
			      return valueOf(this);
			    };
			    P._isBigNumber = true;
			    if (configObject != null) BigNumber.set(configObject);
			    return BigNumber;
			  }

			  // PRIVATE HELPER FUNCTIONS

			  // These functions don't need access to variables,
			  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.

			  function bitFloor(n) {
			    var i = n | 0;
			    return n > 0 || n === i ? i : i - 1;
			  }

			  // Return a coefficient array as a string of base 10 digits.
			  function coeffToString(a) {
			    var s,
			      z,
			      i = 1,
			      j = a.length,
			      r = a[0] + '';
			    for (; i < j;) {
			      s = a[i++] + '';
			      z = LOG_BASE - s.length;
			      for (; z--; s = '0' + s);
			      r += s;
			    }

			    // Determine trailing zeros.
			    for (j = r.length; r.charCodeAt(--j) === 48;);
			    return r.slice(0, j + 1 || 1);
			  }

			  // Compare the value of BigNumbers x and y.
			  function compare(x, y) {
			    var a,
			      b,
			      xc = x.c,
			      yc = y.c,
			      i = x.s,
			      j = y.s,
			      k = x.e,
			      l = y.e;

			    // Either NaN?
			    if (!i || !j) return null;
			    a = xc && !xc[0];
			    b = yc && !yc[0];

			    // Either zero?
			    if (a || b) return a ? b ? 0 : -j : i;

			    // Signs differ?
			    if (i != j) return i;
			    a = i < 0;
			    b = k == l;

			    // Either Infinity?
			    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

			    // Compare exponents.
			    if (!b) return k > l ^ a ? 1 : -1;
			    j = (k = xc.length) < (l = yc.length) ? k : l;

			    // Compare digit by digit.
			    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

			    // Compare lengths.
			    return k == l ? 0 : k > l ^ a ? 1 : -1;
			  }

			  /*
			   * Check that n is a primitive number, an integer, and in range, otherwise throw.
			   */
			  function intCheck(n, min, max, name) {
			    if (n < min || n > max || n !== mathfloor(n)) {
			      throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
			    }
			  }

			  // Assumes finite n.
			  function isOdd(n) {
			    var k = n.c.length - 1;
			    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
			  }
			  function toExponential(str, e) {
			    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
			  }
			  function toFixedPoint(str, e, z) {
			    var len, zs;

			    // Negative exponent?
			    if (e < 0) {
			      // Prepend zeros.
			      for (zs = z + '.'; ++e; zs += z);
			      str = zs + str;

			      // Positive exponent
			    } else {
			      len = str.length;

			      // Append zeros.
			      if (++e > len) {
			        for (zs = z, e -= len; --e; zs += z);
			        str += zs;
			      } else if (e < len) {
			        str = str.slice(0, e) + '.' + str.slice(e);
			      }
			    }
			    return str;
			  }

			  // EXPORT

			  BigNumber = clone();
			  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

			  // AMD.
			  if (module.exports) {
			    module.exports = BigNumber;

			    // Browser.
			  } else {
			    if (!globalObject) {
			      globalObject = typeof self != 'undefined' && self ? self : window;
			    }
			    globalObject.BigNumber = BigNumber;
			  }
			})(bignumber); 
		} (bignumber$1));
		return bignumber$1.exports;
	}

	var hasRequiredAr;

	function requireAr () {
		if (hasRequiredAr) return ar$1;
		hasRequiredAr = 1;

		Object.defineProperty(ar$1, "__esModule", {
		  value: true
		});
		const bignumber_js_1 = requireBignumber();
		class Ar {
		  /**
		   * Method to take a string value and return a bignumber object.
		   *
		   * @protected
		   * @type {Function}
		   * @memberof Arweave
		   */
		  BigNum;
		  constructor() {
		    // Configure and assign the constructor function for the bignumber library.
		    this.BigNum = (value, decimals) => {
		      let instance = bignumber_js_1.BigNumber.clone({
		        DECIMAL_PLACES: decimals
		      });
		      return new instance(value);
		    };
		  }
		  winstonToAr(winstonString, {
		    formatted = false,
		    decimals = 12,
		    trim = true
		  } = {}) {
		    let number = this.stringToBigNum(winstonString, decimals).shiftedBy(-12);
		    return formatted ? number.toFormat(decimals) : number.toFixed(decimals);
		  }
		  arToWinston(arString, {
		    formatted = false
		  } = {}) {
		    let number = this.stringToBigNum(arString).shiftedBy(12);
		    return formatted ? number.toFormat() : number.toFixed(0);
		  }
		  compare(winstonStringA, winstonStringB) {
		    let a = this.stringToBigNum(winstonStringA);
		    let b = this.stringToBigNum(winstonStringB);
		    return a.comparedTo(b);
		  }
		  isEqual(winstonStringA, winstonStringB) {
		    return this.compare(winstonStringA, winstonStringB) === 0;
		  }
		  isLessThan(winstonStringA, winstonStringB) {
		    let a = this.stringToBigNum(winstonStringA);
		    let b = this.stringToBigNum(winstonStringB);
		    return a.isLessThan(b);
		  }
		  isGreaterThan(winstonStringA, winstonStringB) {
		    let a = this.stringToBigNum(winstonStringA);
		    let b = this.stringToBigNum(winstonStringB);
		    return a.isGreaterThan(b);
		  }
		  add(winstonStringA, winstonStringB) {
		    let a = this.stringToBigNum(winstonStringA);
		    this.stringToBigNum(winstonStringB);
		    return a.plus(winstonStringB).toFixed(0);
		  }
		  sub(winstonStringA, winstonStringB) {
		    let a = this.stringToBigNum(winstonStringA);
		    this.stringToBigNum(winstonStringB);
		    return a.minus(winstonStringB).toFixed(0);
		  }
		  stringToBigNum(stringValue, decimalPlaces = 12) {
		    return this.BigNum(stringValue, decimalPlaces);
		  }
		}
		ar$1.default = Ar;
		return ar$1;
	}

	var api = {};

	var hasRequiredApi;

	function requireApi () {
		if (hasRequiredApi) return api;
		hasRequiredApi = 1;

		Object.defineProperty(api, "__esModule", {
		  value: true
		});
		class Api {
		  METHOD_GET = "GET";
		  METHOD_POST = "POST";
		  config;
		  constructor(config) {
		    this.applyConfig(config);
		  }
		  applyConfig(config) {
		    this.config = this.mergeDefaults(config);
		  }
		  getConfig() {
		    return this.config;
		  }
		  mergeDefaults(config) {
		    const protocol = config.protocol || "http";
		    const port = config.port || (protocol === "https" ? 443 : 80);
		    return {
		      host: config.host || "127.0.0.1",
		      protocol,
		      port,
		      timeout: config.timeout || 20000,
		      logging: config.logging || false,
		      logger: config.logger || console.log,
		      network: config.network
		    };
		  }
		  async get(endpoint, config) {
		    return await this.request(endpoint, {
		      ...config,
		      method: this.METHOD_GET
		    });
		  }
		  async post(endpoint, body, config) {
		    const headers = new Headers(config?.headers || {});
		    if (!headers.get("content-type")?.includes("application/json")) {
		      headers.append("content-type", "application/json");
		    }
		    headers.append("accept", "application/json, text/plain, */*");
		    return await this.request(endpoint, {
		      ...config,
		      method: this.METHOD_POST,
		      body: typeof body !== "string" ? JSON.stringify(body) : body,
		      headers
		    });
		  }
		  async request(endpoint, init) {
		    const headers = new Headers(init?.headers || {});
		    const baseURL = `${this.config.protocol}://${this.config.host}:${this.config.port}`;
		    /* responseType is purely for backwards compatibility with external apps */
		    const responseType = init?.responseType;
		    delete init?.responseType;
		    if (endpoint.startsWith("/")) {
		      endpoint = endpoint.slice(1);
		    }
		    if (this.config.network) {
		      headers.append("x-network", this.config.network);
		    }
		    if (this.config.logging) {
		      this.config.logger(`Requesting: ${baseURL}/${endpoint}`);
		    }
		    let res = await fetch(`${baseURL}/${endpoint}`, {
		      ...(init || {}),
		      headers
		    });
		    if (this.config.logging) {
		      this.config.logger(`Response:   ${res.url} - ${res.status}`);
		    }
		    const contentType = res.headers.get("content-type");
		    const charset = contentType?.match(/charset=([^()<>@,;:\"/[\]?.=\s]*)/i)?.[1];
		    const response = res;
		    const decodeText = async () => {
		      if (charset) {
		        try {
		          response.data = new TextDecoder(charset).decode(await res.arrayBuffer());
		        } catch (e) {
		          response.data = await res.text();
		        }
		      } else {
		        response.data = await res.text();
		      }
		    };
		    if (responseType === "arraybuffer") {
		      response.data = await res.arrayBuffer();
		    } else if (responseType === "text") {
		      await decodeText();
		    } else if (responseType === "webstream") {
		      response.data = addAsyncIterator(res.body);
		    } else {
		      /** axios defaults to JSON, and then text, we mimic the behaviour */
		      try {
		        let test = await res.clone().json();
		        if (typeof test !== "object") {
		          await decodeText();
		        } else {
		          response.data = await res.json();
		        }
		        test = null;
		      } catch {
		        await decodeText();
		      }
		    }
		    return response;
		  }
		}
		api.default = Api;
		/**
		 * *** To be removed when browsers catch up with the whatwg standard. ***
		 * [Symbol.AsyncIterator] is needed to use `for-await` on the returned ReadableStream (web stream).
		 * Feature is available in nodejs, and should be available in browsers eventually.
		 */
		const addAsyncIterator = body => {
		  const bodyWithIter = body;
		  if (typeof bodyWithIter[Symbol.asyncIterator] === "undefined") {
		    bodyWithIter[Symbol.asyncIterator] = webIiterator(body);
		    return bodyWithIter;
		  }
		  return body;
		};
		const webIiterator = function (stream) {
		  return async function* iteratorGenerator() {
		    const reader = stream.getReader(); //lock
		    try {
		      while (true) {
		        const {
		          done,
		          value
		        } = await reader.read();
		        if (done) return;
		        yield value;
		      }
		    } finally {
		      reader.releaseLock(); //unlock
		    }
		  };
		};
		return api;
	}

	var webcryptoDriver = {};

	var utils = {};

	var hasRequiredUtils;

	function requireUtils () {
		if (hasRequiredUtils) return utils;
		hasRequiredUtils = 1;

		Object.defineProperty(utils, "__esModule", {
		  value: true
		});
		utils.b64UrlDecode = utils.b64UrlEncode = utils.bufferTob64Url = utils.bufferTob64 = utils.b64UrlToBuffer = utils.stringToB64Url = utils.stringToBuffer = utils.bufferToString = utils.b64UrlToString = utils.concatBuffers = void 0;
		const B64js = requireBase64Js();
		function concatBuffers(buffers) {
		  let total_length = 0;
		  for (let i = 0; i < buffers.length; i++) {
		    total_length += buffers[i].byteLength;
		  }
		  let temp = new Uint8Array(total_length);
		  let offset = 0;
		  temp.set(new Uint8Array(buffers[0]), offset);
		  offset += buffers[0].byteLength;
		  for (let i = 1; i < buffers.length; i++) {
		    temp.set(new Uint8Array(buffers[i]), offset);
		    offset += buffers[i].byteLength;
		  }
		  return temp;
		}
		utils.concatBuffers = concatBuffers;
		function b64UrlToString(b64UrlString) {
		  let buffer = b64UrlToBuffer(b64UrlString);
		  return bufferToString(buffer);
		}
		utils.b64UrlToString = b64UrlToString;
		function bufferToString(buffer) {
		  return new TextDecoder("utf-8", {
		    fatal: true
		  }).decode(buffer);
		}
		utils.bufferToString = bufferToString;
		function stringToBuffer(string) {
		  return new TextEncoder().encode(string);
		}
		utils.stringToBuffer = stringToBuffer;
		function stringToB64Url(string) {
		  return bufferTob64Url(stringToBuffer(string));
		}
		utils.stringToB64Url = stringToB64Url;
		function b64UrlToBuffer(b64UrlString) {
		  return new Uint8Array(B64js.toByteArray(b64UrlDecode(b64UrlString)));
		}
		utils.b64UrlToBuffer = b64UrlToBuffer;
		function bufferTob64(buffer) {
		  return B64js.fromByteArray(new Uint8Array(buffer));
		}
		utils.bufferTob64 = bufferTob64;
		function bufferTob64Url(buffer) {
		  return b64UrlEncode(bufferTob64(buffer));
		}
		utils.bufferTob64Url = bufferTob64Url;
		function b64UrlEncode(b64UrlString) {
		  try {
		    return b64UrlString.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
		  } catch (error) {
		    throw new Error("Failed to encode string", {
		      cause: error
		    });
		  }
		}
		utils.b64UrlEncode = b64UrlEncode;
		function b64UrlDecode(b64UrlString) {
		  try {
		    b64UrlString = b64UrlString.replace(/\-/g, "+").replace(/\_/g, "/");
		    let padding;
		    b64UrlString.length % 4 == 0 ? padding = 0 : padding = 4 - b64UrlString.length % 4;
		    return b64UrlString.concat("=".repeat(padding));
		  } catch (error) {
		    throw new Error("Failed to decode string", {
		      cause: error
		    });
		  }
		}
		utils.b64UrlDecode = b64UrlDecode;
		return utils;
	}

	var hasRequiredWebcryptoDriver;

	function requireWebcryptoDriver () {
		if (hasRequiredWebcryptoDriver) return webcryptoDriver;
		hasRequiredWebcryptoDriver = 1;

		Object.defineProperty(webcryptoDriver, "__esModule", {
		  value: true
		});
		const ArweaveUtils = requireUtils();
		class WebCryptoDriver {
		  keyLength = 4096;
		  publicExponent = 0x10001;
		  hashAlgorithm = "sha256";
		  driver;
		  constructor() {
		    if (!this.detectWebCrypto()) {
		      throw new Error("SubtleCrypto not available!");
		    }
		    this.driver = crypto.subtle;
		  }
		  async generateJWK() {
		    let cryptoKey = await this.driver.generateKey({
		      name: "RSA-PSS",
		      modulusLength: 4096,
		      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
		      hash: {
		        name: "SHA-256"
		      }
		    }, true, ["sign"]);
		    let jwk = await this.driver.exportKey("jwk", cryptoKey.privateKey);
		    return {
		      kty: jwk.kty,
		      e: jwk.e,
		      n: jwk.n,
		      d: jwk.d,
		      p: jwk.p,
		      q: jwk.q,
		      dp: jwk.dp,
		      dq: jwk.dq,
		      qi: jwk.qi
		    };
		  }
		  async sign(jwk, data, {
		    saltLength
		  } = {}) {
		    let signature = await this.driver.sign({
		      name: "RSA-PSS",
		      saltLength: 32
		    }, await this.jwkToCryptoKey(jwk), data);
		    return new Uint8Array(signature);
		  }
		  async hash(data, algorithm = "SHA-256") {
		    let digest = await this.driver.digest(algorithm, data);
		    return new Uint8Array(digest);
		  }
		  async verify(publicModulus, data, signature) {
		    const publicKey = {
		      kty: "RSA",
		      e: "AQAB",
		      n: publicModulus
		    };
		    const key = await this.jwkToPublicCryptoKey(publicKey);
		    const digest = await this.driver.digest("SHA-256", data);
		    const salt0 = await this.driver.verify({
		      name: "RSA-PSS",
		      saltLength: 0
		    }, key, signature, data);
		    const salt32 = await this.driver.verify({
		      name: "RSA-PSS",
		      saltLength: 32
		    }, key, signature, data);
		    // saltN's salt-length is derived from a formula described here
		    // https://developer.mozilla.org/en-US/docs/Web/API/RsaPssParams
		    const saltN = await this.driver.verify({
		      name: "RSA-PSS",
		      saltLength: Math.ceil((key.algorithm.modulusLength - 1) / 8) - digest.byteLength - 2
		    }, key, signature, data);
		    return salt0 || salt32 || saltN;
		  }
		  async jwkToCryptoKey(jwk) {
		    return this.driver.importKey("jwk", jwk, {
		      name: "RSA-PSS",
		      hash: {
		        name: "SHA-256"
		      }
		    }, false, ["sign"]);
		  }
		  async jwkToPublicCryptoKey(publicJwk) {
		    return this.driver.importKey("jwk", publicJwk, {
		      name: "RSA-PSS",
		      hash: {
		        name: "SHA-256"
		      }
		    }, false, ["verify"]);
		  }
		  detectWebCrypto() {
		    if (typeof crypto === "undefined") {
		      return false;
		    }
		    const subtle = crypto?.subtle;
		    if (subtle === undefined) {
		      return false;
		    }
		    const names = ["generateKey", "importKey", "exportKey", "digest", "sign"];
		    return names.every(name => typeof subtle[name] === "function");
		  }
		  async encrypt(data, key, salt) {
		    const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
		      name: "PBKDF2",
		      length: 32
		    }, false, ["deriveKey"]);
		    // const salt = ArweaveUtils.stringToBuffer("salt");
		    // create a random string for deriving the key
		    // const salt = this.driver.randomBytes(16).toString('hex');
		    const derivedkey = await this.driver.deriveKey({
		      name: "PBKDF2",
		      salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
		      iterations: 100000,
		      hash: "SHA-256"
		    }, initialKey, {
		      name: "AES-CBC",
		      length: 256
		    }, false, ["encrypt", "decrypt"]);
		    const iv = new Uint8Array(16);
		    crypto.getRandomValues(iv);
		    const encryptedData = await this.driver.encrypt({
		      name: "AES-CBC",
		      iv: iv
		    }, derivedkey, data);
		    return ArweaveUtils.concatBuffers([iv, encryptedData]);
		  }
		  async decrypt(encrypted, key, salt) {
		    const initialKey = await this.driver.importKey("raw", typeof key == "string" ? ArweaveUtils.stringToBuffer(key) : key, {
		      name: "PBKDF2",
		      length: 32
		    }, false, ["deriveKey"]);
		    // const salt = ArweaveUtils.stringToBuffer("pepper");
		    const derivedkey = await this.driver.deriveKey({
		      name: "PBKDF2",
		      salt: salt ? ArweaveUtils.stringToBuffer(salt) : ArweaveUtils.stringToBuffer("salt"),
		      iterations: 100000,
		      hash: "SHA-256"
		    }, initialKey, {
		      name: "AES-CBC",
		      length: 256
		    }, false, ["encrypt", "decrypt"]);
		    const iv = encrypted.slice(0, 16);
		    const data = await this.driver.decrypt({
		      name: "AES-CBC",
		      iv: iv
		    }, derivedkey, encrypted.slice(16));
		    // We're just using concat to convert from an array buffer to uint8array
		    return ArweaveUtils.concatBuffers([data]);
		  }
		}
		webcryptoDriver.default = WebCryptoDriver;
		return webcryptoDriver;
	}

	var network = {};

	var hasRequiredNetwork;

	function requireNetwork () {
		if (hasRequiredNetwork) return network;
		hasRequiredNetwork = 1;

		Object.defineProperty(network, "__esModule", {
		  value: true
		});
		class Network {
		  api;
		  constructor(api) {
		    this.api = api;
		  }
		  getInfo() {
		    return this.api.get(`info`).then(response => {
		      return response.data;
		    });
		  }
		  getPeers() {
		    return this.api.get(`peers`).then(response => {
		      return response.data;
		    });
		  }
		}
		network.default = Network;
		return network;
	}

	var transactions = {};

	var error = {};

	var hasRequiredError;

	function requireError () {
		if (hasRequiredError) return error;
		hasRequiredError = 1;

		Object.defineProperty(error, "__esModule", {
		  value: true
		});
		error.getError = void 0;
		class ArweaveError extends Error {
		  type;
		  response;
		  constructor(type, optional = {}) {
		    if (optional.message) {
		      super(optional.message);
		    } else {
		      super();
		    }
		    this.type = type;
		    this.response = optional.response;
		  }
		  getType() {
		    return this.type;
		  }
		}
		error.default = ArweaveError;
		// Safely get error string
		// from a response, falling back to
		// resp.data, statusText or 'unknown'.
		// Note: a wrongly set content-type can
		// cause what is a json response to be interepted
		// as a string or Buffer, so we handle that too.
		function getError(resp) {
		  let data = resp.data;
		  if (typeof resp.data === "string") {
		    try {
		      data = JSON.parse(resp.data);
		    } catch (e) {}
		  }
		  if (resp.data instanceof ArrayBuffer || resp.data instanceof Uint8Array) {
		    try {
		      data = JSON.parse(data.toString());
		    } catch (e) {}
		  }
		  return data ? data.error || data : resp.statusText || "unknown";
		}
		error.getError = getError;
		return error;
	}

	var transaction = {};

	var deepHash = {};

	var hasRequiredDeepHash;

	function requireDeepHash () {
		if (hasRequiredDeepHash) return deepHash;
		hasRequiredDeepHash = 1;

		Object.defineProperty(deepHash, "__esModule", {
		  value: true
		});
		const common_1 = requireCommon();
		async function deepHash$1(data) {
		  if (Array.isArray(data)) {
		    const tag = common_1.default.utils.concatBuffers([common_1.default.utils.stringToBuffer("list"), common_1.default.utils.stringToBuffer(data.length.toString())]);
		    return await deepHashChunks(data, await common_1.default.crypto.hash(tag, "SHA-384"));
		  }
		  const tag = common_1.default.utils.concatBuffers([common_1.default.utils.stringToBuffer("blob"), common_1.default.utils.stringToBuffer(data.byteLength.toString())]);
		  const taggedHash = common_1.default.utils.concatBuffers([await common_1.default.crypto.hash(tag, "SHA-384"), await common_1.default.crypto.hash(data, "SHA-384")]);
		  return await common_1.default.crypto.hash(taggedHash, "SHA-384");
		}
		deepHash.default = deepHash$1;
		async function deepHashChunks(chunks, acc) {
		  if (chunks.length < 1) {
		    return acc;
		  }
		  const hashPair = common_1.default.utils.concatBuffers([acc, await deepHash$1(chunks[0])]);
		  const newAcc = await common_1.default.crypto.hash(hashPair, "SHA-384");
		  return await deepHashChunks(chunks.slice(1), newAcc);
		}
		return deepHash;
	}

	var merkle = {};

	var hasRequiredMerkle;

	function requireMerkle () {
		if (hasRequiredMerkle) return merkle;
		hasRequiredMerkle = 1;
		(function (exports) {

			Object.defineProperty(exports, "__esModule", {
			  value: true
			});
			exports.debug = exports.validatePath = exports.arrayCompare = exports.bufferToInt = exports.intToBuffer = exports.arrayFlatten = exports.generateProofs = exports.buildLayers = exports.generateTransactionChunks = exports.generateTree = exports.computeRootHash = exports.generateLeaves = exports.chunkData = exports.MIN_CHUNK_SIZE = exports.MAX_CHUNK_SIZE = void 0;
			/**
			 * @see {@link https://github.com/ArweaveTeam/arweave/blob/fbc381e0e36efffa45d13f2faa6199d3766edaa2/apps/arweave/src/ar_merkle.erl}
			 */
			const common_1 = requireCommon();
			const utils_1 = requireUtils();
			exports.MAX_CHUNK_SIZE = 256 * 1024;
			exports.MIN_CHUNK_SIZE = 32 * 1024;
			const NOTE_SIZE = 32;
			const HASH_SIZE = 32;
			/**
			 * Takes the input data and chunks it into (mostly) equal sized chunks.
			 * The last chunk will be a bit smaller as it contains the remainder
			 * from the chunking process.
			 */
			async function chunkData(data) {
			  let chunks = [];
			  let rest = data;
			  let cursor = 0;
			  while (rest.byteLength >= exports.MAX_CHUNK_SIZE) {
			    let chunkSize = exports.MAX_CHUNK_SIZE;
			    // If the total bytes left will produce a chunk < MIN_CHUNK_SIZE,
			    // then adjust the amount we put in this 2nd last chunk.
			    let nextChunkSize = rest.byteLength - exports.MAX_CHUNK_SIZE;
			    if (nextChunkSize > 0 && nextChunkSize < exports.MIN_CHUNK_SIZE) {
			      chunkSize = Math.ceil(rest.byteLength / 2);
			      // console.log(`Last chunk will be: ${nextChunkSize} which is below ${MIN_CHUNK_SIZE}, adjusting current to ${chunkSize} with ${rest.byteLength} left.`)
			    }
			    const chunk = rest.slice(0, chunkSize);
			    const dataHash = await common_1.default.crypto.hash(chunk);
			    cursor += chunk.byteLength;
			    chunks.push({
			      dataHash,
			      minByteRange: cursor - chunk.byteLength,
			      maxByteRange: cursor
			    });
			    rest = rest.slice(chunkSize);
			  }
			  chunks.push({
			    dataHash: await common_1.default.crypto.hash(rest),
			    minByteRange: cursor,
			    maxByteRange: cursor + rest.byteLength
			  });
			  return chunks;
			}
			exports.chunkData = chunkData;
			async function generateLeaves(chunks) {
			  return Promise.all(chunks.map(async ({
			    dataHash,
			    minByteRange,
			    maxByteRange
			  }) => {
			    return {
			      type: "leaf",
			      id: await hash(await Promise.all([hash(dataHash), hash(intToBuffer(maxByteRange))])),
			      dataHash: dataHash,
			      minByteRange,
			      maxByteRange
			    };
			  }));
			}
			exports.generateLeaves = generateLeaves;
			/**
			 * Builds an arweave merkle tree and gets the root hash for the given input.
			 */
			async function computeRootHash(data) {
			  const rootNode = await generateTree(data);
			  return rootNode.id;
			}
			exports.computeRootHash = computeRootHash;
			async function generateTree(data) {
			  const rootNode = await buildLayers(await generateLeaves(await chunkData(data)));
			  return rootNode;
			}
			exports.generateTree = generateTree;
			/**
			 * Generates the data_root, chunks & proofs
			 * needed for a transaction.
			 *
			 * This also checks if the last chunk is a zero-length
			 * chunk and discards that chunk and proof if so.
			 * (we do not need to upload this zero length chunk)
			 *
			 * @param data
			 */
			async function generateTransactionChunks(data) {
			  const chunks = await chunkData(data);
			  const leaves = await generateLeaves(chunks);
			  const root = await buildLayers(leaves);
			  const proofs = await generateProofs(root);
			  // Discard the last chunk & proof if it's zero length.
			  const lastChunk = chunks.slice(-1)[0];
			  if (lastChunk.maxByteRange - lastChunk.minByteRange === 0) {
			    chunks.splice(chunks.length - 1, 1);
			    proofs.splice(proofs.length - 1, 1);
			  }
			  return {
			    data_root: root.id,
			    chunks,
			    proofs
			  };
			}
			exports.generateTransactionChunks = generateTransactionChunks;
			/**
			 * Starting with the bottom layer of leaf nodes, hash every second pair
			 * into a new branch node, push those branch nodes onto a new layer,
			 * and then recurse, building up the tree to it's root, where the
			 * layer only consists of two items.
			 */
			async function buildLayers(nodes, level = 0) {
			  // If there is only 1 node left, this is going to be the root node
			  if (nodes.length < 2) {
			    const root = nodes[0];
			    // console.log("Root layer", root);
			    return root;
			  }
			  const nextLayer = [];
			  for (let i = 0; i < nodes.length; i += 2) {
			    nextLayer.push(await hashBranch(nodes[i], nodes[i + 1]));
			  }
			  // console.log("Layer", nextLayer);
			  return buildLayers(nextLayer, level + 1);
			}
			exports.buildLayers = buildLayers;
			/**
			 * Recursively search through all branches of the tree,
			 * and generate a proof for each leaf node.
			 */
			function generateProofs(root) {
			  const proofs = resolveBranchProofs(root);
			  if (!Array.isArray(proofs)) {
			    return [proofs];
			  }
			  return arrayFlatten(proofs);
			}
			exports.generateProofs = generateProofs;
			function resolveBranchProofs(node, proof = new Uint8Array(), depth = 0) {
			  if (node.type == "leaf") {
			    return {
			      offset: node.maxByteRange - 1,
			      proof: (0, utils_1.concatBuffers)([proof, node.dataHash, intToBuffer(node.maxByteRange)])
			    };
			  }
			  if (node.type == "branch") {
			    const partialProof = (0, utils_1.concatBuffers)([proof, node.leftChild.id, node.rightChild.id, intToBuffer(node.byteRange)]);
			    return [resolveBranchProofs(node.leftChild, partialProof, depth + 1), resolveBranchProofs(node.rightChild, partialProof, depth + 1)];
			  }
			  throw new Error(`Unexpected node type`);
			}
			function arrayFlatten(input) {
			  const flat = [];
			  input.forEach(item => {
			    if (Array.isArray(item)) {
			      flat.push(...arrayFlatten(item));
			    } else {
			      flat.push(item);
			    }
			  });
			  return flat;
			}
			exports.arrayFlatten = arrayFlatten;
			async function hashBranch(left, right) {
			  if (!right) {
			    return left;
			  }
			  let branch = {
			    type: "branch",
			    id: await hash([await hash(left.id), await hash(right.id), await hash(intToBuffer(left.maxByteRange))]),
			    byteRange: left.maxByteRange,
			    maxByteRange: right.maxByteRange,
			    leftChild: left,
			    rightChild: right
			  };
			  return branch;
			}
			async function hash(data) {
			  if (Array.isArray(data)) {
			    data = common_1.default.utils.concatBuffers(data);
			  }
			  return new Uint8Array(await common_1.default.crypto.hash(data));
			}
			function intToBuffer(note) {
			  const buffer = new Uint8Array(NOTE_SIZE);
			  for (var i = buffer.length - 1; i >= 0; i--) {
			    var byte = note % 256;
			    buffer[i] = byte;
			    note = (note - byte) / 256;
			  }
			  return buffer;
			}
			exports.intToBuffer = intToBuffer;
			function bufferToInt(buffer) {
			  let value = 0;
			  for (var i = 0; i < buffer.length; i++) {
			    value *= 256;
			    value += buffer[i];
			  }
			  return value;
			}
			exports.bufferToInt = bufferToInt;
			const arrayCompare = (a, b) => a.every((value, index) => b[index] === value);
			exports.arrayCompare = arrayCompare;
			async function validatePath(id, dest, leftBound, rightBound, path) {
			  if (rightBound <= 0) {
			    return false;
			  }
			  if (dest >= rightBound) {
			    return validatePath(id, 0, rightBound - 1, rightBound, path);
			  }
			  if (dest < 0) {
			    return validatePath(id, 0, 0, rightBound, path);
			  }
			  if (path.length == HASH_SIZE + NOTE_SIZE) {
			    const pathData = path.slice(0, HASH_SIZE);
			    const endOffsetBuffer = path.slice(pathData.length, pathData.length + NOTE_SIZE);
			    const pathDataHash = await hash([await hash(pathData), await hash(endOffsetBuffer)]);
			    let result = (0, exports.arrayCompare)(id, pathDataHash);
			    if (result) {
			      return {
			        offset: rightBound - 1,
			        leftBound: leftBound,
			        rightBound: rightBound,
			        chunkSize: rightBound - leftBound
			      };
			    }
			    return false;
			  }
			  const left = path.slice(0, HASH_SIZE);
			  const right = path.slice(left.length, left.length + HASH_SIZE);
			  const offsetBuffer = path.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
			  const offset = bufferToInt(offsetBuffer);
			  const remainder = path.slice(left.length + right.length + offsetBuffer.length);
			  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);
			  if ((0, exports.arrayCompare)(id, pathHash)) {
			    if (dest < offset) {
			      return await validatePath(left, dest, leftBound, Math.min(rightBound, offset), remainder);
			    }
			    return await validatePath(right, dest, Math.max(leftBound, offset), rightBound, remainder);
			  }
			  return false;
			}
			exports.validatePath = validatePath;
			/**
			 * Inspect an arweave chunk proof.
			 * Takes proof, parses, reads and displays the values for console logging.
			 * One proof section per line
			 * Format: left,right,offset => hash
			 */
			async function debug(proof, output = "") {
			  if (proof.byteLength < 1) {
			    return output;
			  }
			  const left = proof.slice(0, HASH_SIZE);
			  const right = proof.slice(left.length, left.length + HASH_SIZE);
			  const offsetBuffer = proof.slice(left.length + right.length, left.length + right.length + NOTE_SIZE);
			  const offset = bufferToInt(offsetBuffer);
			  const remainder = proof.slice(left.length + right.length + offsetBuffer.length);
			  const pathHash = await hash([await hash(left), await hash(right), await hash(offsetBuffer)]);
			  const updatedOutput = `${output}\n${JSON.stringify(bufferExports.Buffer.from(left))},${JSON.stringify(bufferExports.Buffer.from(right))},${offset} => ${JSON.stringify(pathHash)}`;
			  return debug(remainder, updatedOutput);
			}
			exports.debug = debug; 
		} (merkle));
		return merkle;
	}

	var hasRequiredTransaction;

	function requireTransaction () {
		if (hasRequiredTransaction) return transaction;
		hasRequiredTransaction = 1;

		Object.defineProperty(transaction, "__esModule", {
		  value: true
		});
		transaction.Tag = void 0;
		const ArweaveUtils = requireUtils();
		const deepHash_1 = requireDeepHash();
		const merkle_1 = requireMerkle();
		class BaseObject {
		  get(field, options) {
		    if (!Object.getOwnPropertyNames(this).includes(field)) {
		      throw new Error(`Field "${field}" is not a property of the Arweave Transaction class.`);
		    }
		    // Handle fields that are Uint8Arrays.
		    // To maintain compat we encode them to b64url
		    // if decode option is not specificed.
		    if (this[field] instanceof Uint8Array) {
		      if (options && options.decode && options.string) {
		        return ArweaveUtils.bufferToString(this[field]);
		      }
		      if (options && options.decode && !options.string) {
		        return this[field];
		      }
		      return ArweaveUtils.bufferTob64Url(this[field]);
		    }
		    if (this[field] instanceof Array) {
		      if (options?.decode !== undefined || options?.string !== undefined) {
		        if (field === "tags") {
		          console.warn(`Did you mean to use 'transaction["tags"]' ?`);
		        }
		        throw new Error(`Cannot decode or stringify an array.`);
		      }
		      return this[field];
		    }
		    if (options && options.decode == true) {
		      if (options && options.string) {
		        return ArweaveUtils.b64UrlToString(this[field]);
		      }
		      return ArweaveUtils.b64UrlToBuffer(this[field]);
		    }
		    return this[field];
		  }
		}
		class Tag extends BaseObject {
		  name;
		  value;
		  constructor(name, value, decode = false) {
		    super();
		    this.name = name;
		    this.value = value;
		  }
		}
		transaction.Tag = Tag;
		class Transaction extends BaseObject {
		  format = 2;
		  id = "";
		  last_tx = "";
		  owner = "";
		  tags = [];
		  target = "";
		  quantity = "0";
		  data_size = "0";
		  data = new Uint8Array();
		  data_root = "";
		  reward = "0";
		  signature = "";
		  // Computed when needed.
		  chunks;
		  constructor(attributes = {}) {
		    super();
		    Object.assign(this, attributes);
		    // If something passes in a Tx that has been toJSON'ed and back,
		    // or where the data was filled in from /tx/data endpoint.
		    // data will be b64url encoded, so decode it.
		    if (typeof this.data === "string") {
		      this.data = ArweaveUtils.b64UrlToBuffer(this.data);
		    }
		    if (attributes.tags) {
		      this.tags = attributes.tags.map(tag => {
		        return new Tag(tag.name, tag.value);
		      });
		    }
		  }
		  addTag(name, value) {
		    this.tags.push(new Tag(ArweaveUtils.stringToB64Url(name), ArweaveUtils.stringToB64Url(value)));
		  }
		  toJSON() {
		    return {
		      format: this.format,
		      id: this.id,
		      last_tx: this.last_tx,
		      owner: this.owner,
		      tags: this.tags,
		      target: this.target,
		      quantity: this.quantity,
		      data: ArweaveUtils.bufferTob64Url(this.data),
		      data_size: this.data_size,
		      data_root: this.data_root,
		      data_tree: this.data_tree,
		      reward: this.reward,
		      signature: this.signature
		    };
		  }
		  setOwner(owner) {
		    this.owner = owner;
		  }
		  setSignature({
		    id,
		    owner,
		    reward,
		    tags,
		    signature
		  }) {
		    this.id = id;
		    this.owner = owner;
		    if (reward) this.reward = reward;
		    if (tags) this.tags = tags;
		    this.signature = signature;
		  }
		  async prepareChunks(data) {
		    // Note: we *do not* use `this.data`, the caller may be
		    // operating on a transaction with an zero length data field.
		    // This function computes the chunks for the data passed in and
		    // assigns the result to this transaction. It should not read the
		    // data *from* this transaction.
		    if (!this.chunks && data.byteLength > 0) {
		      this.chunks = await (0, merkle_1.generateTransactionChunks)(data);
		      this.data_root = ArweaveUtils.bufferTob64Url(this.chunks.data_root);
		    }
		    if (!this.chunks && data.byteLength === 0) {
		      this.chunks = {
		        chunks: [],
		        data_root: new Uint8Array(),
		        proofs: []
		      };
		      this.data_root = "";
		    }
		  }
		  // Returns a chunk in a format suitable for posting to /chunk.
		  // Similar to `prepareChunks()` this does not operate `this.data`,
		  // instead using the data passed in.
		  getChunk(idx, data) {
		    if (!this.chunks) {
		      throw new Error(`Chunks have not been prepared`);
		    }
		    const proof = this.chunks.proofs[idx];
		    const chunk = this.chunks.chunks[idx];
		    return {
		      data_root: this.data_root,
		      data_size: this.data_size,
		      data_path: ArweaveUtils.bufferTob64Url(proof.proof),
		      offset: proof.offset.toString(),
		      chunk: ArweaveUtils.bufferTob64Url(data.slice(chunk.minByteRange, chunk.maxByteRange))
		    };
		  }
		  async getSignatureData() {
		    switch (this.format) {
		      case 1:
		        let tags = this.tags.reduce((accumulator, tag) => {
		          return ArweaveUtils.concatBuffers([accumulator, tag.get("name", {
		            decode: true,
		            string: false
		          }), tag.get("value", {
		            decode: true,
		            string: false
		          })]);
		        }, new Uint8Array());
		        return ArweaveUtils.concatBuffers([this.get("owner", {
		          decode: true,
		          string: false
		        }), this.get("target", {
		          decode: true,
		          string: false
		        }), this.get("data", {
		          decode: true,
		          string: false
		        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get("last_tx", {
		          decode: true,
		          string: false
		        }), tags]);
		      case 2:
		        if (!this.data_root) {
		          await this.prepareChunks(this.data);
		        }
		        const tagList = this.tags.map(tag => [tag.get("name", {
		          decode: true,
		          string: false
		        }), tag.get("value", {
		          decode: true,
		          string: false
		        })]);
		        return await (0, deepHash_1.default)([ArweaveUtils.stringToBuffer(this.format.toString()), this.get("owner", {
		          decode: true,
		          string: false
		        }), this.get("target", {
		          decode: true,
		          string: false
		        }), ArweaveUtils.stringToBuffer(this.quantity), ArweaveUtils.stringToBuffer(this.reward), this.get("last_tx", {
		          decode: true,
		          string: false
		        }), tagList, ArweaveUtils.stringToBuffer(this.data_size), this.get("data_root", {
		          decode: true,
		          string: false
		        })]);
		      default:
		        throw new Error(`Unexpected transaction format: ${this.format}`);
		    }
		  }
		}
		transaction.default = Transaction;
		return transaction;
	}

	var transactionUploader = {};

	var hasRequiredTransactionUploader;

	function requireTransactionUploader () {
		if (hasRequiredTransactionUploader) return transactionUploader;
		hasRequiredTransactionUploader = 1;

		Object.defineProperty(transactionUploader, "__esModule", {
		  value: true
		});
		transactionUploader.TransactionUploader = void 0;
		const transaction_1 = requireTransaction();
		const ArweaveUtils = requireUtils();
		const error_1 = requireError();
		const merkle_1 = requireMerkle();
		// Maximum amount of chunks we will upload in the body.
		const MAX_CHUNKS_IN_BODY = 1;
		// We assume these errors are intermitment and we can try again after a delay:
		// - not_joined
		// - timeout
		// - data_root_not_found (we may have hit a node that just hasn't seen it yet)
		// - exceeds_disk_pool_size_limit
		// We also try again after any kind of unexpected network errors
		// Errors from /chunk we should never try and continue on.
		const FATAL_CHUNK_UPLOAD_ERRORS = ["invalid_json", "chunk_too_big", "data_path_too_big", "offset_too_big", "data_size_too_big", "chunk_proof_ratio_not_attractive", "invalid_proof"];
		// Amount we will delay on receiving an error response but do want to continue.
		const ERROR_DELAY = 1000 * 40;
		class TransactionUploader {
		  api;
		  chunkIndex = 0;
		  txPosted = false;
		  transaction;
		  lastRequestTimeEnd = 0;
		  totalErrors = 0; // Not serialized.
		  data;
		  lastResponseStatus = 0;
		  lastResponseError = "";
		  get isComplete() {
		    return this.txPosted && this.chunkIndex === this.transaction.chunks.chunks.length;
		  }
		  get totalChunks() {
		    return this.transaction.chunks.chunks.length;
		  }
		  get uploadedChunks() {
		    return this.chunkIndex;
		  }
		  get pctComplete() {
		    return Math.trunc(this.uploadedChunks / this.totalChunks * 100);
		  }
		  constructor(api, transaction) {
		    this.api = api;
		    if (!transaction.id) {
		      throw new Error(`Transaction is not signed`);
		    }
		    if (!transaction.chunks) {
		      throw new Error(`Transaction chunks not prepared`);
		    }
		    // Make a copy of transaction, zeroing the data so we can serialize.
		    this.data = transaction.data;
		    this.transaction = new transaction_1.default(Object.assign({}, transaction, {
		      data: new Uint8Array(0)
		    }));
		  }
		  /**
		   * Uploads the next part of the transaction.
		   * On the first call this posts the transaction
		   * itself and on any subsequent calls uploads the
		   * next chunk until it completes.
		   */
		  async uploadChunk(chunkIndex_) {
		    if (this.isComplete) {
		      throw new Error(`Upload is already complete`);
		    }
		    if (this.lastResponseError !== "") {
		      this.totalErrors++;
		    } else {
		      this.totalErrors = 0;
		    }
		    // We have been trying for about an hour receiving an
		    // error every time, so eventually bail.
		    if (this.totalErrors === 100) {
		      throw new Error(`Unable to complete upload: ${this.lastResponseStatus}: ${this.lastResponseError}`);
		    }
		    let delay = this.lastResponseError === "" ? 0 : Math.max(this.lastRequestTimeEnd + ERROR_DELAY - Date.now(), ERROR_DELAY);
		    if (delay > 0) {
		      // Jitter delay bcoz networks, subtract up to 30% from 40 seconds
		      delay = delay - delay * Math.random() * 0.3;
		      await new Promise(res => setTimeout(res, delay));
		    }
		    this.lastResponseError = "";
		    if (!this.txPosted) {
		      await this.postTransaction();
		      return;
		    }
		    if (chunkIndex_) {
		      this.chunkIndex = chunkIndex_;
		    }
		    const chunk = this.transaction.getChunk(chunkIndex_ || this.chunkIndex, this.data);
		    const chunkOk = await (0, merkle_1.validatePath)(this.transaction.chunks.data_root, parseInt(chunk.offset), 0, parseInt(chunk.data_size), ArweaveUtils.b64UrlToBuffer(chunk.data_path));
		    if (!chunkOk) {
		      throw new Error(`Unable to validate chunk ${this.chunkIndex}`);
		    }
		    // Catch network errors and turn them into objects with status -1 and an error message.
		    const resp = await this.api.post(`chunk`, this.transaction.getChunk(this.chunkIndex, this.data)).catch(e => {
		      console.error(e.message);
		      return {
		        status: -1,
		        data: {
		          error: e.message
		        }
		      };
		    });
		    this.lastRequestTimeEnd = Date.now();
		    this.lastResponseStatus = resp.status;
		    if (this.lastResponseStatus == 200) {
		      this.chunkIndex++;
		    } else {
		      this.lastResponseError = (0, error_1.getError)(resp);
		      if (FATAL_CHUNK_UPLOAD_ERRORS.includes(this.lastResponseError)) {
		        throw new Error(`Fatal error uploading chunk ${this.chunkIndex}: ${this.lastResponseError}`);
		      }
		    }
		  }
		  /**
		   * Reconstructs an upload from its serialized state and data.
		   * Checks if data matches the expected data_root.
		   *
		   * @param serialized
		   * @param data
		   */
		  static async fromSerialized(api, serialized, data) {
		    if (!serialized || typeof serialized.chunkIndex !== "number" || typeof serialized.transaction !== "object") {
		      throw new Error(`Serialized object does not match expected format.`);
		    }
		    // Everything looks ok, reconstruct the TransactionUpload,
		    // prepare the chunks again and verify the data_root matches
		    var transaction = new transaction_1.default(serialized.transaction);
		    if (!transaction.chunks) {
		      await transaction.prepareChunks(data);
		    }
		    const upload = new TransactionUploader(api, transaction);
		    // Copy the serialized upload information, and data passed in.
		    upload.chunkIndex = serialized.chunkIndex;
		    upload.lastRequestTimeEnd = serialized.lastRequestTimeEnd;
		    upload.lastResponseError = serialized.lastResponseError;
		    upload.lastResponseStatus = serialized.lastResponseStatus;
		    upload.txPosted = serialized.txPosted;
		    upload.data = data;
		    if (upload.transaction.data_root !== serialized.transaction.data_root) {
		      throw new Error(`Data mismatch: Uploader doesn't match provided data.`);
		    }
		    return upload;
		  }
		  /**
		   * Reconstruct an upload from the tx metadata, ie /tx/<id>.
		   *
		   * @param api
		   * @param id
		   * @param data
		   */
		  static async fromTransactionId(api, id) {
		    const resp = await api.get(`tx/${id}`);
		    if (resp.status !== 200) {
		      throw new Error(`Tx ${id} not found: ${resp.status}`);
		    }
		    const transaction = resp.data;
		    transaction.data = new Uint8Array(0);
		    const serialized = {
		      txPosted: true,
		      chunkIndex: 0,
		      lastResponseError: "",
		      lastRequestTimeEnd: 0,
		      lastResponseStatus: 0,
		      transaction
		    };
		    return serialized;
		  }
		  toJSON() {
		    return {
		      chunkIndex: this.chunkIndex,
		      transaction: this.transaction,
		      lastRequestTimeEnd: this.lastRequestTimeEnd,
		      lastResponseStatus: this.lastResponseStatus,
		      lastResponseError: this.lastResponseError,
		      txPosted: this.txPosted
		    };
		  }
		  // POST to /tx
		  async postTransaction() {
		    const uploadInBody = this.totalChunks <= MAX_CHUNKS_IN_BODY;
		    if (uploadInBody) {
		      // Post the transaction with data.
		      this.transaction.data = this.data;
		      const resp = await this.api.post(`tx`, this.transaction).catch(e => {
		        console.error(e);
		        return {
		          status: -1,
		          data: {
		            error: e.message
		          }
		        };
		      });
		      this.lastRequestTimeEnd = Date.now();
		      this.lastResponseStatus = resp.status;
		      this.transaction.data = new Uint8Array(0);
		      if (resp.status >= 200 && resp.status < 300) {
		        // We are complete.
		        this.txPosted = true;
		        this.chunkIndex = MAX_CHUNKS_IN_BODY;
		        return;
		      }
		      this.lastResponseError = (0, error_1.getError)(resp);
		      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
		    }
		    // Post the transaction with no data.
		    const resp = await this.api.post(`tx`, this.transaction);
		    this.lastRequestTimeEnd = Date.now();
		    this.lastResponseStatus = resp.status;
		    if (!(resp.status >= 200 && resp.status < 300)) {
		      this.lastResponseError = (0, error_1.getError)(resp);
		      throw new Error(`Unable to upload transaction: ${resp.status}, ${this.lastResponseError}`);
		    }
		    this.txPosted = true;
		  }
		}
		transactionUploader.TransactionUploader = TransactionUploader;
		return transactionUploader;
	}

	var hasRequiredTransactions;

	function requireTransactions () {
		if (hasRequiredTransactions) return transactions;
		hasRequiredTransactions = 1;

		Object.defineProperty(transactions, "__esModule", {
		  value: true
		});
		const error_1 = requireError();
		const transaction_1 = requireTransaction();
		const ArweaveUtils = requireUtils();
		const transaction_uploader_1 = requireTransactionUploader();

		class Transactions {
		  api;
		  crypto;
		  chunks;
		  constructor(api, crypto, chunks) {
		    this.api = api;
		    this.crypto = crypto;
		    this.chunks = chunks;
		  }
		  async getTransactionAnchor() {
		    const res = await this.api.get(`tx_anchor`);
		    if (!res.data.match(/^[a-z0-9_-]{43,}/i) || !res.ok) {
		      throw new Error(`Could not getTransactionAnchor. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);
		    }
		    return res.data;
		  }
		  async getPrice(byteSize, targetAddress) {
		    let endpoint = targetAddress ? `price/${byteSize}/${targetAddress}` : `price/${byteSize}`;
		    const res = await this.api.get(endpoint);
		    if (!/^\d+$/.test(res.data) || !res.ok) {
		      throw new Error(`Could not getPrice. Received: ${res.data}. Status: ${res.status}, ${res.statusText}`);
		    }
		    return res.data;
		  }
		  async get(id) {
		    const response = await this.api.get(`tx/${id}`);
		    if (response.status == 200) {
		      const data_size = parseInt(response.data.data_size);
		      if (response.data.format >= 2 && data_size > 0 && data_size <= 1024 * 1024 * 12) {
		        const data = await this.getData(id);
		        return new transaction_1.default({
		          ...response.data,
		          data
		        });
		      }
		      return new transaction_1.default({
		        ...response.data,
		        format: response.data.format || 1
		      });
		    }
		    if (response.status == 404) {
		      throw new error_1.default("TX_NOT_FOUND" /* ArweaveErrorType.TX_NOT_FOUND */);
		    }
		    if (response.status == 410) {
		      throw new error_1.default("TX_FAILED" /* ArweaveErrorType.TX_FAILED */);
		    }
		    throw new error_1.default("TX_INVALID" /* ArweaveErrorType.TX_INVALID */);
		  }
		  fromRaw(attributes) {
		    return new transaction_1.default(attributes);
		  }
		  async search(tagName, tagValue) {
		    return this.api.post(`arql`, {
		      op: "equals",
		      expr1: tagName,
		      expr2: tagValue
		    }).then(response => {
		      if (!response.data) {
		        return [];
		      }
		      return response.data;
		    });
		  }
		  getStatus(id) {
		    return this.api.get(`tx/${id}/status`).then(response => {
		      if (response.status == 200) {
		        return {
		          status: 200,
		          confirmed: response.data
		        };
		      }
		      return {
		        status: response.status,
		        confirmed: null
		      };
		    });
		  }
		  async getData(id, options) {
		    let data = undefined;
		    try {
		      data = await this.chunks.downloadChunkedData(id);
		    } catch (error) {
		      console.error(`Error while trying to download chunked data for ${id}`);
		      console.error(error);
		    }
		    if (!data) {
		      console.warn(`Falling back to gateway cache for ${id}`);
		      try {
		        const {
		          data: resData,
		          ok,
		          status,
		          statusText
		        } = await this.api.get(`/${id}`, {
		          responseType: "arraybuffer"
		        });
		        if (!ok) {
		          throw new Error(`Bad http status code`, {
		            cause: {
		              status,
		              statusText
		            }
		          });
		        }
		        data = resData;
		      } catch (error) {
		        console.error(`Error while trying to download contiguous data from gateway cache for ${id}`);
		        console.error(error);
		      }
		    }
		    if (!data) {
		      throw new Error(`${id} data was not found!`);
		    }
		    if (options && options.decode && !options.string) {
		      return data;
		    }
		    if (options && options.decode && options.string) {
		      return ArweaveUtils.bufferToString(data);
		    }
		    // Since decode wasn't requested, caller expects b64url encoded data.
		    return ArweaveUtils.bufferTob64Url(data);
		  }
		  async sign(transaction, jwk,
		  //"use_wallet" for backwards compatibility only
		  options) {
		    /** Non-exhaustive (only checks key names), but previously no jwk checking was done */
		    const isJwk = obj => {
		      let valid = true;
		      ["n", "e", "d", "p", "q", "dp", "dq", "qi"].map(key => !(key in obj) && (valid = false));
		      return valid;
		    };
		    const validJwk = typeof jwk === "object" && isJwk(jwk);
		    const externalWallet = typeof arweaveWallet === "object";
		    if (!validJwk && !externalWallet) {
		      throw new Error(`No valid JWK or external wallet found to sign transaction.`);
		    } else if (validJwk) {
		      transaction.setOwner(jwk.n);
		      let dataToSign = await transaction.getSignatureData();
		      let rawSignature = await this.crypto.sign(jwk, dataToSign, options);
		      let id = await this.crypto.hash(rawSignature);
		      transaction.setSignature({
		        id: ArweaveUtils.bufferTob64Url(id),
		        owner: jwk.n,
		        signature: ArweaveUtils.bufferTob64Url(rawSignature)
		      });
		    } else if (externalWallet) {
		      try {
		        const existingPermissions = await arweaveWallet.getPermissions();
		        if (!existingPermissions.includes("SIGN_TRANSACTION")) await arweaveWallet.connect(["SIGN_TRANSACTION"]);
		      } catch {
		        // Permission is already granted
		      }
		      const signedTransaction = await arweaveWallet.sign(transaction, options);
		      transaction.setSignature({
		        id: signedTransaction.id,
		        owner: signedTransaction.owner,
		        reward: signedTransaction.reward,
		        tags: signedTransaction.tags,
		        signature: signedTransaction.signature
		      });
		    } else {
		      //can't get here, but for sanity we'll throw an error.
		      throw new Error(`An error occurred while signing. Check wallet is valid`);
		    }
		  }
		  async verify(transaction) {
		    const signaturePayload = await transaction.getSignatureData();
		    /**
		     * The transaction ID should be a SHA-256 hash of the raw signature bytes, so this needs
		     * to be recalculated from the signature and checked against the transaction ID.
		     */
		    const rawSignature = transaction.get("signature", {
		      decode: true,
		      string: false
		    });
		    const expectedId = ArweaveUtils.bufferTob64Url(await this.crypto.hash(rawSignature));
		    if (transaction.id !== expectedId) {
		      throw new Error(`Invalid transaction signature or ID! The transaction ID doesn't match the expected SHA-256 hash of the signature.`);
		    }
		    /**
		     * Now verify the signature is valid and signed by the owner wallet (owner field = originating wallet public key).
		     */
		    return this.crypto.verify(transaction.owner, signaturePayload, rawSignature);
		  }
		  async post(transaction) {
		    if (typeof transaction === "string") {
		      transaction = new transaction_1.default(JSON.parse(transaction));
		    } else if (typeof transaction.readInt32BE === "function") {
		      transaction = new transaction_1.default(JSON.parse(transaction.toString()));
		    } else if (typeof transaction === "object" && !(transaction instanceof transaction_1.default)) {
		      transaction = new transaction_1.default(transaction);
		    }
		    if (!(transaction instanceof transaction_1.default)) {
		      throw new Error(`Must be Transaction object`);
		    }
		    if (!transaction.chunks) {
		      await transaction.prepareChunks(transaction.data);
		    }
		    const uploader = await this.getUploader(transaction, transaction.data);
		    // Emulate existing error & return value behavior.
		    try {
		      while (!uploader.isComplete) {
		        await uploader.uploadChunk();
		      }
		    } catch (e) {
		      if (uploader.lastResponseStatus > 0) {
		        return {
		          status: uploader.lastResponseStatus,
		          statusText: uploader.lastResponseError,
		          data: {
		            error: uploader.lastResponseError
		          }
		        };
		      }
		      throw e;
		    }
		    return {
		      status: 200,
		      statusText: "OK",
		      data: {}
		    };
		  }
		  /**
		   * Gets an uploader than can be used to upload a transaction chunk by chunk, giving progress
		   * and the ability to resume.
		   *
		   * Usage example:
		   *
		   * ```
		   * const uploader = arweave.transactions.getUploader(transaction);
		   * while (!uploader.isComplete) {
		   *   await uploader.uploadChunk();
		   *   console.log(`${uploader.pctComplete}%`);
		   * }
		   * ```
		   *
		   * @param upload a Transaction object, a previously save progress object, or a transaction id.
		   * @param data the data of the transaction. Required when resuming an upload.
		   */
		  async getUploader(upload, data) {
		    let uploader;
		    if (data instanceof ArrayBuffer) {
		      data = new Uint8Array(data);
		    }
		    if (upload instanceof transaction_1.default) {
		      if (!data) {
		        data = upload.data;
		      }
		      if (!(data instanceof Uint8Array)) {
		        throw new Error("Data format is invalid");
		      }
		      if (!upload.chunks) {
		        await upload.prepareChunks(data);
		      }
		      uploader = new transaction_uploader_1.TransactionUploader(this.api, upload);
		      if (!uploader.data || uploader.data.length === 0) {
		        uploader.data = data;
		      }
		    } else {
		      if (typeof upload === "string") {
		        upload = await transaction_uploader_1.TransactionUploader.fromTransactionId(this.api, upload);
		      }
		      if (!data || !(data instanceof Uint8Array)) {
		        throw new Error(`Must provide data when resuming upload`);
		      }
		      // upload should be a serialized upload.
		      uploader = await transaction_uploader_1.TransactionUploader.fromSerialized(this.api, upload, data);
		    }
		    return uploader;
		  }
		  /**
		   * Async generator version of uploader
		   *
		   * Usage example:
		   *
		   * ```
		   * for await (const uploader of arweave.transactions.upload(tx)) {
		   *  console.log(`${uploader.pctComplete}%`);
		   * }
		   * ```
		   *
		   * @param upload a Transaction object, a previously save uploader, or a transaction id.
		   * @param data the data of the transaction. Required when resuming an upload.
		   */
		  async *upload(upload, data) {
		    const uploader = await this.getUploader(upload, data);
		    while (!uploader.isComplete) {
		      await uploader.uploadChunk();
		      yield uploader;
		    }
		    return uploader;
		  }
		}
		transactions.default = Transactions;
		return transactions;
	}

	var wallets = {};

	var hasRequiredWallets;

	function requireWallets () {
		if (hasRequiredWallets) return wallets;
		hasRequiredWallets = 1;

		Object.defineProperty(wallets, "__esModule", {
		  value: true
		});
		const ArweaveUtils = requireUtils();

		class Wallets {
		  api;
		  crypto;
		  constructor(api, crypto) {
		    this.api = api;
		    this.crypto = crypto;
		  }
		  /**
		   * Get the wallet balance for the given address.
		   *
		   * @param {string} address - The arweave address to get the balance for.
		   *
		   * @returns {Promise<string>} - Promise which resolves with a winston string balance.
		   */
		  getBalance(address) {
		    return this.api.get(`wallet/${address}/balance`).then(response => {
		      return response.data;
		    });
		  }
		  /**
		   * Get the last transaction ID for the given wallet address.
		   *
		   * @param {string} address - The arweave address to get the transaction for.
		   *
		   * @returns {Promise<string>} - Promise which resolves with a transaction ID.
		   */
		  getLastTransactionID(address) {
		    return this.api.get(`wallet/${address}/last_tx`).then(response => {
		      return response.data;
		    });
		  }
		  generate() {
		    return this.crypto.generateJWK();
		  }
		  async jwkToAddress(jwk) {
		    if (!jwk || jwk === "use_wallet") {
		      return this.getAddress();
		    } else {
		      return this.getAddress(jwk);
		    }
		  }
		  async getAddress(jwk) {
		    if (!jwk || jwk === "use_wallet") {
		      try {
		        // @ts-ignore
		        await arweaveWallet.connect(["ACCESS_ADDRESS"]);
		      } catch {
		        // Permission is already granted
		      }
		      // @ts-ignore
		      return arweaveWallet.getActiveAddress();
		    } else {
		      return this.ownerToAddress(jwk.n);
		    }
		  }
		  async ownerToAddress(owner) {
		    return ArweaveUtils.bufferTob64Url(await this.crypto.hash(ArweaveUtils.b64UrlToBuffer(owner)));
		  }
		}
		wallets.default = Wallets;
		return wallets;
	}

	var silo = {};

	var hasRequiredSilo;

	function requireSilo () {
		if (hasRequiredSilo) return silo;
		hasRequiredSilo = 1;

		Object.defineProperty(silo, "__esModule", {
		  value: true
		});
		silo.SiloResource = void 0;
		const ArweaveUtils = requireUtils();
		class Silo {
		  api;
		  crypto;
		  transactions;
		  constructor(api, crypto, transactions) {
		    this.api = api;
		    this.crypto = crypto;
		    this.transactions = transactions;
		  }
		  async get(siloURI) {
		    if (!siloURI) {
		      throw new Error(`No Silo URI specified`);
		    }
		    const resource = await this.parseUri(siloURI);
		    const ids = await this.transactions.search("Silo-Name", resource.getAccessKey());
		    if (ids.length == 0) {
		      throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
		    }
		    const transaction = await this.transactions.get(ids[0]);
		    if (!transaction) {
		      throw new Error(`No data could be found for the Silo URI: ${siloURI}`);
		    }
		    const encrypted = transaction.get("data", {
		      decode: true,
		      string: false
		    });
		    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
		  }
		  async readTransactionData(transaction, siloURI) {
		    if (!siloURI) {
		      throw new Error(`No Silo URI specified`);
		    }
		    const resource = await this.parseUri(siloURI);
		    const encrypted = transaction.get("data", {
		      decode: true,
		      string: false
		    });
		    return this.crypto.decrypt(encrypted, resource.getEncryptionKey());
		  }
		  async parseUri(siloURI) {
		    const parsed = siloURI.match(/^([a-z0-9-_]+)\.([0-9]+)/i);
		    if (!parsed) {
		      throw new Error(`Invalid Silo name, must be a name in the format of [a-z0-9]+.[0-9]+, e.g. 'bubble.7'`);
		    }
		    const siloName = parsed[1];
		    const hashIterations = Math.pow(2, parseInt(parsed[2]));
		    const digest = await this.hash(ArweaveUtils.stringToBuffer(siloName), hashIterations);
		    const accessKey = ArweaveUtils.bufferTob64(digest.slice(0, 15));
		    const encryptionkey = await this.hash(digest.slice(16, 31), 1);
		    return new SiloResource(siloURI, accessKey, encryptionkey);
		  }
		  async hash(input, iterations) {
		    let digest = await this.crypto.hash(input);
		    for (let count = 0; count < iterations - 1; count++) {
		      digest = await this.crypto.hash(digest);
		    }
		    return digest;
		  }
		}
		silo.default = Silo;
		class SiloResource {
		  uri;
		  accessKey;
		  encryptionKey;
		  constructor(uri, accessKey, encryptionKey) {
		    this.uri = uri;
		    this.accessKey = accessKey;
		    this.encryptionKey = encryptionKey;
		  }
		  getUri() {
		    return this.uri;
		  }
		  getAccessKey() {
		    return this.accessKey;
		  }
		  getEncryptionKey() {
		    return this.encryptionKey;
		  }
		}
		silo.SiloResource = SiloResource;
		return silo;
	}

	var chunks = {};

	var hasRequiredChunks;

	function requireChunks () {
		if (hasRequiredChunks) return chunks;
		hasRequiredChunks = 1;

		Object.defineProperty(chunks, "__esModule", {
		  value: true
		});
		const error_1 = requireError();
		const ArweaveUtils = requireUtils();
		class Chunks {
		  api;
		  constructor(api) {
		    this.api = api;
		  }
		  async getTransactionOffset(id) {
		    const resp = await this.api.get(`tx/${id}/offset`);
		    if (resp.status === 200) {
		      return resp.data;
		    }
		    throw new Error(`Unable to get transaction offset: ${(0, error_1.getError)(resp)}`);
		  }
		  async getChunk(offset) {
		    const resp = await this.api.get(`chunk/${offset}`);
		    if (resp.status === 200) {
		      return resp.data;
		    }
		    throw new Error(`Unable to get chunk: ${(0, error_1.getError)(resp)}`);
		  }
		  async getChunkData(offset) {
		    const chunk = await this.getChunk(offset);
		    const buf = ArweaveUtils.b64UrlToBuffer(chunk.chunk);
		    return buf;
		  }
		  firstChunkOffset(offsetResponse) {
		    return parseInt(offsetResponse.offset) - parseInt(offsetResponse.size) + 1;
		  }
		  async downloadChunkedData(id) {
		    const offsetResponse = await this.getTransactionOffset(id);
		    const size = parseInt(offsetResponse.size);
		    const endOffset = parseInt(offsetResponse.offset);
		    const startOffset = endOffset - size + 1;
		    const data = new Uint8Array(size);
		    let byte = 0;
		    while (byte < size) {
		      if (this.api.config.logging) {
		        console.log(`[chunk] ${byte}/${size}`);
		      }
		      let chunkData;
		      try {
		        chunkData = await this.getChunkData(startOffset + byte);
		      } catch (error) {
		        console.error(`[chunk] Failed to fetch chunk at offset ${startOffset + byte}`);
		        console.error(`[chunk] This could indicate that the chunk wasn't uploaded or hasn't yet seeded properly to a particular gateway/node`);
		      }
		      if (chunkData) {
		        data.set(chunkData, byte);
		        byte += chunkData.length;
		      } else {
		        throw new Error(`Couldn't complete data download at ${byte}/${size}`);
		      }
		    }
		    return data;
		  }
		}
		chunks.default = Chunks;
		return chunks;
	}

	var blocks = {};

	var hasRequiredBlocks;

	function requireBlocks () {
		if (hasRequiredBlocks) return blocks;
		hasRequiredBlocks = 1;

		Object.defineProperty(blocks, "__esModule", {
		  value: true
		});
		const error_1 = requireError();

		class Blocks {
		  api;
		  network;
		  static HASH_ENDPOINT = "block/hash/";
		  static HEIGHT_ENDPOINT = "block/height/";
		  constructor(api, network) {
		    this.api = api;
		    this.network = network;
		  }
		  /**
		   * Gets a block by its "indep_hash"
		   */
		  async get(indepHash) {
		    const response = await this.api.get(`${Blocks.HASH_ENDPOINT}${indepHash}`);
		    if (response.status === 200) {
		      return response.data;
		    } else {
		      if (response.status === 404) {
		        throw new error_1.default("BLOCK_NOT_FOUND" /* ArweaveErrorType.BLOCK_NOT_FOUND */);
		      } else {
		        throw new Error(`Error while loading block data: ${response}`);
		      }
		    }
		  }
		  /**
		   * Gets a block by its "height"
		   */
		  async getByHeight(height) {
		    const response = await this.api.get(`${Blocks.HEIGHT_ENDPOINT}${height}`);
		    if (response.status === 200) {
		      return response.data;
		    } else {
		      if (response.status === 404) {
		        throw new error_1.default("BLOCK_NOT_FOUND" /* ArweaveErrorType.BLOCK_NOT_FOUND */);
		      } else {
		        throw new Error(`Error while loading block data: ${response}`);
		      }
		    }
		  }
		  /**
		   * Gets current block data (ie. block with indep_hash = Network.getInfo().current)
		   */
		  async getCurrent() {
		    const {
		      current
		    } = await this.network.getInfo();
		    return await this.get(current);
		  }
		}
		blocks.default = Blocks;
		return blocks;
	}

	var hasRequiredCommon;

	function requireCommon () {
		if (hasRequiredCommon) return common;
		hasRequiredCommon = 1;

		Object.defineProperty(common, "__esModule", {
		  value: true
		});
		const ar_1 = requireAr();
		const api_1 = requireApi();
		const node_driver_1 = requireWebcryptoDriver();
		const network_1 = requireNetwork();
		const transactions_1 = requireTransactions();
		const wallets_1 = requireWallets();
		const transaction_1 = requireTransaction();
		const ArweaveUtils = requireUtils();
		const silo_1 = requireSilo();
		const chunks_1 = requireChunks();
		const blocks_1 = requireBlocks();
		class Arweave {
		  api;
		  wallets;
		  transactions;
		  network;
		  blocks;
		  ar;
		  silo;
		  chunks;
		  static init;
		  static crypto = new node_driver_1.default();
		  static utils = ArweaveUtils;
		  constructor(apiConfig) {
		    this.api = new api_1.default(apiConfig);
		    this.wallets = new wallets_1.default(this.api, Arweave.crypto);
		    this.chunks = new chunks_1.default(this.api);
		    this.transactions = new transactions_1.default(this.api, Arweave.crypto, this.chunks);
		    this.silo = new silo_1.default(this.api, this.crypto, this.transactions);
		    this.network = new network_1.default(this.api);
		    this.blocks = new blocks_1.default(this.api, this.network);
		    this.ar = new ar_1.default();
		  }
		  /** @deprecated */
		  get crypto() {
		    return Arweave.crypto;
		  }
		  /** @deprecated */
		  get utils() {
		    return Arweave.utils;
		  }
		  getConfig() {
		    return {
		      api: this.api.getConfig(),
		      crypto: null
		    };
		  }
		  async createTransaction(attributes, jwk) {
		    const transaction = {};
		    Object.assign(transaction, attributes);
		    if (!attributes.data && !(attributes.target && attributes.quantity)) {
		      throw new Error(`A new Arweave transaction must have a 'data' value, or 'target' and 'quantity' values.`);
		    }
		    if (attributes.owner == undefined) {
		      if (jwk && jwk !== "use_wallet") {
		        transaction.owner = jwk.n;
		      }
		    }
		    if (attributes.last_tx == undefined) {
		      transaction.last_tx = await this.transactions.getTransactionAnchor();
		    }
		    if (typeof attributes.data === "string") {
		      attributes.data = ArweaveUtils.stringToBuffer(attributes.data);
		    }
		    if (attributes.data instanceof ArrayBuffer) {
		      attributes.data = new Uint8Array(attributes.data);
		    }
		    if (attributes.data && !(attributes.data instanceof Uint8Array)) {
		      throw new Error("Expected data to be a string, Uint8Array or ArrayBuffer");
		    }
		    if (attributes.reward == undefined) {
		      const length = attributes.data ? attributes.data.byteLength : 0;
		      transaction.reward = await this.transactions.getPrice(length, transaction.target);
		    }
		    // here we should call prepare chunk
		    transaction.data_root = "";
		    transaction.data_size = attributes.data ? attributes.data.byteLength.toString() : "0";
		    transaction.data = attributes.data || new Uint8Array(0);
		    const createdTransaction = new transaction_1.default(transaction);
		    await createdTransaction.getSignatureData();
		    return createdTransaction;
		  }
		  async createSiloTransaction(attributes, jwk, siloUri) {
		    const transaction = {};
		    Object.assign(transaction, attributes);
		    if (!attributes.data) {
		      throw new Error(`Silo transactions must have a 'data' value`);
		    }
		    if (!siloUri) {
		      throw new Error(`No Silo URI specified.`);
		    }
		    if (attributes.target || attributes.quantity) {
		      throw new Error(`Silo transactions can only be used for storing data, sending AR to other wallets isn't supported.`);
		    }
		    if (attributes.owner == undefined) {
		      if (!jwk || !jwk.n) {
		        throw new Error(`A new Arweave transaction must either have an 'owner' attribute, or you must provide the jwk parameter.`);
		      }
		      transaction.owner = jwk.n;
		    }
		    if (attributes.last_tx == undefined) {
		      transaction.last_tx = await this.transactions.getTransactionAnchor();
		    }
		    const siloResource = await this.silo.parseUri(siloUri);
		    if (typeof attributes.data == "string") {
		      const encrypted = await this.crypto.encrypt(ArweaveUtils.stringToBuffer(attributes.data), siloResource.getEncryptionKey());
		      transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
		      transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
		    }
		    if (attributes.data instanceof Uint8Array) {
		      const encrypted = await this.crypto.encrypt(attributes.data, siloResource.getEncryptionKey());
		      transaction.reward = await this.transactions.getPrice(encrypted.byteLength);
		      transaction.data = ArweaveUtils.bufferTob64Url(encrypted);
		    }
		    const siloTransaction = new transaction_1.default(transaction);
		    siloTransaction.addTag("Silo-Name", siloResource.getAccessKey());
		    siloTransaction.addTag("Silo-Version", `0.1.0`);
		    return siloTransaction;
		  }
		  arql(query) {
		    return this.api.post("/arql", query).then(response => response.data || []);
		  }
		}
		common.default = Arweave;
		return common;
	}

	var netConfig = {};

	var hasRequiredNetConfig;

	function requireNetConfig () {
		if (hasRequiredNetConfig) return netConfig;
		hasRequiredNetConfig = 1;

		Object.defineProperty(netConfig, "__esModule", {
		  value: true
		});
		netConfig.getDefaultConfig = void 0;
		/** exhaustive localhost testing */
		const isLocal = (protocol, hostname) => {
		  const regexLocalIp = /^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/;
		  const split = hostname.split(".");
		  const tld = split[split.length - 1]; // check if subdomain on the localhost
		  const localStrings = ["localhost", "[::1]"];
		  return localStrings.includes(hostname) || protocol == "file" || localStrings.includes(tld) || !!hostname.match(regexLocalIp) || !!tld.match(regexLocalIp);
		};
		/** simplified tests for ip addresses */
		const isIpAdress = host => {
		  // an IPv6 location.hostname (and only IPv6 hostnames) must be surrounded by square brackets
		  const isIpv6 = host.charAt(0) === "[";
		  // Potential speed-up for IPv4 detection:
		  // the tld of a domain name cannot be a number (IDN location.hostnames appear to be converted, needs further clarification)
		  const regexMatchIpv4 = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/;
		  return !!host.match(regexMatchIpv4) || isIpv6;
		};
		const getDefaultConfig = (protocol, host) => {
		  // If we're running in what looks like a local dev environment
		  // then default to using arweave.net
		  if (isLocal(protocol, host)) {
		    return {
		      protocol: "https",
		      host: "arweave.net",
		      port: 443
		    };
		  }
		  //check if hostname is an IP address before removing first subdomain
		  if (!isIpAdress(host)) {
		    let split = host.split(".");
		    if (split.length >= 3) {
		      split.shift();
		      const parentDomain = split.join(".");
		      return {
		        protocol,
		        host: parentDomain
		      };
		    }
		  }
		  // there are 2 potential garbage returns here:
		  // a non-GW ip address & a non-GW hostname without ArNS. garbage in, garbage out.
		  // they should be overridden with user inputs in apiConfig.
		  // otherwise we have a valid ip based GW address.
		  return {
		    protocol,
		    host
		  };
		};
		netConfig.getDefaultConfig = getDefaultConfig;
		return netConfig;
	}

	var hasRequiredWeb;

	function requireWeb () {
		if (hasRequiredWeb) return web;
		hasRequiredWeb = 1;
		(function (exports) {

			var __createBinding = web && web.__createBinding || (Object.create ? function (o, m, k, k2) {
			  if (k2 === undefined) k2 = k;
			  var desc = Object.getOwnPropertyDescriptor(m, k);
			  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
			    desc = {
			      enumerable: true,
			      get: function () {
			        return m[k];
			      }
			    };
			  }
			  Object.defineProperty(o, k2, desc);
			} : function (o, m, k, k2) {
			  if (k2 === undefined) k2 = k;
			  o[k2] = m[k];
			});
			var __exportStar = web && web.__exportStar || function (m, exports) {
			  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
			};
			Object.defineProperty(exports, "__esModule", {
			  value: true
			});
			const common_1 = requireCommon();
			const net_config_1 = requireNetConfig();
			common_1.default.init = function (apiConfig = {}) {
			  const defaults = {
			    host: "arweave.net",
			    port: 443,
			    protocol: "https"
			  };
			  if (typeof location !== "object" || !location.protocol || !location.hostname) {
			    return new common_1.default({
			      ...apiConfig,
			      ...defaults
			    });
			  }
			  // window.location.protocol has a trailing colon (http:, https:, file: etc)
			  const locationProtocol = location.protocol.replace(":", "");
			  const locationHost = location.hostname;
			  const locationPort = location.port ? parseInt(location.port) : locationProtocol == "https" ? 443 : 80;
			  const defaultConfig = (0, net_config_1.getDefaultConfig)(locationProtocol, locationHost);
			  const protocol = apiConfig.protocol || defaultConfig.protocol;
			  const host = apiConfig.host || defaultConfig.host;
			  const port = apiConfig.port || defaultConfig.port || locationPort;
			  return new common_1.default({
			    ...apiConfig,
			    host,
			    protocol,
			    port
			  });
			};
			if (typeof globalThis === "object") {
			  globalThis.Arweave = common_1.default;
			} else if (typeof self === "object") {
			  self.Arweave = common_1.default;
			}
			__exportStar(requireCommon(), exports);
			exports.default = common_1.default; 
		} (web));
		return web;
	}

	var webExports = requireWeb();
	var ArweaveModule = /*@__PURE__*/getDefaultExportFromCjs(webExports);

	// src/lib/config/config.constants.ts
	var DEFAULT_OTHENT_CONFIG = {
	  debug: false,
	  inject: false,
	  auth0Domain: "auth.othent.io",
	  auth0ClientId: "uXkRmJoIa0NfzYgYEDAgj6Rss4wR1tIc",
	  auth0Strategy: "refresh-tokens",
	  auth0Cache: "memory",
	  auth0RefreshTokenExpirationMs: 1296e6,
	  // 2 weeks
	  auth0LogInMethod: "popup",
	  auth0RedirectURI: null,
	  auth0ReturnToURI: null,
	  serverBaseURL: "https://kms-server.othent.io",
	  autoConnect: "lazy",
	  cookieKey: null,
	  localStorageKey: null,
	  throwErrors: true,
	  tags: []
	};
	var DEFAULT_OTHENT_OPTIONS = {
	  ...DEFAULT_OTHENT_CONFIG,
	  appName: "",
	  appVersion: "",
	  persistCookie: false,
	  persistLocalStorage: false,
	  auth0Cache: "memory"
	};
	var DEFAULT_GATEWAY_CONFIG = {
	  host: "arweave.net",
	  protocol: "https",
	  port: 443
	};
	var DEFAULT_DISPATCH_NODE = "https://turbo.ardrive.io";
	var DEFAULT_COOKIE_KEY = "othentUserDetails";
	var CLIENT_NAME = "Othent KMS";
	var CLIENT_VERSION = "2.0.0-beta.10";
	var ANALYTICS_TAGS = [
	  {
	    name: "Client",
	    value: CLIENT_NAME
	  },
	  {
	    name: "Client-Version",
	    value: CLIENT_VERSION
	  }
	];

	// src/lib/utils/events/event-listener-handler.ts
	var EventListenersHandler = class {
	  constructor(options) {
	    this.listeners = /* @__PURE__ */ new Set();
	    this.initializedListeners = /* @__PURE__ */ new Set();
	    this.lastEmittedUpdateId = "";
	    this.lastEmittedParams = null;
	    this.options = {
	      diffParams: false,
	      replyOnListen: false
	    };
	    this.options = {
	      ...this.options,
	      ...options
	    };
	  }
	  getUpdateId(parameters) {
	    const serializer = (_, value) => {
	      return value && value === "oject" && !Array.isArray(value) ? Object.entries(value).sort((a, b) => a[0].localeCompare(b[0])) : value;
	    };
	    const { getUpdateIdTransform } = this.options;
	    const transformedParameters = getUpdateIdTransform ? getUpdateIdTransform(parameters) : parameters;
	    return JSON.stringify(transformedParameters, serializer);
	  }
	  get hasListeners() {
	    return this.listeners.size > 0;
	  }
	  add(listener) {
	    this.listeners.add(listener);
	    if (this.options.replyOnListen && this.lastEmittedParams)
	      this.emit(...this.lastEmittedParams);
	  }
	  delete(listener) {
	    this.listeners.add(listener);
	  }
	  emit(...parameters) {
	    const { initializedListeners, lastEmittedUpdateId } = this;
	    const updateId = this.getUpdateId(parameters);
	    const updatedAlreadyEmitted = lastEmittedUpdateId === updateId;
	    this.lastEmittedUpdateId = updateId;
	    this.lastEmittedParams = parameters;
	    this.listeners.forEach((listenerFn) => {
	      if (updatedAlreadyEmitted && initializedListeners.has(listenerFn)) return;
	      initializedListeners.add(listenerFn);
	      try {
	        listenerFn(...parameters);
	      } catch (err) {
	      }
	    });
	    return updatedAlreadyEmitted;
	  }
	};
	function mergeOptions(options, defaults) {
	  return extend$1(true, {}, defaults, options);
	}

	// src/lib/utils/cookies/cookie-storage.ts
	var DEFAULT_COOKIE_OPTIONS = {
	  secure: true,
	  domain: true,
	  ttlHours: 360
	};
	var _CookieStorage = class _CookieStorage {
	  // 2 weeks
	  constructor(cookieOptions = DEFAULT_COOKIE_OPTIONS) {
	    this.secureParam = null;
	    this.domainParam = null;
	    this.ttlMs = 1296e6;
	    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(
	      mergeOptions(cookieOptions, DEFAULT_COOKIE_OPTIONS)
	    );
	    this.secureParam = secureParam;
	    this.domainParam = domainParam;
	    this.ttlMs = ttlMs;
	    return new Proxy(this, {
	      get(target, prop) {
	        return prop in target || typeof prop !== "string" ? target[prop] : target.getItem(prop);
	      },
	      ownKeys(target) {
	        return document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).map(
	          (cookieStr) => cookieStr.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0]
	        );
	      },
	      getOwnPropertyDescriptor() {
	        return {
	          enumerable: true,
	          configurable: true
	        };
	      }
	    });
	  }
	  parseCookieOptions({
	    secure,
	    domain,
	    ttlHours
	  } = {}) {
	    const secureParam = secure ? "secure" : secure === void 0 ? this.secureParam : null;
	    const domainParam = domain ? `domain=${domain === true ? location.host : domain}` : domain === void 0 ? this.domainParam : null;
	    const ttlMs = ttlHours ? ttlHours * 36e5 : ttlHours === void 0 ? this.ttlMs : 0;
	    return {
	      secureParam,
	      domainParam,
	      ttlMs
	    };
	  }
	  getCookieParams(cookieOptions) {
	    const { secureParam, domainParam, ttlMs } = this.parseCookieOptions(cookieOptions);
	    const expirationDate = new Date(Date.now() + ttlMs);
	    const expiresParam = `expires=${expirationDate.toUTCString()}`;
	    const pathParam = "path=/";
	    const cookieParams = [expiresParam, secureParam, domainParam, pathParam].filter(Boolean).join("; ");
	    return cookieParams ? ` ${cookieParams};` : "";
	  }
	  get length() {
	    return document.cookie ? document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).length : 0;
	  }
	  key(index) {
	    const cookieStrAtIndex = document.cookie.split(_CookieStorage.COOKIE_SEPARATOR)[index] || "";
	    const cookieKey = cookieStrAtIndex.split(
	      _CookieStorage.COOKIE_VALUE_SEPARATOR
	    )[0];
	    return cookieKey || null;
	  }
	  getItem(name) {
	    const targetCookie = document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).find((item) => {
	      return item.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0] === name;
	    });
	    return targetCookie && targetCookie.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[1] || null;
	  }
	  setItem(key, value, cookieOptions) {
	    const serializedValue = typeof value === "string" ? value : JSON.stringify(value);
	    const cookieParams = this.getCookieParams(cookieOptions);
	    if (process.env.NODE_ENV === "development") {
	      const actionLabel = ((cookieOptions == null ? void 0 : cookieOptions.ttlHours) || 1) < 0 ? "Removing" : "Setting";
	      console.info(`${actionLabel} cookie ${key}=<VALUE>;${cookieParams}`);
	    }
	    const cookieStr = `${key}=${serializedValue};${cookieParams}`;
	    document.cookie = cookieStr;
	    return cookieStr;
	  }
	  removeItem(key, cookieOptions) {
	    return this.setItem(key, "", { ...cookieOptions, ttlHours: -1 });
	  }
	  clear() {
	    document.cookie.split(_CookieStorage.COOKIE_SEPARATOR).forEach((item) => {
	      this.removeItem(item.split(_CookieStorage.COOKIE_VALUE_SEPARATOR)[0]);
	    });
	  }
	};
	_CookieStorage.COOKIE_SEPARATOR = /\s*;\s*/;
	_CookieStorage.COOKIE_VALUE_SEPARATOR = /\s*=\s*/;
	var CookieStorage = _CookieStorage;
	var cookieStorage = null;
	function getCookieStorage() {
	  if (!cookieStorage) {
	    const isLocalhost = process.env.NODE_ENV === "development" && (location == null ? void 0 : location.hostname) === "localhost";
	    cookieStorage = new CookieStorage({
	      secure: isLocalhost ? false : void 0,
	      domain: isLocalhost ? false : void 0
	    });
	  }
	  return cookieStorage;
	}
	async function getAnsProfile(address) {
	  try {
	    const response = await axios3.get(
	      "https://api.mem.tech/api/state/Tih8T1uESATJNzdwBIY3rpe25kWTzjw8uNiMRYe9I5M",
	      {
	        // Because this will return the whole contract's state, it could get quite large in the future. Therefore, we set
	        // a timeout of 2 seconds to make sure this request doesn't slow down the SDK due to the big download size.
	        timeout: 2e3
	      }
	    );
	    const balanceMatch = response.data.balances.find(
	      (balance) => balance.address === address
	    );
	    const domain = balanceMatch ? balanceMatch.primary_domain || balanceMatch.ownedDomains[0].domain || null : null;
	    return domain ? `${domain}.ar` : null;
	  } catch (err) {
	    console.warn(`Error resolving ANS domain for ${address} =
`, err);
	    return null;
	  }
	}

	// src/lib/auth/auth0.ts
	var _OthentAuth0Client = class _OthentAuth0Client {
	  constructor({
	    debug,
	    domain,
	    clientId,
	    strategy,
	    cache,
	    refreshTokenExpirationMs,
	    loginMethod,
	    redirectURI,
	    returnToURI,
	    appInfo,
	    initialUserDetails,
	    cookieKey,
	    localStorageKey
	  }) {
	    this.debug = false;
	    this.auth0ClientPromise = Promise.resolve(null);
	    this.authEventListenerHandler = new EventListenersHandler({
	      diffParams: true,
	      replyOnListen: true
	    });
	    this.userDetails = null;
	    this.userDetailsExpirationTimeoutID = 0;
	    this.cookieKey = null;
	    this.localStorageKey = null;
	    this.refreshTokenExpirationMs = +DEFAULT_OTHENT_CONFIG.auth0RefreshTokenExpirationMs;
	    this.appInfo = {
	      name: "",
	      version: ""
	    };
	    this.isReady = false;
	    this.isAuthenticated = false;
	    this.debug = debug;
	    this.loginMethod = loginMethod;
	    this.redirectURI = redirectURI;
	    this.returnToURI = returnToURI;
	    this.auth0ClientPromise = oe$1({
	      domain,
	      clientId,
	      useRefreshTokens: strategy === "refresh-tokens",
	      cacheLocation: typeof cache === "string" ? cache : void 0,
	      cache: typeof cache === "object" ? cache : void 0,
	      authorizationParams: {
	        redirect_uri: this.redirectURI
	        // scope: "openid profile email offline_access"
	        // audience
	      }
	    }).then((Auth0Client2) => {
	      this.isReady = true;
	      return Auth0Client2;
	    });
	    this.cookieKey = cookieKey;
	    this.localStorageKey = localStorageKey;
	    this.refreshTokenExpirationMs = refreshTokenExpirationMs;
	    this.appInfo = appInfo;
	    this.restoreUserDetails(initialUserDetails || null);
	    this.handleStorage = this.handleStorage.bind(this);
	  }
	  static isIdTokenValidUser(idToken) {
	    return !!(idToken && idToken.sub && idToken.owner && idToken.walletAddress && idToken.authSystem === "KMS");
	  }
	  static async getUserDetails(idToken) {
	    const { email = "", walletAddress } = idToken;
	    const sub = idToken.sub || "";
	    const authProvider = sub.split("|")[0];
	    let walletAddressLabel = await getAnsProfile(walletAddress);
	    if (!walletAddressLabel) {
	      const providerLabel = _OthentAuth0Client.PROVIDER_LABELS[authProvider] || "Unknown Provider";
	      walletAddressLabel = `${providerLabel} (${email})`;
	    }
	    return {
	      sub,
	      name: idToken.name || "",
	      givenName: idToken.given_name || "",
	      middleName: idToken.middle_name || "",
	      familyName: idToken.family_name || "",
	      nickname: idToken.nickname || "",
	      preferredUsername: idToken.preferred_username || "",
	      profile: idToken.profile || "",
	      picture: idToken.picture || "",
	      website: idToken.website || "",
	      locale: idToken.locale || "",
	      updatedAt: idToken.updated_at || "",
	      email,
	      emailVerified: !!idToken.email_verified,
	      owner: idToken.owner,
	      walletAddress: idToken.walletAddress,
	      walletAddressLabel,
	      authSystem: idToken.authSystem,
	      authProvider
	    };
	  }
	  // Getters / Setters:
	  getAuthEventListenerHandler() {
	    return this.authEventListenerHandler;
	  }
	  setAppInfo(appInfo) {
	    this.appInfo = appInfo;
	  }
	  // Storage listeners:
	  initStorageSyncing() {
	    if (!this.localStorageKey) return;
	    window.addEventListener("storage", this.handleStorage);
	  }
	  stopStorageSyncing() {
	    window.removeEventListener("storage", this.handleStorage);
	  }
	  handleStorage(event) {
	    if (event.key !== this.localStorageKey) return;
	    if (event.newValue) {
	      this.restoreUserDetails();
	    } else {
	      this.logOut();
	    }
	  }
	  persistUserDetails(userDetails) {
	    const { cookieKey, localStorageKey } = this;
	    if (cookieKey) {
	      const cookieStorage2 = getCookieStorage();
	      if (userDetails) {
	        cookieStorage2.setItem(cookieKey, JSON.stringify(userDetails));
	      } else if (cookieStorage2.getItem(cookieKey) !== null) {
	        cookieStorage2.removeItem(cookieKey);
	      }
	    }
	    if (localStorageKey) {
	      if (userDetails) {
	        const now = /* @__PURE__ */ new Date();
	        const serializedUserDetails = JSON.stringify({
	          userDetails,
	          createdAt: now.toUTCString(),
	          expiredBy: new Date(
	            now.getTime() + this.refreshTokenExpirationMs
	          ).toUTCString()
	        });
	        localStorage.setItem(localStorageKey, serializedUserDetails);
	      } else {
	        this.clearStoredUserDetails();
	      }
	    }
	  }
	  // `userDetails` setters:
	  setUserDetails(userDetails, updateAuth = true) {
	    window.clearTimeout(this.userDetailsExpirationTimeoutID);
	    if (userDetails) {
	      this.userDetailsExpirationTimeoutID = window.setTimeout(
	        this.logOut,
	        this.refreshTokenExpirationMs
	      );
	    }
	    const updatedAlreadyEmitted = this.authEventListenerHandler.emit(
	      userDetails,
	      updateAuth ? !!userDetails : this.isAuthenticated
	    );
	    if (!updatedAlreadyEmitted) {
	      this.userDetails = userDetails;
	    }
	    if (updateAuth) {
	      this.isAuthenticated = !!userDetails;
	      this.persistUserDetails(userDetails);
	    }
	    return userDetails;
	  }
	  restoreUserDetails(userDetails) {
	    let initialUserDetails = userDetails || null;
	    if (!initialUserDetails && this.localStorageKey) {
	      try {
	        const storedUserDetails = JSON.parse(
	          localStorage.getItem(this.localStorageKey) || "null"
	        );
	        if (storedUserDetails) {
	          const expiredBy = new Date(storedUserDetails.expiredBy).getTime();
	          if (!isNaN(expiredBy) && expiredBy > Date.now()) {
	            initialUserDetails = storedUserDetails.userDetails;
	          } else {
	            this.clearStoredUserDetails();
	          }
	        }
	      } catch (err) {
	      }
	    }
	    this.setUserDetails(initialUserDetails, false);
	  }
	  clearStoredUserDetails() {
	    Object.keys(localStorage).forEach((key) => {
	      if (key.startsWith("othent")) localStorage.removeItem(key);
	    });
	  }
	  async updateUserDetails(idToken) {
	    const nextUserDetails = idToken && _OthentAuth0Client.isIdTokenValidUser(idToken) ? await _OthentAuth0Client.getUserDetails(idToken) : null;
	    return this.setUserDetails(nextUserDetails);
	  }
	  getAuthorizationParams(authorizationParamsOrData = {}) {
	    const { authorizationParams, data } = authorizationParamsOrData.hasOwnProperty("keyName") ? {
	      authorizationParams: null,
	      data: authorizationParamsOrData
	    } : {
	      authorizationParams: authorizationParamsOrData,
	      data: null
	    };
	    const replacer = (key, value) => {
	      let bufferValues = [];
	      if (value instanceof bufferExports.Buffer || value instanceof DataView || ArrayBuffer.isView(value)) {
	        bufferValues = Array.from(new Uint8Array(value.buffer));
	      } else if (value instanceof ArrayBuffer) {
	        bufferValues = Array.from(new Uint8Array(value));
	      } else {
	        return value;
	      }
	      return key === "data" ? Object.fromEntries(Object.entries(bufferValues)) : {
	        type: "Buffer",
	        data: bufferValues
	      };
	    };
	    const transactionInput = {
	      othentFunction: "KMS",
	      othentSDKVersion: CLIENT_NAME,
	      othentAPIVersion: CLIENT_VERSION,
	      appName: this.appInfo.name,
	      appVersion: this.appInfo.version
	    };
	    if (data) {
	      transactionInput.data = data;
	    }
	    return {
	      ...authorizationParams,
	      transaction_input: JSON.stringify(transactionInput, replacer)
	    };
	  }
	  // Wrappers around Auth0's native client with some additional functionality:
	  async getTokenSilently(data) {
	    const auth0Client = await this.auth0ClientPromise;
	    if (!auth0Client) throw new Error("Missing Auth0 Client");
	    const authorizationParams = this.getAuthorizationParams(data);
	    if (this.debug) {
	      try {
	        console.log("getTokenSilently() =", {
	          ...authorizationParams,
	          transaction_input: JSON.parse(authorizationParams.transaction_input)
	        });
	      } catch (err) {
	        console.error("Error logging/parsing `authorizationParams`:", err);
	      }
	    }
	    try {
	      const getTokenSilentlyResponse = await auth0Client.getTokenSilently({
	        detailedResponse: true,
	        authorizationParams,
	        cacheMode: "off"
	        // Forces the client to get a new token, as we actually include data in them, it cannot be done any other way.
	      });
	      const idToken = await auth0Client.getUser();
	      if (!idToken) throw new Error("Could not get the user's details");
	      const userDetails = await this.updateUserDetails(idToken);
	      return {
	        ...getTokenSilentlyResponse,
	        idToken,
	        userDetails
	      };
	    } catch (err) {
	      throw err;
	    }
	  }
	  async logIn() {
	    const auth0Client = await this.auth0ClientPromise;
	    if (!auth0Client) throw new Error("Missing Auth0 Client");
	    if (this.debug) console.log("logIn()");
	    const isAuthenticated = await auth0Client.isAuthenticated();
	    if (isAuthenticated) {
	      throw new Error("Already logged in");
	    }
	    const authorizationParams = this.getAuthorizationParams({
	      redirect_uri: this.redirectURI
	      // TODO: This doesn't seem to change anything. It could be used to remember the last provider the user used.
	      // connection: "auth0",
	    });
	    if (this.loginMethod === "popup") {
	      await auth0Client.loginWithPopup(
	        {
	          authorizationParams
	        },
	        {
	          // { popup: <POPUP> } // This might be useful to provide an already-created popup in platforms like iOS.
	        }
	      );
	    } else {
	      auth0Client.loginWithRedirect({
	        authorizationParams
	        // openUrl(url) { }, // This might be useful to control the redirect in mobile platforms.
	      });
	      throw new Error("Redirecting...");
	    }
	    return this.getTokenSilently();
	  }
	  async handleRedirectCallback(callbackUrlWithParams) {
	    if (this.debug)
	      console.log(`handleRedirectCallback(${callbackUrlWithParams})`);
	    const auth0Client = await this.auth0ClientPromise;
	    if (!auth0Client) throw new Error("Missing Auth0 Client");
	    await auth0Client.handleRedirectCallback(callbackUrlWithParams);
	    const idToken = await auth0Client.getUser();
	    if (!idToken) throw new Error("Could not get the user's details");
	    return this.updateUserDetails(idToken);
	  }
	  async logOut() {
	    this.setUserDetails(null);
	    const auth0Client = await this.auth0ClientPromise;
	    if (!auth0Client) throw new Error("Missing Auth0 Client");
	    return auth0Client.logout({
	      logoutParams: {
	        returnTo: this.returnToURI
	      }
	    }).catch((err) => {
	      console.warn(err instanceof Error ? err.message : err);
	      if (typeof location !== "undefined") location.reload();
	    });
	  }
	  async encodeToken(data) {
	    const accessToken = await this.getTokenSilently(data);
	    return accessToken.id_token;
	  }
	  // Getters for cached user data:
	  getCachedUserDetails() {
	    return this.userDetails;
	  }
	  getCachedUserPublicKey() {
	    var _a;
	    return ((_a = this.userDetails) == null ? void 0 : _a.owner) || null;
	  }
	  getCachedUserSub() {
	    var _a;
	    return ((_a = this.userDetails) == null ? void 0 : _a.sub) || null;
	  }
	  getCachedUserAddress() {
	    var _a;
	    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddress) || null;
	  }
	  getCachedUserAddressLabel() {
	    var _a;
	    return ((_a = this.userDetails) == null ? void 0 : _a.walletAddressLabel) || null;
	  }
	  getCachedUserEmail() {
	    var _a;
	    return ((_a = this.userDetails) == null ? void 0 : _a.email) || null;
	  }
	};
	_OthentAuth0Client.PROVIDER_LABELS = {
	  apple: "Apple",
	  auth0: "E-Mail",
	  "google-oauth2": "Google",
	  // TODO: Complete these values:
	  "<LinkedIn>": "LinkedIn",
	  "<X>": "X",
	  "<Meta>": "Meta",
	  "<Twitch>": "Twitch",
	  github: "GitHub"
	};
	var OthentAuth0Client = _OthentAuth0Client;
	function binaryDataTypeToString(buffer) {
	  return new TextDecoder().decode(buffer);
	}
	function binaryDataTypeOrStringToBinaryDataType(source) {
	  return typeof source === "string" ? stringToUint8Array(source) : source;
	}
	function stringToUint8Array(str) {
	  return new TextEncoder().encode(str);
	}
	function uint8ArrayTob64(buffer) {
	  return base64JsExports.fromByteArray(new Uint8Array(buffer));
	}
	function uint8ArrayTob64Url(buffer) {
	  return b64UrlEncode(uint8ArrayTob64(buffer));
	}
	function b64UrlEncode(str) {
	  return str.replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
	}
	async function hash(data, algorithm = "SHA-256") {
	  let digest = await crypto.subtle.digest(algorithm, data);
	  return new Uint8Array(digest);
	}

	// src/lib/utils/errors/error.ts
	var OthentErrorID = /* @__PURE__ */ ((OthentErrorID2) => {
	  OthentErrorID2["Unexpected"] = "Unexpected";
	  OthentErrorID2["Validation"] = "Validation";
	  OthentErrorID2["UserCreation"] = "UserCreation";
	  OthentErrorID2["Encryption"] = "Encryption";
	  OthentErrorID2["Decryption"] = "Decryption";
	  OthentErrorID2["Signing"] = "Signing";
	  OthentErrorID2["PublicKey"] = "PublicKey";
	  return OthentErrorID2;
	})(OthentErrorID || {});
	var OthentError = class extends Error {
	  constructor(id, developerMessage, error, fromServer = false) {
	    super();
	    this.name = id;
	    this.message = developerMessage || "";
	    if (fromServer) {
	      this.stack = `${id} (from server): ${developerMessage}
`;
	    } else {
	      Error.captureStackTrace(this);
	    }
	    this.id = id;
	    this.developerMessage = developerMessage;
	    if (error instanceof Error) {
	      this.cause = error;
	    } else if (typeof error === "string" || typeof error === "number") {
	      this.cause = new Error(`${error}`);
	    }
	  }
	};

	// src/lib/utils/errors/error.utils.ts
	function isErrorResponseData(data) {
	  return typeof data === "object" && data.error === true && !!data.id && !!OthentErrorID[data.id];
	}
	function parseErrorResponse(error) {
	  var _a;
	  if (isAxiosError(error)) {
	    const data = (_a = error.response) == null ? void 0 : _a.data;
	    if (!isErrorResponseData(data)) {
	      return error;
	    }
	    const { id, developerMessage, cause } = data;
	    let causeError;
	    if (cause) {
	      causeError = new Error(cause.message);
	      causeError.name = cause.name;
	      causeError.stack = cause.stack;
	    }
	    return new OthentError(id, developerMessage || "", causeError, true);
	  }
	  if (error instanceof Error) {
	    return error;
	  }
	  return new Error("Unknown error");
	}

	// src/lib/othent-kms-client/operations/createUser.ts
	async function createUser(api, idToken) {
	  let createUserSuccess = false;
	  try {
	    const createUserResponse = await api.post(
	      "/create-user",
	      { encodedData: idToken }
	    );
	    createUserSuccess = createUserResponse.data.data;
	  } catch (err) {
	    throw parseErrorResponse(err);
	  }
	  if (!createUserSuccess) {
	    throw new Error("Error creating user on server.");
	  }
	  return true;
	}

	// src/lib/othent-kms-client/operations/decrypt.ts
	async function decrypt(api, auth0, ciphertext, keyName) {
	  var _a;
	  const encodedData = await auth0.encodeToken({ ciphertext, keyName });
	  let plaintext = null;
	  try {
	    const decryptResponse = await api.post("/decrypt", {
	      encodedData
	    });
	    plaintext = (_a = decryptResponse.data.data) != null ? _a : null;
	  } catch (err) {
	    throw parseErrorResponse(err);
	  }
	  if (plaintext === null) {
	    throw new Error("Error decrypting on server.");
	  }
	  return typeof plaintext === "string" ? plaintext : binaryDataTypeToString(new Uint8Array(plaintext.data));
	}

	// src/lib/othent-kms-client/operations/encrypt.ts
	async function encrypt(api, auth0, plaintext, keyName) {
	  var _a;
	  const encodedData = await auth0.encodeToken({ plaintext, keyName });
	  let ciphertext = null;
	  try {
	    const encryptResponse = await api.post("/encrypt", {
	      encodedData
	    });
	    ciphertext = (_a = encryptResponse.data.data) != null ? _a : null;
	  } catch (err) {
	    throw parseErrorResponse(err);
	  }
	  if (ciphertext === null) {
	    throw new Error("Error encrypting on server.");
	  }
	  return typeof ciphertext === "string" ? stringToUint8Array(ciphertext) : new Uint8Array(ciphertext.data);
	}

	// src/lib/othent-kms-client/operations/sign.ts
	async function sign(api, auth0, data, keyName) {
	  const encodedData = await auth0.encodeToken({ data, keyName });
	  let signature = null;
	  try {
	    const signResponse = await api.post("/sign", {
	      encodedData
	    });
	    signature = signResponse.data.data;
	  } catch (err) {
	    throw parseErrorResponse(err);
	  }
	  if (signature === null) {
	    throw new Error("Error signing data on server.");
	  }
	  return typeof signature === "string" ? stringToUint8Array(signature) : new Uint8Array(signature.data);
	}

	// src/lib/othent-kms-client/client.ts
	var OthentKMSClient = class {
	  constructor(baseURL, auth0) {
	    this.api = axios3.create({ baseURL });
	    this.auth0 = auth0;
	  }
	  async createUser(idToken) {
	    return createUser(this.api, idToken);
	  }
	  async decrypt(ciphertext, keyName) {
	    return decrypt(this.api, this.auth0, ciphertext, keyName);
	  }
	  async encrypt(plaintext, keyName) {
	    return encrypt(this.api, this.auth0, plaintext, keyName);
	  }
	  async sign(data, keyName) {
	    return sign(this.api, this.auth0, data, keyName);
	  }
	  getSignerSignFn(keyName) {
	    return async (data) => {
	      const signatureBuffer = await this.sign(data, keyName);
	      return signatureBuffer;
	    };
	  }
	};
	function padString(input) {
	  let segmentLength = 4;
	  let stringLength = input.length;
	  let diff = stringLength % segmentLength;
	  if (!diff) {
	    return input;
	  }
	  let position = stringLength;
	  let padLength = segmentLength - diff;
	  let paddedStringLength = stringLength + padLength;
	  let buffer = bufferExports.Buffer.alloc(paddedStringLength);
	  buffer.write(input);
	  while (padLength--) {
	    buffer.write("=", position++);
	  }
	  return buffer.toString();
	}
	function encode(input, encoding = "utf8") {
	  if (bufferExports.Buffer.isBuffer(input)) {
	    return fromBase64(input.toString("base64"));
	  }
	  return fromBase64(bufferExports.Buffer.from(input, encoding).toString("base64"));
	}
	function decode(base64url2, encoding = "utf8") {
	  return bufferExports.Buffer.from(toBase64(base64url2), "base64").toString(encoding);
	}
	function toBase64(base64url2) {
	  base64url2 = base64url2.toString();
	  return padString(base64url2).replace(/\-/g, "+").replace(/_/g, "/");
	}
	function fromBase64(base64) {
	  return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function toBuffer(base64url2) {
	  return bufferExports.Buffer.from(toBase64(base64url2), "base64");
	}
	var base64url = encode;
	base64url.encode = encode;
	base64url.decode = decode;
	base64url.toBase64 = toBase64;
	base64url.fromBase64 = fromBase64;
	base64url.toBuffer = toBuffer;

	// src/lib/utils/promises/promises.utils.ts
	function isPromise(obj) {
	  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
	}
	function initArweave(apiConfig) {
	  const ArweaveClass = ArweaveModule.default;
	  return ArweaveClass.init(apiConfig);
	}
	var _Othent = class _Othent {
	  // TODO: Add B64 / B64Encoded support (e.g. option on encrypt to return B64Encoded, make decrypt accept a B64 input, make all signature functions return B64Encoded results...)
	  // TODO: Consider moving some of the dependencies to peer dependencies (arweave, axios, warp-arbundles)
	  // TODO: Expose Auth0 client and/or accessToken for developers to use on their own backend?
	  constructor(options = DEFAULT_OTHENT_OPTIONS) {
	    this.errorEventListenerHandler = new EventListenersHandler();
	    this.tokens = /* @__PURE__ */ new Set();
	    this.walletName = CLIENT_NAME;
	    this.walletVersion = CLIENT_VERSION;
	    this.config = DEFAULT_OTHENT_CONFIG;
	    this.appInfo = {
	      name: "",
	      version: ""
	    };
	    this.gatewayConfig = DEFAULT_GATEWAY_CONFIG;
	    let {
	      appName,
	      appVersion,
	      persistCookie,
	      persistLocalStorage,
	      auth0Cache = DEFAULT_OTHENT_CONFIG.auth0Cache,
	      auth0RedirectURI,
	      auth0ReturnToURI,
	      gatewayConfig,
	      initialUserDetails,
	      ...configOptions
	    } = options;
	    const defaultRedirectURI = typeof location === "undefined" ? null : location.origin;
	    this.config = {
	      ...mergeOptions(configOptions, DEFAULT_OTHENT_CONFIG),
	      cookieKey: typeof persistCookie === "string" ? persistCookie : persistCookie ? DEFAULT_COOKIE_KEY : null,
	      localStorageKey: typeof persistLocalStorage === "string" ? persistLocalStorage : persistLocalStorage ? DEFAULT_COOKIE_KEY : null,
	      auth0Cache: typeof auth0Cache === "object" ? "custom" : auth0Cache,
	      auth0RedirectURI: auth0RedirectURI || defaultRedirectURI,
	      auth0ReturnToURI: auth0ReturnToURI || defaultRedirectURI
	    };
	    const { config } = this;
	    const { cookieKey, localStorageKey } = config;
	    if (typeof cookieKey === "string" && !cookieKey.startsWith("othent")) {
	      throw new Error(
	        '`persistCookie` / `cookieKey` must start with "othent".'
	      );
	    }
	    if (typeof localStorageKey === "string" && !localStorageKey.startsWith("othent")) {
	      throw new Error(
	        '`persistLocalStorage` / `localStorageKey` must start with "othent".'
	      );
	    }
	    if (!config.auth0RedirectURI) {
	      throw new Error("`auth0RedirectURI` is required.");
	    }
	    if (!config.auth0ReturnToURI) {
	      throw new Error("`auth0ReturnToURI` is required.");
	    }
	    this.appInfo = {
	      name: appName,
	      version: appVersion
	    };
	    this.gatewayConfig = gatewayConfig || DEFAULT_GATEWAY_CONFIG;
	    let crypto2 = null;
	    if (typeof window !== "undefined") {
	      crypto2 = window.crypto;
	    } else if (typeof global !== "undefined") {
	      crypto2 = global.crypto;
	    } else {
	      throw new Error(
	        "A Crypto module is needed for Othent to work. If your environment doesn't natively provide one, you should polyfill it."
	      );
	    }
	    this.crypto = crypto2;
	    if (config.autoConnect === "eager" && config.auth0LogInMethod === "popup" && config.auth0Strategy === "refresh-tokens" && auth0Cache === "memory") {
	      throw new Error(
	        'The browser cannot open the authentication modal automatically before an user interaction. Use `autoConnect = "lazy"` or change any of these other options: `auth0LogInMethod`, `auth0Strategy` or `auth0Cache`.'
	      );
	    }
	    this.auth0 = new OthentAuth0Client({
	      debug: config.debug,
	      domain: config.auth0Domain,
	      clientId: config.auth0ClientId,
	      strategy: config.auth0Strategy,
	      cache: auth0Cache,
	      refreshTokenExpirationMs: config.auth0RefreshTokenExpirationMs,
	      redirectURI: config.auth0RedirectURI,
	      returnToURI: config.auth0ReturnToURI,
	      loginMethod: config.auth0LogInMethod,
	      appInfo: this.appInfo,
	      initialUserDetails,
	      cookieKey: config.cookieKey,
	      localStorageKey: config.localStorageKey
	    });
	    if (this.config.autoConnect === "eager") {
	      let shouldAutoConnect = typeof location === "undefined";
	      if (!shouldAutoConnect) {
	        const url = new URL(location.href);
	        const { searchParams } = url;
	        if (!searchParams.has("code") && !searchParams.has("state")) {
	          shouldAutoConnect = true;
	        }
	      }
	      if (shouldAutoConnect) this.connect();
	    }
	    if (config.inject) {
	      window.arweaveWallet = this;
	    }
	    if (!config.throwErrors) {
	      const walletMethods = [
	        "connect",
	        "disconnect",
	        "getActiveAddress",
	        "getActivePublicKey",
	        "getAllAddresses",
	        "getWalletNames",
	        "getUserDetails",
	        "getSyncActiveAddress",
	        "getSyncActivePublicKey",
	        "getSyncAllAddresses",
	        "getSyncWalletNames",
	        "getSyncUserDetails",
	        "sign",
	        "dispatch",
	        "encrypt",
	        "decrypt",
	        "signature",
	        "signDataItem",
	        "signMessage",
	        "verifyMessage",
	        "privateHash",
	        "getArweaveConfig",
	        "getPermissions"
	      ];
	      walletMethods.forEach((walletMethod) => {
	        let fn = this[walletMethod];
	        if (typeof fn !== "function") return;
	        fn = fn.bind(this);
	        this[walletMethod] = (...args) => {
	          try {
	            let result = fn(...args);
	            if (isPromise(result)) {
	              result = result.catch((err) => {
	                this.onError(err);
	                return null;
	              });
	            }
	            return result;
	          } catch (err) {
	            this.onError(err);
	          }
	          return null;
	        };
	      });
	    }
	    this.api = new OthentKMSClient(this.config.serverBaseURL, this.auth0);
	  }
	  /**
	   * Start listening for `storage` events to sync user details across tabs. Only needed if `persistLocalStorage = true`.
	   *
	   * @returns A cleanup function that must be called whenever Othent needs to stop listening for `storage` events (e.g.
	   * to be used in React's `useEffects`'s cleanup function).
	   */
	  startTabSynching() {
	    if (!this.config.localStorageKey) {
	      console.warn(
	        "Calling `Othent.startTabSynching()` is a NOOP unless the `persistLocalStorage` option is used."
	      );
	    }
	    this.auth0.initStorageSyncing();
	    return () => {
	      this.auth0.stopStorageSyncing();
	    };
	  }
	  /**
	   *
	   * @param callbackUriWithParams
	   * @returns
	   */
	  async completeConnectionAfterRedirect(callbackUriWithParams) {
	    if (this.config.auth0LogInMethod !== "redirect") {
	      console.warn(
	        'Calling `Othent.completeConnectionAfterRedirect()` is a NOOP unless the `auth0LogInMethod` options is `"redirect"`.'
	      );
	    }
	    const urlString = callbackUriWithParams || (typeof location === "undefined" ? "" : location.href);
	    const urlObject = new URL(urlString.replace(/.+\.auth0:\/\//, "https://"));
	    const { searchParams } = urlObject;
	    if (!searchParams.has("code") || !searchParams.has("state") || !urlString)
	      return null;
	    let userDetails = null;
	    try {
	      userDetails = await this.auth0.handleRedirectCallback(urlString);
	    } finally {
	      if (typeof location !== "undefined" && typeof history !== "undefined") {
	        searchParams.delete("code");
	        searchParams.delete("state");
	        history.replaceState(null, "", urlObject);
	      }
	    }
	    return userDetails;
	  }
	  /**
	   * @returns `true` if Othent's Auth0 client has been initialized; `false` otherwise.
	   */
	  get isReady() {
	    return this.auth0.isReady;
	  }
	  // ERROR EVENT / ERROR HANDLING:
	  onError(error) {
	    if (!(error instanceof Error)) {
	      console.warn("Unknown error type", error);
	      return;
	    }
	    if (this.errorEventListenerHandler.hasListeners) {
	      this.errorEventListenerHandler.emit(error);
	    } else {
	      console.warn(
	        "Unhandled unthrown error:\n",
	        error,
	        '\nWhen using `throwErrors = false`, you must add at least one error event listener with `othent.addEventListener("error", () => { ... })`'
	      );
	    }
	  }
	  /**
	   * Add an event listener for the specific error type.
	   *
	   * @param type `"auth"` or `error`.
	   * @param listener Function of type `AuthListener` or `ErrorListener`.
	   * @returns A cleanup function that will remove the error listener when called.
	   */
	  addEventListener(type, listener) {
	    let eventListenerHandler = null;
	    if (type === "auth") {
	      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
	    } else if (type === "error") {
	      if (this.config.throwErrors)
	        throw new Error(
	          "You can only listen for `error` events if `throwErrors = false`."
	        );
	      eventListenerHandler = this.errorEventListenerHandler;
	    }
	    if (!eventListenerHandler) throw new Error("Unknown event type");
	    eventListenerHandler.add(listener);
	    return () => {
	      eventListenerHandler.delete(listener);
	    };
	  }
	  /**
	   * Remove an error listener of the specified error type.
	   *
	   * @param type `"auth"` or `error`.
	   * @param listener Function of type `AuthListener` or `ErrorListener`.
	   */
	  removeEventListener(type, listener) {
	    let eventListenerHandler = null;
	    if (type === "auth") {
	      eventListenerHandler = this.auth0.getAuthEventListenerHandler();
	    } else if (type === "error") {
	      eventListenerHandler = this.errorEventListenerHandler;
	    }
	    if (!eventListenerHandler) throw new Error("Unknown event type");
	    eventListenerHandler.delete(listener);
	  }
	  // AUTH LOADING:
	  /**
	   * @returns `true` if the user is authenticated; `false` otherwise.
	   */
	  get isAuthenticated() {
	    return this.auth0.isAuthenticated;
	  }
	  /**
	   * Automatically checks if the user is authenticated. If they are not, and...
	   *
	   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
	   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
	   *   to sign in/up again. It throws an error if authentication fails.
	   * - `autoConnect === "off"`: It throws an error.
	   */
	  requireAuth() {
	    return this.requireUserDataOrThrow().then(() => {
	    });
	  }
	  /**
	   * Automatically checks if the user is authenticated. If they are not, and...
	   *
	   * - `autoConnect === "eager"`: Prompts them to sign in/up again. It throws an error if authentication fails.
	   * - `autoConnect === "lazy"`: Authenticates them automatically, either from an existing session or by prompting them
	   *   to sign in/up again. It throws an error if authentication fails.
	   * - `autoConnect === "off"`: It throws an error.
	   *
	   * @returns `Promise<{ sub, publicKey }>` to get these 2 properties required in most Othent functions.
	   */
	  async requireUserDataOrThrow() {
	    if (this.config.autoConnect !== "off" && !this.auth0.isAuthenticated) {
	      await this.connect(void 0, void 0, this.gatewayConfig);
	    }
	    const { sub, owner } = this.auth0.getCachedUserDetails() || {};
	    if (!sub || !owner) throw new Error("Missing cached user.");
	    return {
	      sub,
	      publicKey: owner
	    };
	  }
	  // CONNECT / DISCONNECT:
	  /**
	   * Prompts the user to sign in/up using Auth0's modal. This function cannot be called programmatically before the user
	   * interacts with the page (e.g. by clicking on a button), as that will result in a `Unable to open a popup` error.
	   *
	   * @returns A Promise with the `UserDetails` or `null` if the log in modal was closed, could not even be opened or
	   * authentication failed.
	   */
	  async connect(permissions, appInfo, gateway) {
	    if (permissions && permissions.toSorted().join("-") !== _Othent.ALL_PERMISSIONS.join("-")) {
	      throw new Error(
	        "Othent implicitly has access to all available permissions. You should pass `permissions = undefined` or include all of them."
	      );
	    }
	    if (appInfo) {
	      this.appInfo = appInfo;
	      this.auth0.setAppInfo(appInfo);
	    }
	    this.gatewayConfig = gateway || DEFAULT_GATEWAY_CONFIG;
	    let id_token = "";
	    let userDetails = null;
	    try {
	      const response = await this.auth0.getTokenSilently();
	      id_token = response.id_token;
	      userDetails = response.userDetails;
	    } catch (err) {
	      if (!(err instanceof Error)) throw err;
	      if (err.message !== "Login required" && !(err instanceof f)) {
	        throw err;
	      }
	      console.warn(err.message);
	    }
	    if (!id_token) {
	      try {
	        const response = await this.auth0.logIn();
	        id_token = response.id_token;
	        userDetails = response.userDetails;
	      } catch (err) {
	        if (!(err instanceof Error)) throw err;
	        if (err.message === "Redirecting...") await new Promise(() => {
	        });
	        if (err.message.startsWith("Unable to open a popup") || err instanceof p$1 || err instanceof h$1) {
	          if (err instanceof h$1) err.popup.close();
	          console.warn(err.message);
	          return null;
	        }
	        throw err;
	      }
	    }
	    if (id_token && !userDetails) {
	      await this.api.createUser(id_token);
	      const response = await this.auth0.getTokenSilently();
	      id_token = response.id_token;
	      userDetails = response.userDetails;
	    }
	    if (id_token && userDetails) return userDetails;
	    this.auth0.logOut();
	    throw new Error("Unexpected authentication error");
	  }
	  /**
	   * Logs out the user (disconnect the user's wallet). This will require the user to log back in after called.
	   */
	  async disconnect() {
	    return this.auth0.logOut();
	  }
	  // GET DATA (ASYNC):
	  /**
	   * Returns the Arweave wallet address associated with the active (authenticated) user account.
	   *
	   * The wallet address is derived from the corresponding public key (see [`getActivePublicKey()`](get-active-public-key.md)).
	   *
	   * This function assumes (and requires) a user is authenticated.
	   *
	   * @returns A Promise with the active wallet address of the users wallet.
	   */
	  getActiveAddress() {
	    return Promise.resolve(this.getSyncActiveAddress());
	  }
	  /**
	   * Returns the public key (`jwk.n` field) associated with the active (authenticated) user account.
	   *
	   * This function assumes (and requires) a user is authenticated.
	   *
	   * @returns A Promise with the owner (jwk.n field) of the users wallet.
	   */
	  getActivePublicKey() {
	    return Promise.resolve(this.getSyncActivePublicKey());
	  }
	  /**
	   * Returns an array of Arweave wallet addresses associated with the active (authenticated) user account.
	   *
	   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
	   * account, so this function will always return exactly one wallet address.
	   *
	   * This function assumes (and requires) a user is authenticated.
	   *
	   * @returns A Promise with an array of all wallet addresses of the users wallet.
	   */
	  getAllAddresses() {
	    return Promise.resolve(this.getSyncAllAddresses());
	  }
	  /**
	   * Similarly to ArConnect, each wallet in Othent has a nickname. This is either:
	   *
	   * - The user's [ANS](https://ans.gg) name.
	   * - A platform + email identifying label (e.g. `Google (email@gmail.com)`, `Twitter (email@outlook.com)`...).
	   *
	   * To provide better UX, you can retrieve these names and display them to the user, so that they can easily recognize
	   * which wallet they're using.
	   *
	   * However, note that Othent does not currently support creating/storing more than one wallet associated to the same
	   * account, so this function will always return exactly one wallet address.
	   *
	   * This function assumes (and requires) a user is authenticated.
	   *
	   * @returns A Promise containing an object that maps each wallet addresses to their nickname.
	   */
	  getWalletNames() {
	    return Promise.resolve(this.getSyncWalletNames());
	  }
	  /**
	   * Returns an object with all the user details of the active (authenticated) user account.
	   *
	   * @returns A Promise containing all the user details of the active user, or `null` if the user is not authenticated.
	   */
	  getUserDetails() {
	    return Promise.resolve(this.getSyncUserDetails());
	  }
	  // GET DATA (SYNC):
	  /**
	   * Get the active wallet address of the users wallet. This function assumes (and requires) a user is authenticated.
	   * @returns The active wallet address of the users wallet.
	   */
	  getSyncActiveAddress() {
	    return this.auth0.getCachedUserAddress() || "";
	  }
	  /**
	   * Get the owner (jwk.n) field of the users wallet. This function assumes (and requires) a user is authenticated.
	   * @returns The owner (jwk.n) field of the users wallet.
	   */
	  getSyncActivePublicKey() {
	    return this.auth0.getCachedUserPublicKey() || "";
	  }
	  /**
	   * Get all addresses of the users wallet. This function assumes (and requires) a user is authenticated.
	   * @returns All wallet addresses of the users wallet.
	   */
	  getSyncAllAddresses() {
	    const address = this.auth0.getCachedUserAddress();
	    return address ? [address] : [];
	  }
	  /**
	   * Get the wallets (users) email. This function assumes (and requires) a user is authenticated.
	   * @returns The wallets (users) email.
	   */
	  getSyncWalletNames() {
	    const address = this.auth0.getCachedUserAddress();
	    const addressLabel = this.auth0.getCachedUserAddressLabel();
	    return Promise.resolve(
	      address && addressLabel ? {
	        [address]: addressLabel
	      } : {}
	    );
	  }
	  /**
	   * Get user details. This function assumes (and requires) a user is authenticated.
	   * @returns The user's details.
	   */
	  getSyncUserDetails() {
	    return this.auth0.getCachedUserDetails();
	  }
	  addCommonTags(transactionOrTags = []) {
	    if (Array.isArray(transactionOrTags)) {
	      const appInfoTags = [
	        { name: "App-Name", value: this.appInfo.name },
	        { name: "App-Version", value: this.appInfo.version }
	      ];
	      return [
	        ...transactionOrTags,
	        ...this.config.tags,
	        ...appInfoTags,
	        ...ANALYTICS_TAGS
	      ];
	    }
	    for (const { name, value } of this.config.tags) {
	      transactionOrTags.addTag(name, value);
	    }
	    transactionOrTags.addTag("App-Name", this.appInfo.name);
	    transactionOrTags.addTag("App-Version", this.appInfo.version);
	    for (const { name, value } of ANALYTICS_TAGS) {
	      transactionOrTags.addTag(name, value);
	    }
	  }
	  /**
	   * To submit a transaction to the Arweave Network, it first has to be signed using a private key. Othent creates a private
	   * key / Arweave wallet for every account and stores it in Google KMS. The wallet associated with the active user account
	   * is used to sign transactions using the `sign()` function.
	   *
	   * The `sign()` function is meant to replicate the behavior of the `transactions.sign()` function of
	   * [`arweave-js`](https://github.com/arweaveTeam/arweave-js#sign-a-transaction), but instead of mutating the transaction
	   * object, it returns a new and signed transaction instance.
	   *
	   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
	   *
	   * @param transaction The transaction to sign.
	   *
	   * @returns A Promise containing a new signed transaction.
	   */
	  async sign(transaction) {
	    const { sub, publicKey } = await this.requireUserDataOrThrow();
	    const arweave = initArweave(this.gatewayConfig);
	    const transactionTags = transaction.get("tags").map(
	      (tag) => ({
	        name: tag.get("name", { decode: true, string: true }),
	        value: tag.get("value", { decode: true, string: true })
	      })
	    );
	    const tags = this.addCommonTags(transactionTags);
	    const transactionToSign = await arweave.createTransaction({
	      data: transaction.data,
	      owner: publicKey,
	      reward: transaction.reward
	    });
	    tags.forEach((tagData) => {
	      transactionToSign.addTag(tagData.name, tagData.value);
	    });
	    const dataToSign = await transactionToSign.getSignatureData();
	    const signatureBuffer = await this.api.sign(dataToSign, sub);
	    const id = await hash(signatureBuffer);
	    transactionToSign.setSignature({
	      id: uint8ArrayTob64Url(id),
	      owner: publicKey,
	      signature: uint8ArrayTob64Url(signatureBuffer),
	      tags: transactionToSign.tags,
	      reward: transactionToSign.reward
	    });
	    return transactionToSign;
	  }
	  /**
	   * The `dispatch()` function allows you to quickly sign and send a transaction to the network in a bundled format. It is
	   * best for smaller datas and contract interactions. If the bundled transaction cannot be submitted, it will fall back to a
	   * base layer transaction. The function returns the [result](dispatch.md#dispatch-result) of the API call.
	   *
	   * This function assumes (and requires) a user is authenticated and a valid arweave transaction.
	   *
	   * @param transaction The transaction to sign and dispatch.
	   *
	   * @returns The signed version of the transaction.
	   */
	  async dispatch(transaction, options) {
	    var _a;
	    const transactionTags = transaction.get("tags").map(
	      (tag) => ({
	        name: tag.get("name", { decode: true, string: true }),
	        value: tag.get("value", { decode: true, string: true })
	      })
	    );
	    const signedDataItemBuffer = await this.signDataItem({
	      data: transaction.data,
	      tags: transactionTags,
	      target: transaction.target
	    });
	    const url = `${(options == null ? void 0 : options.node) || DEFAULT_DISPATCH_NODE}/tx`;
	    try {
	      const res = await axios3.post(
	        url,
	        signedDataItemBuffer,
	        {
	          headers: {
	            "Content-Type": "application/octet-stream"
	          },
	          maxBodyLength: Infinity,
	          maxContentLength: Infinity,
	          responseType: "json"
	        }
	      );
	      if (res.status >= 400) {
	        throw new Error(`${res.status} - ${JSON.stringify(res.data)}`);
	      }
	      return {
	        ...res.data,
	        type: "BUNDLED"
	      };
	    } catch (err) {
	      console.warn(`Error dispatching transaction to ${url} =
`, err);
	      const signedTransaction = await this.sign(transaction);
	      const arweave = (_a = options == null ? void 0 : options.arweave) != null ? _a : initArweave(this.gatewayConfig);
	      const uploader = await arweave.transactions.getUploader(signedTransaction);
	      while (!uploader.isComplete) {
	        await uploader.uploadChunk();
	      }
	      return {
	        id: signedTransaction.id,
	        signature: signedTransaction.signature,
	        owner: signedTransaction.owner,
	        type: "BASE"
	      };
	    }
	  }
	  // ENCRYPT/DECRYPT:
	  /**
	   * Encrypt data with the users JWK.
	   *
	   * This function assumes (and requires) a user is authenticate.
	   *
	   * @param plaintext The data in string format to sign.
	   *
	   * @returns The encrypted data.
	   */
	  async encrypt(plaintext) {
	    const { sub } = await this.requireUserDataOrThrow();
	    const ciphertextBuffer = await this.api.encrypt(plaintext, sub);
	    return ciphertextBuffer;
	  }
	  /**
	   * Decrypt data with the users JWK.
	   *
	   * This function assumes (and requires) a user is authenticated.
	   *
	   * @param ciphertext The data to decrypt.
	   *
	   * @returns The decrypted data.
	   */
	  async decrypt(ciphertext) {
	    const { sub } = await this.requireUserDataOrThrow();
	    const plaintext = await this.api.decrypt(ciphertext, sub);
	    return plaintext;
	  }
	  // SIGN:
	  // TODO: Add deprecation warning (and update all TSDocs according to what's on ArConnect and add references to their docs).
	  /**
	   * Generate a signature. This function assumes (and requires) a user is authenticated.
	   * @param data The data to sign.
	   * @returns The {@linkcode Buffer} format of the signature.
	   * @deprecated Use `sign`, `signDataItems` or `signMessage` instead.
	   */
	  async signature(data) {
	    const { sub } = await this.requireUserDataOrThrow();
	    const signatureBuffer = await this.api.sign(data, sub);
	    return signatureBuffer;
	  }
	  /**
	   * The signDataItem() function allows you to create and sign a data item object, compatible with arbundles. These data
	   * items can then be submitted to an ANS-104 compatible bundler.
	   * @param dataItem The data to sign.
	   * @returns The signed data item.
	   */
	  async signDataItem(dataItem) {
	    const { sub, publicKey } = await this.requireUserDataOrThrow();
	    const { data, tags, ...options } = dataItem;
	    const signer = {
	      publicKey: toBuffer(publicKey),
	      // => Buffer.from(toBase64(base64url), "base64");
	      // publicKey: Buffer.from(publicKey, "base64"),
	      signatureType: 1,
	      signatureLength: 512,
	      ownerLength: 512,
	      sign: this.api.getSignerSignFn(sub)
	      // Note we don't provide `verify` as it's not used anyway:
	      // verify: () => true,
	    };
	    const opts = {
	      ...options,
	      tags: this.addCommonTags(tags)
	    };
	    const dataItemInstance = ge$1(data, signer, opts);
	    await dataItemInstance.sign(signer);
	    return dataItemInstance.getRaw().buffer;
	  }
	  /**
	   * Sign the given message. This function assumes (and requires) a user is authenticated.
	   * @param message The message to sign.
	   * @returns The signed version of the message.
	   */
	  async signMessage(data, options) {
	    const { sub } = await this.requireUserDataOrThrow();
	    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
	    const hashArrayBuffer = await this.crypto.subtle.digest(
	      hashAlgorithm,
	      binaryDataTypeOrStringToBinaryDataType(data)
	    );
	    const signatureBuffer = await this.api.sign(hashArrayBuffer, sub);
	    return signatureBuffer;
	  }
	  /**
	   * Verify the given message. This function assumes (and requires) a user is authenticated.
	   * @param signature The signature to verify.
	   * @returns The signed version of the message.
	   */
	  async verifyMessage(data, signature, publicKey, options = { hashAlgorithm: "SHA-256" }) {
	    if (!publicKey) {
	      const requiredUserData = await this.requireUserDataOrThrow();
	      publicKey || (publicKey = requiredUserData.publicKey);
	    }
	    const hashAlgorithm = (options == null ? void 0 : options.hashAlgorithm) || "SHA-256";
	    const hashArrayBuffer = await this.crypto.subtle.digest(
	      hashAlgorithm,
	      binaryDataTypeOrStringToBinaryDataType(data)
	    );
	    const publicJWK = {
	      e: "AQAB",
	      ext: true,
	      kty: "RSA",
	      n: publicKey
	    };
	    const cryptoKey = await this.crypto.subtle.importKey(
	      "jwk",
	      publicJWK,
	      {
	        name: "RSA-PSS",
	        hash: options.hashAlgorithm
	      },
	      false,
	      ["verify"]
	    );
	    const result = await this.crypto.subtle.verify(
	      { name: "RSA-PSS", saltLength: 32 },
	      cryptoKey,
	      binaryDataTypeOrStringToBinaryDataType(signature),
	      hashArrayBuffer
	    );
	    return result;
	  }
	  /**
	   * Create a deterministic secret based on the input data.
	   *
	   * @param data Input data to generate the hash from.
	   * @param options Hash algorithm (default = `SHA-256`).
	   *
	   * @returns Hash `Uint8Array`.
	   */
	  async privateHash(data, options) {
	    return hash(
	      binaryDataTypeOrStringToBinaryDataType(data),
	      options == null ? void 0 : options.hashAlgorithm
	    );
	  }
	  // MISC.:
	  /**
	   * Get the Arweave config used by Othent.
	   *
	   * @returns Promise of Othent's `GatewayConfig`.
	   */
	  getArweaveConfig() {
	    return Promise.resolve(this.gatewayConfig);
	  }
	  /**
	   * Get the permissions Othent can use in the current site.
	   *
	   * @returns Promise of Othent's `PermissionType[]`.
	   */
	  getPermissions() {
	    return Promise.resolve(_Othent.ALL_PERMISSIONS);
	  }
	  /**
	   * Mocked implementation to add tokens.
	   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
	   */
	  addToken(id, type, gateway) {
	    console.warn(
	      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
	    );
	    this.tokens.add(id);
	    return Promise.resolve();
	  }
	  /**
	   * Mocked implementation to check if a token has been added.
	   * Othent doesn't currently support this feature and only tracks added tokens temporarily in memory.
	   */
	  isTokenAdded(id) {
	    console.warn(
	      "Othent doesn't currently support this feature and only tracks added tokens temporarily in memory."
	    );
	    return Promise.resolve(this.tokens.has(id));
	  }
	};
	_Othent.walletName = CLIENT_NAME;
	_Othent.walletVersion = CLIENT_VERSION;
	_Othent.ALL_PERMISSIONS = [
	  "ACCESS_ADDRESS",
	  "ACCESS_ALL_ADDRESSES",
	  "ACCESS_ARWEAVE_CONFIG",
	  "ACCESS_PUBLIC_KEY",
	  "DECRYPT",
	  "DISPATCH",
	  "ENCRYPT",
	  "SIGN_TRANSACTION",
	  "SIGNATURE"
	];
	var Othent = _Othent;

	// src/index.ts
	window.Buffer = bufferExports.Buffer;

	// Function to convert PEM encoded public key to a format usable by the Web Crypto API
	function pemToBuffer(pem) {
	  // Remove the first and last lines (headers), and all line breaks
	  const base64String = pem.replace(/-----BEGIN PUBLIC KEY-----/, '').replace(/-----END PUBLIC KEY-----/, '').replace(/\s/g, ''); // remove all whitespace, not just line breaks
	  const binaryString = window.atob(base64String);
	  const bytes = new Uint8Array(binaryString.length);
	  for (let i = 0; i < binaryString.length; i++) {
	    bytes[i] = binaryString.charCodeAt(i);
	  }
	  return bytes.buffer;
	}

	// Function to encrypt data using RSA
	async function rsaEncrypt(publicKeyPem, data) {
	  try {
	    const publicKeyBuffer = pemToBuffer(publicKeyPem);
	    const importedKey = await window.crypto.subtle.importKey('spki', publicKeyBuffer, {
	      name: 'RSA-OAEP',
	      hash: {
	        name: 'SHA-256'
	      }
	    }, true, ['encrypt']);
	    const encrypted = await window.crypto.subtle.encrypt({
	      name: 'RSA-OAEP'
	    }, importedKey, new TextEncoder().encode(data));
	    return bufferToBase64(encrypted);
	  } catch (error) {
	    console.error("rsaEncrypt error:", error);
	    return null;
	  }
	}

	// Function to convert ArrayBuffer to Base64
	function bufferToBase64(buffer) {
	  try {
	    let binary = '';
	    const bytes = new Uint8Array(buffer);
	    const len = bytes.byteLength;
	    for (let i = 0; i < len; i++) {
	      binary += String.fromCharCode(bytes[i]);
	    }
	    return window.btoa(binary);
	  } catch (e) {
	    console.error("Eror in buffertoBase64 : ", e);
	  }
	}

	async function getPin(hashedOthentSub) {
	  const jsonData = {
	    Info: {
	      'hashedOthentSub': hashedOthentSub
	    },
	    request: 'PIN'
	  };
	  return await fetch('https://api2.onairos.uk/getAccountInfoFromOthentSub', {
	    // return await fetch('http://localhost:8080/getAccountInfoFromOthentSub', {
	    method: 'POST',
	    headers: {
	      'Content-Type': 'application/json'
	    },
	    body: JSON.stringify(jsonData)
	  }).then(response => response.json()).then(data => {
	    return data;
	  }).catch(error => console.error(error));
	}

	const authenticateWithBiometrics = async () => {
	  if (!window.PublicKeyCredential) {
	    throw new Error('WebAuthn not supported');
	  }
	  try {
	    const supported = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
	    if (!supported) {
	      throw new Error('Biometric authentication not available');
	    }

	    // Trigger FaceID/TouchID
	    const credential = await navigator.credentials.get({
	      publicKey: {
	        challenge: new Uint8Array(32),
	        rpId: window.location.hostname,
	        userVerification: 'required'
	      }
	    });
	    return !!credential;
	  } catch (error) {
	    console.error('Biometric authentication failed:', error);
	    return false;
	  }
	};

	function OnairosAppButton(_ref) {
	  let {
	    onLoginSuccess
	  } = _ref;
	  const [loading, setLoading] = reactExports.useState(false);
	  const verifySavedCredentials = async () => {
	    const savedCredentials = localStorage.getItem('onairosCredentials');
	    if (!savedCredentials) return null;
	    try {
	      const credentials = JSON.parse(savedCredentials);
	      const response = await fetch('https://api2.onairos.uk/verify', {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify({
	          username: credentials.username,
	          token: credentials.token
	        })
	      });
	      if (!response.ok) {
	        localStorage.removeItem('onairosCredentials');
	        return null;
	      }
	      return credentials;
	    } catch (error) {
	      console.error('Verification failed:', error);
	      return null;
	    }
	  };
	  const handleAppLogin = async () => {
	    setLoading(true);
	    try {
	      const credentials = await verifySavedCredentials();
	      if (credentials) {
	        const isAuthenticated = await authenticateWithBiometrics();
	        if (isAuthenticated) {
	          await onLoginSuccess(credentials.username);
	          return;
	        }
	      }

	      // If no credentials or biometrics failed, launch app
	      const nonce = Date.now();
	      const returnLink = encodeURIComponent(window.location.origin + '/auth/callback');
	      const onairosUrl = `onairos://authenticate?nonce=${nonce}&callback=${returnLink}&appName=google`;
	      window.location.href = onairosUrl;

	      // Fallback to app store after timeout
	      setTimeout(() => {
	        window.location.href = 'https://apps.apple.com/app/onairos/id123456789';
	      }, 2500);
	    } catch (error) {
	      console.error('App login failed:', error);
	    } finally {
	      setLoading(false);
	    }
	  };
	  return /*#__PURE__*/React.createElement("div", {
	    className: "flex flex-col items-center"
	  }, /*#__PURE__*/React.createElement("button", {
	    onClick: handleAppLogin,
	    disabled: loading,
	    className: "w-12 h-12 rounded-full shadow-md hover:shadow-lg transition-shadow duration-200 flex items-center justify-center bg-white"
	  }, /*#__PURE__*/React.createElement("img", {
	    src: "https://onairos.sirv.com/Images/OnairosBlack.png",
	    alt: "Onairos",
	    className: "w-10 h-6"
	  })), /*#__PURE__*/React.createElement("span", {
	    className: "text-xs mt-2 text-gray-600"
	  }, "Login with App"));
	}

	function TestTelegramButton() {
	  const [error, setError] = reactExports.useState(null);
	  const [logs, setLogs] = reactExports.useState([]);
	  const addLog = message => {
	    setLogs(prevLogs => [...prevLogs, message]);
	  };
	  const handleClick = () => {
	    try {
	      addLog('Opening external browser...');
	      const data = {
	        key: 'value'
	      }; // Example data
	      const queryString = new URLSearchParams(data).toString();
	      const testUrl = `https://internship.onairos.uk/auth?${queryString}`;
	      // const testUrl = `https://onairos.uk/auth?${queryString}`;

	      // Use standard JavaScript to open the link in a new tab
	      window.open(testUrl, '_blank');
	    } catch (error) {
	      console.error('Failed to open link:', error);
	      addLog(`Failed to open link: ${error.message}`);
	      setError(`Failed to open link: ${error.message}`);
	    }
	  };
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "flex flex-col items-center p-4"
	  }, /*#__PURE__*/React$1.createElement("button", {
	    onClick: handleClick,
	    className: "flex flex-col items-center justify-center px-4 py-2 border border-gray-300 rounded-full shadow-sm bg-white hover:bg-gray-50"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "relative"
	  }, /*#__PURE__*/React$1.createElement("img", {
	    src: "google-icon.png",
	    alt: "Google",
	    className: "w-10 h-10 rounded-full"
	  }), /*#__PURE__*/React$1.createElement("svg", {
	    className: "absolute bottom-0 right-0 w-4 h-4",
	    fill: "currentColor",
	    viewBox: "0 0 20 20"
	  }, /*#__PURE__*/React$1.createElement("path", {
	    d: "M10 3a1 1 0 011 1v6h6a1 1 0 110 2h-6v6a1 1 0 11-2 0v-6H3a1 1 0 110-2h6V4a1 1 0 011-1z"
	  }))), /*#__PURE__*/React$1.createElement("span", {
	    className: "text-gray-700 mt-2"
	  }, "Google")));
	}

	function AuthButtons(_ref) {
	  let {
	    onLoginSuccess,
	    setOthent,
	    setHashedOthentSub,
	    setEncryptedPin
	  } = _ref;
	  const [hasSavedCredentials, setHasSavedCredentials] = reactExports.useState(false);
	  reactExports.useEffect(() => {
	    checkSavedCredentials();
	  }, []);
	  const checkSavedCredentials = async () => {
	    const credentials = localStorage.getItem('onairosCredentials');
	    setHasSavedCredentials(!!credentials);
	  };
	  return /*#__PURE__*/React.createElement("div", {
	    className: "flex flex-row justify-center items-center space-x-4"
	  }, /*#__PURE__*/React.createElement(TestTelegramButton, null), /*#__PURE__*/React.createElement(OnairosAppButton, {
	    hasSavedCredentials: hasSavedCredentials,
	    onSuccess: onLoginSuccess
	  }));
	}

	var propTypes = {exports: {}};

	var reactIs = {exports: {}};

	var reactIs_production_min = {};

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactIs_production_min;

	function requireReactIs_production_min () {
		if (hasRequiredReactIs_production_min) return reactIs_production_min;
		hasRequiredReactIs_production_min = 1;

		var b = "function" === typeof Symbol && Symbol.for,
		  c = b ? Symbol.for("react.element") : 60103,
		  d = b ? Symbol.for("react.portal") : 60106,
		  e = b ? Symbol.for("react.fragment") : 60107,
		  f = b ? Symbol.for("react.strict_mode") : 60108,
		  g = b ? Symbol.for("react.profiler") : 60114,
		  h = b ? Symbol.for("react.provider") : 60109,
		  k = b ? Symbol.for("react.context") : 60110,
		  l = b ? Symbol.for("react.async_mode") : 60111,
		  m = b ? Symbol.for("react.concurrent_mode") : 60111,
		  n = b ? Symbol.for("react.forward_ref") : 60112,
		  p = b ? Symbol.for("react.suspense") : 60113,
		  q = b ? Symbol.for("react.suspense_list") : 60120,
		  r = b ? Symbol.for("react.memo") : 60115,
		  t = b ? Symbol.for("react.lazy") : 60116,
		  v = b ? Symbol.for("react.block") : 60121,
		  w = b ? Symbol.for("react.fundamental") : 60117,
		  x = b ? Symbol.for("react.responder") : 60118,
		  y = b ? Symbol.for("react.scope") : 60119;
		function z(a) {
		  if ("object" === typeof a && null !== a) {
		    var u = a.$$typeof;
		    switch (u) {
		      case c:
		        switch (a = a.type, a) {
		          case l:
		          case m:
		          case e:
		          case g:
		          case f:
		          case p:
		            return a;
		          default:
		            switch (a = a && a.$$typeof, a) {
		              case k:
		              case n:
		              case t:
		              case r:
		              case h:
		                return a;
		              default:
		                return u;
		            }
		        }
		      case d:
		        return u;
		    }
		  }
		}
		function A(a) {
		  return z(a) === m;
		}
		reactIs_production_min.AsyncMode = l;
		reactIs_production_min.ConcurrentMode = m;
		reactIs_production_min.ContextConsumer = k;
		reactIs_production_min.ContextProvider = h;
		reactIs_production_min.Element = c;
		reactIs_production_min.ForwardRef = n;
		reactIs_production_min.Fragment = e;
		reactIs_production_min.Lazy = t;
		reactIs_production_min.Memo = r;
		reactIs_production_min.Portal = d;
		reactIs_production_min.Profiler = g;
		reactIs_production_min.StrictMode = f;
		reactIs_production_min.Suspense = p;
		reactIs_production_min.isAsyncMode = function (a) {
		  return A(a) || z(a) === l;
		};
		reactIs_production_min.isConcurrentMode = A;
		reactIs_production_min.isContextConsumer = function (a) {
		  return z(a) === k;
		};
		reactIs_production_min.isContextProvider = function (a) {
		  return z(a) === h;
		};
		reactIs_production_min.isElement = function (a) {
		  return "object" === typeof a && null !== a && a.$$typeof === c;
		};
		reactIs_production_min.isForwardRef = function (a) {
		  return z(a) === n;
		};
		reactIs_production_min.isFragment = function (a) {
		  return z(a) === e;
		};
		reactIs_production_min.isLazy = function (a) {
		  return z(a) === t;
		};
		reactIs_production_min.isMemo = function (a) {
		  return z(a) === r;
		};
		reactIs_production_min.isPortal = function (a) {
		  return z(a) === d;
		};
		reactIs_production_min.isProfiler = function (a) {
		  return z(a) === g;
		};
		reactIs_production_min.isStrictMode = function (a) {
		  return z(a) === f;
		};
		reactIs_production_min.isSuspense = function (a) {
		  return z(a) === p;
		};
		reactIs_production_min.isValidElementType = function (a) {
		  return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
		};
		reactIs_production_min.typeOf = z;
		return reactIs_production_min;
	}

	var reactIs_development = {};

	var hasRequiredReactIs_development;

	function requireReactIs_development () {
		if (hasRequiredReactIs_development) return reactIs_development;
		hasRequiredReactIs_development = 1;

		if (process.env.NODE_ENV !== "production") {
		  (function () {

		    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
		    // nor polyfill, then a plain number is used for performance.
		    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
		    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
		    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
		    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
		    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
		    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
		    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
		    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
		    // (unstable) APIs that have been removed. Can we remove the symbols?

		    var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
		    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
		    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
		    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
		    var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
		    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
		    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
		    var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
		    var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
		    var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
		    var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
		    function isValidElementType(type) {
		      return typeof type === 'string' || typeof type === 'function' ||
		      // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
		      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
		    }
		    function typeOf(object) {
		      if (typeof object === 'object' && object !== null) {
		        var $$typeof = object.$$typeof;
		        switch ($$typeof) {
		          case REACT_ELEMENT_TYPE:
		            var type = object.type;
		            switch (type) {
		              case REACT_ASYNC_MODE_TYPE:
		              case REACT_CONCURRENT_MODE_TYPE:
		              case REACT_FRAGMENT_TYPE:
		              case REACT_PROFILER_TYPE:
		              case REACT_STRICT_MODE_TYPE:
		              case REACT_SUSPENSE_TYPE:
		                return type;
		              default:
		                var $$typeofType = type && type.$$typeof;
		                switch ($$typeofType) {
		                  case REACT_CONTEXT_TYPE:
		                  case REACT_FORWARD_REF_TYPE:
		                  case REACT_LAZY_TYPE:
		                  case REACT_MEMO_TYPE:
		                  case REACT_PROVIDER_TYPE:
		                    return $$typeofType;
		                  default:
		                    return $$typeof;
		                }
		            }
		          case REACT_PORTAL_TYPE:
		            return $$typeof;
		        }
		      }
		      return undefined;
		    } // AsyncMode is deprecated along with isAsyncMode

		    var AsyncMode = REACT_ASYNC_MODE_TYPE;
		    var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
		    var ContextConsumer = REACT_CONTEXT_TYPE;
		    var ContextProvider = REACT_PROVIDER_TYPE;
		    var Element = REACT_ELEMENT_TYPE;
		    var ForwardRef = REACT_FORWARD_REF_TYPE;
		    var Fragment = REACT_FRAGMENT_TYPE;
		    var Lazy = REACT_LAZY_TYPE;
		    var Memo = REACT_MEMO_TYPE;
		    var Portal = REACT_PORTAL_TYPE;
		    var Profiler = REACT_PROFILER_TYPE;
		    var StrictMode = REACT_STRICT_MODE_TYPE;
		    var Suspense = REACT_SUSPENSE_TYPE;
		    var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

		    function isAsyncMode(object) {
		      {
		        if (!hasWarnedAboutDeprecatedIsAsyncMode) {
		          hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

		          console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
		        }
		      }
		      return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
		    }
		    function isConcurrentMode(object) {
		      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
		    }
		    function isContextConsumer(object) {
		      return typeOf(object) === REACT_CONTEXT_TYPE;
		    }
		    function isContextProvider(object) {
		      return typeOf(object) === REACT_PROVIDER_TYPE;
		    }
		    function isElement(object) {
		      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		    }
		    function isForwardRef(object) {
		      return typeOf(object) === REACT_FORWARD_REF_TYPE;
		    }
		    function isFragment(object) {
		      return typeOf(object) === REACT_FRAGMENT_TYPE;
		    }
		    function isLazy(object) {
		      return typeOf(object) === REACT_LAZY_TYPE;
		    }
		    function isMemo(object) {
		      return typeOf(object) === REACT_MEMO_TYPE;
		    }
		    function isPortal(object) {
		      return typeOf(object) === REACT_PORTAL_TYPE;
		    }
		    function isProfiler(object) {
		      return typeOf(object) === REACT_PROFILER_TYPE;
		    }
		    function isStrictMode(object) {
		      return typeOf(object) === REACT_STRICT_MODE_TYPE;
		    }
		    function isSuspense(object) {
		      return typeOf(object) === REACT_SUSPENSE_TYPE;
		    }
		    reactIs_development.AsyncMode = AsyncMode;
		    reactIs_development.ConcurrentMode = ConcurrentMode;
		    reactIs_development.ContextConsumer = ContextConsumer;
		    reactIs_development.ContextProvider = ContextProvider;
		    reactIs_development.Element = Element;
		    reactIs_development.ForwardRef = ForwardRef;
		    reactIs_development.Fragment = Fragment;
		    reactIs_development.Lazy = Lazy;
		    reactIs_development.Memo = Memo;
		    reactIs_development.Portal = Portal;
		    reactIs_development.Profiler = Profiler;
		    reactIs_development.StrictMode = StrictMode;
		    reactIs_development.Suspense = Suspense;
		    reactIs_development.isAsyncMode = isAsyncMode;
		    reactIs_development.isConcurrentMode = isConcurrentMode;
		    reactIs_development.isContextConsumer = isContextConsumer;
		    reactIs_development.isContextProvider = isContextProvider;
		    reactIs_development.isElement = isElement;
		    reactIs_development.isForwardRef = isForwardRef;
		    reactIs_development.isFragment = isFragment;
		    reactIs_development.isLazy = isLazy;
		    reactIs_development.isMemo = isMemo;
		    reactIs_development.isPortal = isPortal;
		    reactIs_development.isProfiler = isProfiler;
		    reactIs_development.isStrictMode = isStrictMode;
		    reactIs_development.isSuspense = isSuspense;
		    reactIs_development.isValidElementType = isValidElementType;
		    reactIs_development.typeOf = typeOf;
		  })();
		}
		return reactIs_development;
	}

	var hasRequiredReactIs;

	function requireReactIs () {
		if (hasRequiredReactIs) return reactIs.exports;
		hasRequiredReactIs = 1;

		if (process.env.NODE_ENV === 'production') {
		  reactIs.exports = requireReactIs_production_min();
		} else {
		  reactIs.exports = requireReactIs_development();
		}
		return reactIs.exports;
	}

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/

	var objectAssign;
	var hasRequiredObjectAssign;

	function requireObjectAssign () {
		if (hasRequiredObjectAssign) return objectAssign;
		hasRequiredObjectAssign = 1;

		/* eslint-disable no-unused-vars */
		var getOwnPropertySymbols = Object.getOwnPropertySymbols;
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		var propIsEnumerable = Object.prototype.propertyIsEnumerable;
		function toObject(val) {
		  if (val === null || val === undefined) {
		    throw new TypeError('Object.assign cannot be called with null or undefined');
		  }
		  return Object(val);
		}
		function shouldUseNative() {
		  try {
		    if (!Object.assign) {
		      return false;
		    }

		    // Detect buggy property enumeration order in older V8 versions.

		    // https://bugs.chromium.org/p/v8/issues/detail?id=4118
		    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		    test1[5] = 'de';
		    if (Object.getOwnPropertyNames(test1)[0] === '5') {
		      return false;
		    }

		    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
		    var test2 = {};
		    for (var i = 0; i < 10; i++) {
		      test2['_' + String.fromCharCode(i)] = i;
		    }
		    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
		      return test2[n];
		    });
		    if (order2.join('') !== '0123456789') {
		      return false;
		    }

		    // https://bugs.chromium.org/p/v8/issues/detail?id=3056
		    var test3 = {};
		    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
		      test3[letter] = letter;
		    });
		    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
		      return false;
		    }
		    return true;
		  } catch (err) {
		    // We don't expect any of the above to throw, but better to be safe.
		    return false;
		  }
		}
		objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		  var from;
		  var to = toObject(target);
		  var symbols;
		  for (var s = 1; s < arguments.length; s++) {
		    from = Object(arguments[s]);
		    for (var key in from) {
		      if (hasOwnProperty.call(from, key)) {
		        to[key] = from[key];
		      }
		    }
		    if (getOwnPropertySymbols) {
		      symbols = getOwnPropertySymbols(from);
		      for (var i = 0; i < symbols.length; i++) {
		        if (propIsEnumerable.call(from, symbols[i])) {
		          to[symbols[i]] = from[symbols[i]];
		        }
		      }
		    }
		  }
		  return to;
		};
		return objectAssign;
	}

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret_1;
	var hasRequiredReactPropTypesSecret;

	function requireReactPropTypesSecret () {
		if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
		hasRequiredReactPropTypesSecret = 1;

		var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
		ReactPropTypesSecret_1 = ReactPropTypesSecret;
		return ReactPropTypesSecret_1;
	}

	var has;
	var hasRequiredHas;

	function requireHas () {
		if (hasRequiredHas) return has;
		hasRequiredHas = 1;
		has = Function.call.bind(Object.prototype.hasOwnProperty);
		return has;
	}

	var checkPropTypes_1;
	var hasRequiredCheckPropTypes;

	function requireCheckPropTypes () {
		if (hasRequiredCheckPropTypes) return checkPropTypes_1;
		hasRequiredCheckPropTypes = 1;

		var printWarning = function () {};
		if (process.env.NODE_ENV !== 'production') {
		  var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();
		  var loggedTypeFailures = {};
		  var has = /*@__PURE__*/ requireHas();
		  printWarning = function (text) {
		    var message = 'Warning: ' + text;
		    if (typeof console !== 'undefined') {
		      console.error(message);
		    }
		    try {
		      // --- Welcome to debugging React ---
		      // This error was thrown as a convenience so that you can use this stack
		      // to find the callsite that caused this warning to fire.
		      throw new Error(message);
		    } catch (x) {/**/}
		  };
		}

		/**
		 * Assert that the values match with the type specs.
		 * Error messages are memorized and will only be shown once.
		 *
		 * @param {object} typeSpecs Map of name to a ReactPropType
		 * @param {object} values Runtime values that need to be type-checked
		 * @param {string} location e.g. "prop", "context", "child context"
		 * @param {string} componentName Name of the component for error messages.
		 * @param {?Function} getStack Returns the component stack.
		 * @private
		 */
		function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
		  if (process.env.NODE_ENV !== 'production') {
		    for (var typeSpecName in typeSpecs) {
		      if (has(typeSpecs, typeSpecName)) {
		        var error;
		        // Prop type validation may throw. In case they do, we don't want to
		        // fail the render phase where it didn't fail before. So we log it.
		        // After these have been cleaned up, we'll let them throw.
		        try {
		          // This is intentionally an invariant that gets caught. It's the same
		          // behavior as without this statement except with a better message.
		          if (typeof typeSpecs[typeSpecName] !== 'function') {
		            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
		            err.name = 'Invariant Violation';
		            throw err;
		          }
		          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
		        } catch (ex) {
		          error = ex;
		        }
		        if (error && !(error instanceof Error)) {
		          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
		        }
		        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
		          // Only monitor this failure once because there tends to be a lot of the
		          // same error.
		          loggedTypeFailures[error.message] = true;
		          var stack = getStack ? getStack() : '';
		          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
		        }
		      }
		    }
		  }
		}

		/**
		 * Resets warning cache when testing.
		 *
		 * @private
		 */
		checkPropTypes.resetWarningCache = function () {
		  if (process.env.NODE_ENV !== 'production') {
		    loggedTypeFailures = {};
		  }
		};
		checkPropTypes_1 = checkPropTypes;
		return checkPropTypes_1;
	}

	var factoryWithTypeCheckers;
	var hasRequiredFactoryWithTypeCheckers;

	function requireFactoryWithTypeCheckers () {
		if (hasRequiredFactoryWithTypeCheckers) return factoryWithTypeCheckers;
		hasRequiredFactoryWithTypeCheckers = 1;

		var ReactIs = requireReactIs();
		var assign = requireObjectAssign();
		var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();
		var has = /*@__PURE__*/ requireHas();
		var checkPropTypes = /*@__PURE__*/ requireCheckPropTypes();
		var printWarning = function () {};
		if (process.env.NODE_ENV !== 'production') {
		  printWarning = function (text) {
		    var message = 'Warning: ' + text;
		    if (typeof console !== 'undefined') {
		      console.error(message);
		    }
		    try {
		      // --- Welcome to debugging React ---
		      // This error was thrown as a convenience so that you can use this stack
		      // to find the callsite that caused this warning to fire.
		      throw new Error(message);
		    } catch (x) {}
		  };
		}
		function emptyFunctionThatReturnsNull() {
		  return null;
		}
		factoryWithTypeCheckers = function (isValidElement, throwOnDirectAccess) {
		  /* global Symbol */
		  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
		  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

		  /**
		   * Returns the iterator method function contained on the iterable object.
		   *
		   * Be sure to invoke the function with the iterable as context:
		   *
		   *     var iteratorFn = getIteratorFn(myIterable);
		   *     if (iteratorFn) {
		   *       var iterator = iteratorFn.call(myIterable);
		   *       ...
		   *     }
		   *
		   * @param {?object} maybeIterable
		   * @return {?function}
		   */
		  function getIteratorFn(maybeIterable) {
		    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
		    if (typeof iteratorFn === 'function') {
		      return iteratorFn;
		    }
		  }

		  /**
		   * Collection of methods that allow declaration and validation of props that are
		   * supplied to React components. Example usage:
		   *
		   *   var Props = require('ReactPropTypes');
		   *   var MyArticle = React.createClass({
		   *     propTypes: {
		   *       // An optional string prop named "description".
		   *       description: Props.string,
		   *
		   *       // A required enum prop named "category".
		   *       category: Props.oneOf(['News','Photos']).isRequired,
		   *
		   *       // A prop named "dialog" that requires an instance of Dialog.
		   *       dialog: Props.instanceOf(Dialog).isRequired
		   *     },
		   *     render: function() { ... }
		   *   });
		   *
		   * A more formal specification of how these methods are used:
		   *
		   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
		   *   decl := ReactPropTypes.{type}(.isRequired)?
		   *
		   * Each and every declaration produces a function with the same signature. This
		   * allows the creation of custom validation functions. For example:
		   *
		   *  var MyLink = React.createClass({
		   *    propTypes: {
		   *      // An optional string or URI prop named "href".
		   *      href: function(props, propName, componentName) {
		   *        var propValue = props[propName];
		   *        if (propValue != null && typeof propValue !== 'string' &&
		   *            !(propValue instanceof URI)) {
		   *          return new Error(
		   *            'Expected a string or an URI for ' + propName + ' in ' +
		   *            componentName
		   *          );
		   *        }
		   *      }
		   *    },
		   *    render: function() {...}
		   *  });
		   *
		   * @internal
		   */

		  var ANONYMOUS = '<<anonymous>>';

		  // Important!
		  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
		  var ReactPropTypes = {
		    array: createPrimitiveTypeChecker('array'),
		    bigint: createPrimitiveTypeChecker('bigint'),
		    bool: createPrimitiveTypeChecker('boolean'),
		    func: createPrimitiveTypeChecker('function'),
		    number: createPrimitiveTypeChecker('number'),
		    object: createPrimitiveTypeChecker('object'),
		    string: createPrimitiveTypeChecker('string'),
		    symbol: createPrimitiveTypeChecker('symbol'),
		    any: createAnyTypeChecker(),
		    arrayOf: createArrayOfTypeChecker,
		    element: createElementTypeChecker(),
		    elementType: createElementTypeTypeChecker(),
		    instanceOf: createInstanceTypeChecker,
		    node: createNodeChecker(),
		    objectOf: createObjectOfTypeChecker,
		    oneOf: createEnumTypeChecker,
		    oneOfType: createUnionTypeChecker,
		    shape: createShapeTypeChecker,
		    exact: createStrictShapeTypeChecker
		  };

		  /**
		   * inlined Object.is polyfill to avoid requiring consumers ship their own
		   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
		   */
		  /*eslint-disable no-self-compare*/
		  function is(x, y) {
		    // SameValue algorithm
		    if (x === y) {
		      // Steps 1-5, 7-10
		      // Steps 6.b-6.e: +0 != -0
		      return x !== 0 || 1 / x === 1 / y;
		    } else {
		      // Step 6.a: NaN == NaN
		      return x !== x && y !== y;
		    }
		  }
		  /*eslint-enable no-self-compare*/

		  /**
		   * We use an Error-like object for backward compatibility as people may call
		   * PropTypes directly and inspect their output. However, we don't use real
		   * Errors anymore. We don't inspect their stack anyway, and creating them
		   * is prohibitively expensive if they are created too often, such as what
		   * happens in oneOfType() for any type before the one that matched.
		   */
		  function PropTypeError(message, data) {
		    this.message = message;
		    this.data = data && typeof data === 'object' ? data : {};
		    this.stack = '';
		  }
		  // Make `instanceof Error` still work for returned errors.
		  PropTypeError.prototype = Error.prototype;
		  function createChainableTypeChecker(validate) {
		    if (process.env.NODE_ENV !== 'production') {
		      var manualPropTypeCallCache = {};
		      var manualPropTypeWarningCount = 0;
		    }
		    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
		      componentName = componentName || ANONYMOUS;
		      propFullName = propFullName || propName;
		      if (secret !== ReactPropTypesSecret) {
		        if (throwOnDirectAccess) {
		          // New behavior only for users of `prop-types` package
		          var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
		          err.name = 'Invariant Violation';
		          throw err;
		        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
		          // Old behavior for people using React.PropTypes
		          var cacheKey = componentName + ':' + propName;
		          if (!manualPropTypeCallCache[cacheKey] &&
		          // Avoid spamming the console because they are often not actionable except for lib authors
		          manualPropTypeWarningCount < 3) {
		            printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
		            manualPropTypeCallCache[cacheKey] = true;
		            manualPropTypeWarningCount++;
		          }
		        }
		      }
		      if (props[propName] == null) {
		        if (isRequired) {
		          if (props[propName] === null) {
		            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
		          }
		          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
		        }
		        return null;
		      } else {
		        return validate(props, propName, componentName, location, propFullName);
		      }
		    }
		    var chainedCheckType = checkType.bind(null, false);
		    chainedCheckType.isRequired = checkType.bind(null, true);
		    return chainedCheckType;
		  }
		  function createPrimitiveTypeChecker(expectedType) {
		    function validate(props, propName, componentName, location, propFullName, secret) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== expectedType) {
		        // `propValue` being instance of, say, date/regexp, pass the 'object'
		        // check, but we can offer a more precise error message here rather than
		        // 'of type `object`'.
		        var preciseType = getPreciseType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
		          expectedType: expectedType
		        });
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createAnyTypeChecker() {
		    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
		  }
		  function createArrayOfTypeChecker(typeChecker) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (typeof typeChecker !== 'function') {
		        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
		      }
		      var propValue = props[propName];
		      if (!Array.isArray(propValue)) {
		        var propType = getPropType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
		      }
		      for (var i = 0; i < propValue.length; i++) {
		        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
		        if (error instanceof Error) {
		          return error;
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createElementTypeChecker() {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      if (!isValidElement(propValue)) {
		        var propType = getPropType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createElementTypeTypeChecker() {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      if (!ReactIs.isValidElementType(propValue)) {
		        var propType = getPropType(propValue);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createInstanceTypeChecker(expectedClass) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (!(props[propName] instanceof expectedClass)) {
		        var expectedClassName = expectedClass.name || ANONYMOUS;
		        var actualClassName = getClassName(props[propName]);
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createEnumTypeChecker(expectedValues) {
		    if (!Array.isArray(expectedValues)) {
		      if (process.env.NODE_ENV !== 'production') {
		        if (arguments.length > 1) {
		          printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
		        } else {
		          printWarning('Invalid argument supplied to oneOf, expected an array.');
		        }
		      }
		      return emptyFunctionThatReturnsNull;
		    }
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      for (var i = 0; i < expectedValues.length; i++) {
		        if (is(propValue, expectedValues[i])) {
		          return null;
		        }
		      }
		      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
		        var type = getPreciseType(value);
		        if (type === 'symbol') {
		          return String(value);
		        }
		        return value;
		      });
		      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createObjectOfTypeChecker(typeChecker) {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (typeof typeChecker !== 'function') {
		        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
		      }
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
		      }
		      for (var key in propValue) {
		        if (has(propValue, key)) {
		          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		          if (error instanceof Error) {
		            return error;
		          }
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createUnionTypeChecker(arrayOfTypeCheckers) {
		    if (!Array.isArray(arrayOfTypeCheckers)) {
		      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
		      return emptyFunctionThatReturnsNull;
		    }
		    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		      var checker = arrayOfTypeCheckers[i];
		      if (typeof checker !== 'function') {
		        printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
		        return emptyFunctionThatReturnsNull;
		      }
		    }
		    function validate(props, propName, componentName, location, propFullName) {
		      var expectedTypes = [];
		      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
		        var checker = arrayOfTypeCheckers[i];
		        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
		        if (checkerResult == null) {
		          return null;
		        }
		        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
		          expectedTypes.push(checkerResult.data.expectedType);
		        }
		      }
		      var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
		      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createNodeChecker() {
		    function validate(props, propName, componentName, location, propFullName) {
		      if (!isNode(props[propName])) {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function invalidValidatorError(componentName, location, propFullName, key, type) {
		    return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
		  }
		  function createShapeTypeChecker(shapeTypes) {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
		      }
		      for (var key in shapeTypes) {
		        var checker = shapeTypes[key];
		        if (typeof checker !== 'function') {
		          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
		        }
		        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		        if (error) {
		          return error;
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function createStrictShapeTypeChecker(shapeTypes) {
		    function validate(props, propName, componentName, location, propFullName) {
		      var propValue = props[propName];
		      var propType = getPropType(propValue);
		      if (propType !== 'object') {
		        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
		      }
		      // We need to check all keys in case some are required but missing from props.
		      var allKeys = assign({}, props[propName], shapeTypes);
		      for (var key in allKeys) {
		        var checker = shapeTypes[key];
		        if (has(shapeTypes, key) && typeof checker !== 'function') {
		          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
		        }
		        if (!checker) {
		          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
		        }
		        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
		        if (error) {
		          return error;
		        }
		      }
		      return null;
		    }
		    return createChainableTypeChecker(validate);
		  }
		  function isNode(propValue) {
		    switch (typeof propValue) {
		      case 'number':
		      case 'string':
		      case 'undefined':
		        return true;
		      case 'boolean':
		        return !propValue;
		      case 'object':
		        if (Array.isArray(propValue)) {
		          return propValue.every(isNode);
		        }
		        if (propValue === null || isValidElement(propValue)) {
		          return true;
		        }
		        var iteratorFn = getIteratorFn(propValue);
		        if (iteratorFn) {
		          var iterator = iteratorFn.call(propValue);
		          var step;
		          if (iteratorFn !== propValue.entries) {
		            while (!(step = iterator.next()).done) {
		              if (!isNode(step.value)) {
		                return false;
		              }
		            }
		          } else {
		            // Iterator will provide entry [k,v] tuples rather than values.
		            while (!(step = iterator.next()).done) {
		              var entry = step.value;
		              if (entry) {
		                if (!isNode(entry[1])) {
		                  return false;
		                }
		              }
		            }
		          }
		        } else {
		          return false;
		        }
		        return true;
		      default:
		        return false;
		    }
		  }
		  function isSymbol(propType, propValue) {
		    // Native Symbol.
		    if (propType === 'symbol') {
		      return true;
		    }

		    // falsy value can't be a Symbol
		    if (!propValue) {
		      return false;
		    }

		    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
		    if (propValue['@@toStringTag'] === 'Symbol') {
		      return true;
		    }

		    // Fallback for non-spec compliant Symbols which are polyfilled.
		    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
		      return true;
		    }
		    return false;
		  }

		  // Equivalent of `typeof` but with special handling for array and regexp.
		  function getPropType(propValue) {
		    var propType = typeof propValue;
		    if (Array.isArray(propValue)) {
		      return 'array';
		    }
		    if (propValue instanceof RegExp) {
		      // Old webkits (at least until Android 4.0) return 'function' rather than
		      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
		      // passes PropTypes.object.
		      return 'object';
		    }
		    if (isSymbol(propType, propValue)) {
		      return 'symbol';
		    }
		    return propType;
		  }

		  // This handles more types than `getPropType`. Only used for error messages.
		  // See `createPrimitiveTypeChecker`.
		  function getPreciseType(propValue) {
		    if (typeof propValue === 'undefined' || propValue === null) {
		      return '' + propValue;
		    }
		    var propType = getPropType(propValue);
		    if (propType === 'object') {
		      if (propValue instanceof Date) {
		        return 'date';
		      } else if (propValue instanceof RegExp) {
		        return 'regexp';
		      }
		    }
		    return propType;
		  }

		  // Returns a string that is postfixed to a warning about an invalid type.
		  // For example, "undefined" or "of type array"
		  function getPostfixForTypeWarning(value) {
		    var type = getPreciseType(value);
		    switch (type) {
		      case 'array':
		      case 'object':
		        return 'an ' + type;
		      case 'boolean':
		      case 'date':
		      case 'regexp':
		        return 'a ' + type;
		      default:
		        return type;
		    }
		  }

		  // Returns class name of the object, if any.
		  function getClassName(propValue) {
		    if (!propValue.constructor || !propValue.constructor.name) {
		      return ANONYMOUS;
		    }
		    return propValue.constructor.name;
		  }
		  ReactPropTypes.checkPropTypes = checkPropTypes;
		  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
		  ReactPropTypes.PropTypes = ReactPropTypes;
		  return ReactPropTypes;
		};
		return factoryWithTypeCheckers;
	}

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var factoryWithThrowingShims;
	var hasRequiredFactoryWithThrowingShims;

	function requireFactoryWithThrowingShims () {
		if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
		hasRequiredFactoryWithThrowingShims = 1;

		var ReactPropTypesSecret = /*@__PURE__*/ requireReactPropTypesSecret();
		function emptyFunction() {}
		function emptyFunctionWithReset() {}
		emptyFunctionWithReset.resetWarningCache = emptyFunction;
		factoryWithThrowingShims = function () {
		  function shim(props, propName, componentName, location, propFullName, secret) {
		    if (secret === ReactPropTypesSecret) {
		      // It is still safe when called from React.
		      return;
		    }
		    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
		    err.name = 'Invariant Violation';
		    throw err;
		  }
		  shim.isRequired = shim;
		  function getShim() {
		    return shim;
		  }
		  // Important!
		  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
		  var ReactPropTypes = {
		    array: shim,
		    bigint: shim,
		    bool: shim,
		    func: shim,
		    number: shim,
		    object: shim,
		    string: shim,
		    symbol: shim,
		    any: shim,
		    arrayOf: getShim,
		    element: shim,
		    elementType: shim,
		    instanceOf: getShim,
		    node: shim,
		    objectOf: getShim,
		    oneOf: getShim,
		    oneOfType: getShim,
		    shape: getShim,
		    exact: getShim,
		    checkPropTypes: emptyFunctionWithReset,
		    resetWarningCache: emptyFunction
		  };
		  ReactPropTypes.PropTypes = ReactPropTypes;
		  return ReactPropTypes;
		};
		return factoryWithThrowingShims;
	}

	var hasRequiredPropTypes;

	function requirePropTypes () {
		if (hasRequiredPropTypes) return propTypes.exports;
		hasRequiredPropTypes = 1;
		if (process.env.NODE_ENV !== 'production') {
		  var ReactIs = requireReactIs();

		  // By explicitly using `prop-types` you are opting into new development behavior.
		  // http://fb.me/prop-types-in-prod
		  var throwOnDirectAccess = true;
		  propTypes.exports = /*@__PURE__*/ requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
		} else {
		  // By explicitly using `prop-types` you are opting into new production behavior.
		  // http://fb.me/prop-types-in-prod
		  propTypes.exports = /*@__PURE__*/ requireFactoryWithThrowingShims()();
		}
		return propTypes.exports;
	}

	var propTypesExports = /*@__PURE__*/ requirePropTypes();
	var PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);

	function IndividualConnection(_ref) {
	  let {
	    active,
	    title,
	    id,
	    number,
	    descriptions,
	    rewards,
	    size,
	    isChecked,
	    onCheckboxChange
	  } = _ref;
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "bg-white rounded-lg p-4 shadow border border-gray-200"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "flex items-center justify-between"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "flex items-center space-x-4"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "group"
	  }, /*#__PURE__*/React$1.createElement("div", null, /*#__PURE__*/React$1.createElement("input", {
	    disabled: !active,
	    type: "checkbox",
	    checked: isChecked,
	    onChange: e => onCheckboxChange(e.target.checked)
	  })))), /*#__PURE__*/React$1.createElement("div", {
	    className: "flex items-center"
	  }), descriptions && title !== "Avatar" && /*#__PURE__*/React$1.createElement("p", {
	    className: "text-sm font-medium text-gray-900 dark:text-gray-300"
	  }, "Intent: ", descriptions), rewards && /*#__PURE__*/React$1.createElement("p", {
	    className: "text-sm font-medium text-gray-900 dark:text-gray-300"
	  }, "Rewards: ", rewards)));
	}
	IndividualConnection.propTypes = {
	  active: PropTypes.bool.isRequired,
	  title: PropTypes.string.isRequired,
	  id: PropTypes.any.isRequired,
	  number: PropTypes.number.isRequired,
	  descriptions: PropTypes.string,
	  rewards: PropTypes.string,
	  size: PropTypes.string.isRequired,
	  isChecked: PropTypes.bool.isRequired,
	  onCheckboxChange: PropTypes.func.isRequired
	};

	const warned = new Set();
	function warnOnce(condition, message, element) {
	    if (condition || warned.has(message))
	        return;
	    console.warn(message);
	    if (element)
	        console.warn(element);
	    warned.add(message);
	}

	function createDOMMotionComponentProxy(componentFactory) {
	    if (typeof Proxy === "undefined") {
	        return componentFactory;
	    }
	    /**
	     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.
	     * Rather than generating them anew every render.
	     */
	    const componentCache = new Map();
	    const deprecatedFactoryFunction = (...args) => {
	        if (process.env.NODE_ENV !== "production") {
	            warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
	        }
	        return componentFactory(...args);
	    };
	    return new Proxy(deprecatedFactoryFunction, {
	        /**
	         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
	         * The prop name is passed through as `key` and we can use that to generate a `motion`
	         * DOM component with that name.
	         */
	        get: (_target, key) => {
	            if (key === "create")
	                return componentFactory;
	            /**
	             * If this element doesn't exist in the component cache, create it and cache.
	             */
	            if (!componentCache.has(key)) {
	                componentCache.set(key, componentFactory(key));
	            }
	            return componentCache.get(key);
	        },
	    });
	}

	function isAnimationControls(v) {
	    return (v !== null &&
	        typeof v === "object" &&
	        typeof v.start === "function");
	}

	const isKeyframesTarget = (v) => {
	    return Array.isArray(v);
	};

	function shallowCompare(next, prev) {
	    if (!Array.isArray(prev))
	        return false;
	    const prevLength = prev.length;
	    if (prevLength !== next.length)
	        return false;
	    for (let i = 0; i < prevLength; i++) {
	        if (prev[i] !== next[i])
	            return false;
	    }
	    return true;
	}

	/**
	 * Decides if the supplied variable is variant label
	 */
	function isVariantLabel(v) {
	    return typeof v === "string" || Array.isArray(v);
	}

	function getValueState(visualElement) {
	    const state = [{}, {}];
	    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
	        state[0][key] = value.get();
	        state[1][key] = value.getVelocity();
	    });
	    return state;
	}
	function resolveVariantFromProps(props, definition, custom, visualElement) {
	    /**
	     * If the variant definition is a function, resolve.
	     */
	    if (typeof definition === "function") {
	        const [current, velocity] = getValueState(visualElement);
	        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
	    }
	    /**
	     * If the variant definition is a variant label, or
	     * the function returned a variant label, resolve.
	     */
	    if (typeof definition === "string") {
	        definition = props.variants && props.variants[definition];
	    }
	    /**
	     * At this point we've resolved both functions and variant labels,
	     * but the resolved variant label might itself have been a function.
	     * If so, resolve. This can only have returned a valid target object.
	     */
	    if (typeof definition === "function") {
	        const [current, velocity] = getValueState(visualElement);
	        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
	    }
	    return definition;
	}

	function resolveVariant(visualElement, definition, custom) {
	    const props = visualElement.getProps();
	    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);
	}

	const variantPriorityOrder = [
	    "animate",
	    "whileInView",
	    "whileFocus",
	    "whileHover",
	    "whileTap",
	    "whileDrag",
	    "exit",
	];
	const variantProps = ["initial", ...variantPriorityOrder];

	/**
	 * Generate a list of every possible transform key.
	 */
	const transformPropOrder = [
	    "transformPerspective",
	    "x",
	    "y",
	    "z",
	    "translateX",
	    "translateY",
	    "translateZ",
	    "scale",
	    "scaleX",
	    "scaleY",
	    "rotate",
	    "rotateX",
	    "rotateY",
	    "rotateZ",
	    "skew",
	    "skewX",
	    "skewY",
	];
	/**
	 * A quick lookup for transform props.
	 */
	const transformProps = new Set(transformPropOrder);

	/**
	 * Converts seconds to milliseconds
	 *
	 * @param seconds - Time in seconds.
	 * @return milliseconds - Converted time in milliseconds.
	 */
	const secondsToMilliseconds = (seconds) => seconds * 1000;
	const millisecondsToSeconds = (milliseconds) => milliseconds / 1000;

	const underDampedSpring = {
	    type: "spring",
	    stiffness: 500,
	    damping: 25,
	    restSpeed: 10,
	};
	const criticallyDampedSpring = (target) => ({
	    type: "spring",
	    stiffness: 550,
	    damping: target === 0 ? 2 * Math.sqrt(550) : 30,
	    restSpeed: 10,
	});
	const keyframesTransition = {
	    type: "keyframes",
	    duration: 0.8,
	};
	/**
	 * Default easing curve is a slightly shallower version of
	 * the default browser easing curve.
	 */
	const ease = {
	    type: "keyframes",
	    ease: [0.25, 0.1, 0.35, 1],
	    duration: 0.3,
	};
	const getDefaultTransition = (valueKey, { keyframes }) => {
	    if (keyframes.length > 2) {
	        return keyframesTransition;
	    }
	    else if (transformProps.has(valueKey)) {
	        return valueKey.startsWith("scale")
	            ? criticallyDampedSpring(keyframes[1])
	            : underDampedSpring;
	    }
	    return ease;
	};

	function getValueTransition(transition, key) {
	    return transition
	        ? transition[key] ||
	            transition["default"] ||
	            transition
	        : undefined;
	}

	const MotionGlobalConfig = {
	    skipAnimations: false,
	    useManualTiming: false,
	};

	const instantAnimationState = {
	    current: false,
	};

	const isNotNull = (value) => value !== null;
	function getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {
	    const resolvedKeyframes = keyframes.filter(isNotNull);
	    const index = repeat && repeatType !== "loop" && repeat % 2 === 1
	        ? 0
	        : resolvedKeyframes.length - 1;
	    return !index || finalKeyframe === undefined
	        ? resolvedKeyframes[index]
	        : finalKeyframe;
	}

	const noop = (any) => any;

	let warning = noop;
	let invariant = noop;
	if (process.env.NODE_ENV !== "production") {
	    warning = (check, message) => {
	        if (!check && typeof console !== "undefined") {
	            console.warn(message);
	        }
	    };
	    invariant = (check, message) => {
	        if (!check) {
	            throw new Error(message);
	        }
	    };
	}

	function createRenderStep(runNextFrame) {
	    /**
	     * We create and reuse two queues, one to queue jobs for the current frame
	     * and one for the next. We reuse to avoid triggering GC after x frames.
	     */
	    let thisFrame = new Set();
	    let nextFrame = new Set();
	    /**
	     * Track whether we're currently processing jobs in this step. This way
	     * we can decide whether to schedule new jobs for this frame or next.
	     */
	    let isProcessing = false;
	    let flushNextFrame = false;
	    /**
	     * A set of processes which were marked keepAlive when scheduled.
	     */
	    const toKeepAlive = new WeakSet();
	    let latestFrameData = {
	        delta: 0.0,
	        timestamp: 0.0,
	        isProcessing: false,
	    };
	    function triggerCallback(callback) {
	        if (toKeepAlive.has(callback)) {
	            step.schedule(callback);
	            runNextFrame();
	        }
	        callback(latestFrameData);
	    }
	    const step = {
	        /**
	         * Schedule a process to run on the next frame.
	         */
	        schedule: (callback, keepAlive = false, immediate = false) => {
	            const addToCurrentFrame = immediate && isProcessing;
	            const queue = addToCurrentFrame ? thisFrame : nextFrame;
	            if (keepAlive)
	                toKeepAlive.add(callback);
	            if (!queue.has(callback))
	                queue.add(callback);
	            return callback;
	        },
	        /**
	         * Cancel the provided callback from running on the next frame.
	         */
	        cancel: (callback) => {
	            nextFrame.delete(callback);
	            toKeepAlive.delete(callback);
	        },
	        /**
	         * Execute all schedule callbacks.
	         */
	        process: (frameData) => {
	            latestFrameData = frameData;
	            /**
	             * If we're already processing we've probably been triggered by a flushSync
	             * inside an existing process. Instead of executing, mark flushNextFrame
	             * as true and ensure we flush the following frame at the end of this one.
	             */
	            if (isProcessing) {
	                flushNextFrame = true;
	                return;
	            }
	            isProcessing = true;
	            [thisFrame, nextFrame] = [nextFrame, thisFrame];
	            // Execute this frame
	            thisFrame.forEach(triggerCallback);
	            // Clear the frame so no callbacks remain. This is to avoid
	            // memory leaks should this render step not run for a while.
	            thisFrame.clear();
	            isProcessing = false;
	            if (flushNextFrame) {
	                flushNextFrame = false;
	                step.process(frameData);
	            }
	        },
	    };
	    return step;
	}

	const stepsOrder = [
	    "read", // Read
	    "resolveKeyframes", // Write/Read/Write/Read
	    "update", // Compute
	    "preRender", // Compute
	    "render", // Write
	    "postRender", // Compute
	];
	const maxElapsed = 40;
	function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
	    let runNextFrame = false;
	    let useDefaultElapsed = true;
	    const state = {
	        delta: 0.0,
	        timestamp: 0.0,
	        isProcessing: false,
	    };
	    const flagRunNextFrame = () => (runNextFrame = true);
	    const steps = stepsOrder.reduce((acc, key) => {
	        acc[key] = createRenderStep(flagRunNextFrame);
	        return acc;
	    }, {});
	    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;
	    const processBatch = () => {
	        const timestamp = performance.now();
	        runNextFrame = false;
	        state.delta = useDefaultElapsed
	            ? 1000 / 60
	            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
	        state.timestamp = timestamp;
	        state.isProcessing = true;
	        // Unrolled render loop for better per-frame performance
	        read.process(state);
	        resolveKeyframes.process(state);
	        update.process(state);
	        preRender.process(state);
	        render.process(state);
	        postRender.process(state);
	        state.isProcessing = false;
	        if (runNextFrame && allowKeepAlive) {
	            useDefaultElapsed = false;
	            scheduleNextBatch(processBatch);
	        }
	    };
	    const wake = () => {
	        runNextFrame = true;
	        useDefaultElapsed = true;
	        if (!state.isProcessing) {
	            scheduleNextBatch(processBatch);
	        }
	    };
	    const schedule = stepsOrder.reduce((acc, key) => {
	        const step = steps[key];
	        acc[key] = (process, keepAlive = false, immediate = false) => {
	            if (!runNextFrame)
	                wake();
	            return step.schedule(process, keepAlive, immediate);
	        };
	        return acc;
	    }, {});
	    const cancel = (process) => {
	        for (let i = 0; i < stepsOrder.length; i++) {
	            steps[stepsOrder[i]].cancel(process);
	        }
	    };
	    return { schedule, cancel, state, steps };
	}

	const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

	/*
	  Bezier function generator
	  This has been modified from Gaëtan Renaudeau's BezierEasing
	  https://github.com/gre/bezier-easing/blob/master/src/index.js
	  https://github.com/gre/bezier-easing/blob/master/LICENSE
	  
	  I've removed the newtonRaphsonIterate algo because in benchmarking it
	  wasn't noticiably faster than binarySubdivision, indeed removing it
	  usually improved times, depending on the curve.
	  I also removed the lookup table, as for the added bundle size and loop we're
	  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
	  to 12 to compensate and this still tended to be faster for no perceivable
	  loss in accuracy.
	  Usage
	    const easeOut = cubicBezier(.17,.67,.83,.67);
	    const x = easeOut(0.5); // returns 0.627...
	*/
	// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
	const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *
	    t;
	const subdivisionPrecision = 0.0000001;
	const subdivisionMaxIterations = 12;
	function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
	    let currentX;
	    let currentT;
	    let i = 0;
	    do {
	        currentT = lowerBound + (upperBound - lowerBound) / 2.0;
	        currentX = calcBezier(currentT, mX1, mX2) - x;
	        if (currentX > 0.0) {
	            upperBound = currentT;
	        }
	        else {
	            lowerBound = currentT;
	        }
	    } while (Math.abs(currentX) > subdivisionPrecision &&
	        ++i < subdivisionMaxIterations);
	    return currentT;
	}
	function cubicBezier(mX1, mY1, mX2, mY2) {
	    // If this is a linear gradient, return linear easing
	    if (mX1 === mY1 && mX2 === mY2)
	        return noop;
	    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
	    // If animation is at start/end, return t without easing
	    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
	}

	// Accepts an easing function and returns a new one that outputs mirrored values for
	// the second half of the animation. Turns easeIn into easeInOut.
	const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

	// Accepts an easing function and returns a new one that outputs reversed values.
	// Turns easeIn into easeOut.
	const reverseEasing = (easing) => (p) => 1 - easing(1 - p);

	const backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);
	const backIn = /*@__PURE__*/ reverseEasing(backOut);
	const backInOut = /*@__PURE__*/ mirrorEasing(backIn);

	const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

	const circIn = (p) => 1 - Math.sin(Math.acos(p));
	const circOut = reverseEasing(circIn);
	const circInOut = mirrorEasing(circIn);

	/**
	 * Check if the value is a zero value string like "0px" or "0%"
	 */
	const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

	function isNone(value) {
	    if (typeof value === "number") {
	        return value === 0;
	    }
	    else if (value !== null) {
	        return value === "none" || value === "0" || isZeroValueString(value);
	    }
	    else {
	        return true;
	    }
	}

	/**
	 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
	 */
	const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

	const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
	const isCSSVariableName = 
	/*@__PURE__*/ checkStringStartsWith("--");
	const startsAsVariableToken = 
	/*@__PURE__*/ checkStringStartsWith("var(--");
	const isCSSVariableToken = (value) => {
	    const startsWithToken = startsAsVariableToken(value);
	    if (!startsWithToken)
	        return false;
	    // Ensure any comments are stripped from the value as this can harm performance of the regex.
	    return singleCssVariableRegex.test(value.split("/*")[0].trim());
	};
	const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

	/**
	 * Parse Framer's special CSS variable format into a CSS token and a fallback.
	 *
	 * ```
	 * `var(--foo, #fff)` => [`--foo`, '#fff']
	 * ```
	 *
	 * @param current
	 */
	const splitCSSVariableRegex = 
	// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
	/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
	function parseCSSVariable(current) {
	    const match = splitCSSVariableRegex.exec(current);
	    if (!match)
	        return [,];
	    const [, token1, token2, fallback] = match;
	    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
	}
	const maxDepth = 4;
	function getVariableValue(current, element, depth = 1) {
	    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
	    const [token, fallback] = parseCSSVariable(current);
	    // No CSS variable detected
	    if (!token)
	        return;
	    // Attempt to read this CSS variable off the element
	    const resolved = window.getComputedStyle(element).getPropertyValue(token);
	    if (resolved) {
	        const trimmed = resolved.trim();
	        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
	    }
	    return isCSSVariableToken(fallback)
	        ? getVariableValue(fallback, element, depth + 1)
	        : fallback;
	}

	const clamp = (min, max, v) => {
	    if (v > max)
	        return max;
	    if (v < min)
	        return min;
	    return v;
	};

	const number = {
	    test: (v) => typeof v === "number",
	    parse: parseFloat,
	    transform: (v) => v,
	};
	const alpha = {
	    ...number,
	    transform: (v) => clamp(0, 1, v),
	};
	const scale = {
	    ...number,
	    default: 1,
	};

	const createUnitType = (unit) => ({
	    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
	    parse: parseFloat,
	    transform: (v) => `${v}${unit}`,
	});
	const degrees = /*@__PURE__*/ createUnitType("deg");
	const percent = /*@__PURE__*/ createUnitType("%");
	const px = /*@__PURE__*/ createUnitType("px");
	const vh = /*@__PURE__*/ createUnitType("vh");
	const vw = /*@__PURE__*/ createUnitType("vw");
	const progressPercentage = {
	    ...percent,
	    parse: (v) => percent.parse(v) / 100,
	    transform: (v) => percent.transform(v * 100),
	};

	const positionalKeys = new Set([
	    "width",
	    "height",
	    "top",
	    "left",
	    "right",
	    "bottom",
	    "x",
	    "y",
	    "translateX",
	    "translateY",
	]);
	const isNumOrPxType = (v) => v === number || v === px;
	const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
	const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
	    if (transform === "none" || !transform)
	        return 0;
	    const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
	    if (matrix3d) {
	        return getPosFromMatrix(matrix3d[1], pos3);
	    }
	    else {
	        const matrix = transform.match(/^matrix\((.+)\)$/u);
	        if (matrix) {
	            return getPosFromMatrix(matrix[1], pos2);
	        }
	        else {
	            return 0;
	        }
	    }
	};
	const transformKeys = new Set(["x", "y", "z"]);
	const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
	function removeNonTranslationalTransform(visualElement) {
	    const removedTransforms = [];
	    nonTranslationalTransformKeys.forEach((key) => {
	        const value = visualElement.getValue(key);
	        if (value !== undefined) {
	            removedTransforms.push([key, value.get()]);
	            value.set(key.startsWith("scale") ? 1 : 0);
	        }
	    });
	    return removedTransforms;
	}
	const positionalValues = {
	    // Dimensions
	    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
	    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
	    top: (_bbox, { top }) => parseFloat(top),
	    left: (_bbox, { left }) => parseFloat(left),
	    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
	    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
	    // Transform
	    x: getTranslateFromMatrix(4, 13),
	    y: getTranslateFromMatrix(5, 14),
	};
	// Alias translate longform names
	positionalValues.translateX = positionalValues.x;
	positionalValues.translateY = positionalValues.y;

	/**
	 * Tests a provided value against a ValueType
	 */
	const testValueType = (v) => (type) => type.test(v);

	/**
	 * ValueType for "auto"
	 */
	const auto = {
	    test: (v) => v === "auto",
	    parse: (v) => v,
	};

	/**
	 * A list of value types commonly used for dimensions
	 */
	const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
	/**
	 * Tests a dimensional value against the list of dimension ValueTypes
	 */
	const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));

	const toResolve = new Set();
	let isScheduled = false;
	let anyNeedsMeasurement = false;
	function measureAllKeyframes() {
	    if (anyNeedsMeasurement) {
	        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
	        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
	        const transformsToRestore = new Map();
	        /**
	         * Write pass
	         * If we're measuring elements we want to remove bounding box-changing transforms.
	         */
	        elementsToMeasure.forEach((element) => {
	            const removedTransforms = removeNonTranslationalTransform(element);
	            if (!removedTransforms.length)
	                return;
	            transformsToRestore.set(element, removedTransforms);
	            element.render();
	        });
	        // Read
	        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
	        // Write
	        elementsToMeasure.forEach((element) => {
	            element.render();
	            const restore = transformsToRestore.get(element);
	            if (restore) {
	                restore.forEach(([key, value]) => {
	                    var _a;
	                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
	                });
	            }
	        });
	        // Read
	        resolversToMeasure.forEach((resolver) => resolver.measureEndState());
	        // Write
	        resolversToMeasure.forEach((resolver) => {
	            if (resolver.suspendedScrollY !== undefined) {
	                window.scrollTo(0, resolver.suspendedScrollY);
	            }
	        });
	    }
	    anyNeedsMeasurement = false;
	    isScheduled = false;
	    toResolve.forEach((resolver) => resolver.complete());
	    toResolve.clear();
	}
	function readAllKeyframes() {
	    toResolve.forEach((resolver) => {
	        resolver.readKeyframes();
	        if (resolver.needsMeasurement) {
	            anyNeedsMeasurement = true;
	        }
	    });
	}
	function flushKeyframeResolvers() {
	    readAllKeyframes();
	    measureAllKeyframes();
	}
	class KeyframeResolver {
	    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {
	        /**
	         * Track whether this resolver has completed. Once complete, it never
	         * needs to attempt keyframe resolution again.
	         */
	        this.isComplete = false;
	        /**
	         * Track whether this resolver is async. If it is, it'll be added to the
	         * resolver queue and flushed in the next frame. Resolvers that aren't going
	         * to trigger read/write thrashing don't need to be async.
	         */
	        this.isAsync = false;
	        /**
	         * Track whether this resolver needs to perform a measurement
	         * to resolve its keyframes.
	         */
	        this.needsMeasurement = false;
	        /**
	         * Track whether this resolver is currently scheduled to resolve
	         * to allow it to be cancelled and resumed externally.
	         */
	        this.isScheduled = false;
	        this.unresolvedKeyframes = [...unresolvedKeyframes];
	        this.onComplete = onComplete;
	        this.name = name;
	        this.motionValue = motionValue;
	        this.element = element;
	        this.isAsync = isAsync;
	    }
	    scheduleResolve() {
	        this.isScheduled = true;
	        if (this.isAsync) {
	            toResolve.add(this);
	            if (!isScheduled) {
	                isScheduled = true;
	                frame.read(readAllKeyframes);
	                frame.resolveKeyframes(measureAllKeyframes);
	            }
	        }
	        else {
	            this.readKeyframes();
	            this.complete();
	        }
	    }
	    readKeyframes() {
	        const { unresolvedKeyframes, name, element, motionValue } = this;
	        /**
	         * If a keyframe is null, we hydrate it either by reading it from
	         * the instance, or propagating from previous keyframes.
	         */
	        for (let i = 0; i < unresolvedKeyframes.length; i++) {
	            if (unresolvedKeyframes[i] === null) {
	                /**
	                 * If the first keyframe is null, we need to find its value by sampling the element
	                 */
	                if (i === 0) {
	                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();
	                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
	                    if (currentValue !== undefined) {
	                        unresolvedKeyframes[0] = currentValue;
	                    }
	                    else if (element && name) {
	                        const valueAsRead = element.readValue(name, finalKeyframe);
	                        if (valueAsRead !== undefined && valueAsRead !== null) {
	                            unresolvedKeyframes[0] = valueAsRead;
	                        }
	                    }
	                    if (unresolvedKeyframes[0] === undefined) {
	                        unresolvedKeyframes[0] = finalKeyframe;
	                    }
	                    if (motionValue && currentValue === undefined) {
	                        motionValue.set(unresolvedKeyframes[0]);
	                    }
	                }
	                else {
	                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
	                }
	            }
	        }
	    }
	    setFinalKeyframe() { }
	    measureInitialState() { }
	    renderEndStyles() { }
	    measureEndState() { }
	    complete() {
	        this.isComplete = true;
	        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
	        toResolve.delete(this);
	    }
	    cancel() {
	        if (!this.isComplete) {
	            this.isScheduled = false;
	            toResolve.delete(this);
	        }
	    }
	    resume() {
	        if (!this.isComplete)
	            this.scheduleResolve();
	    }
	}

	// If this number is a decimal, make it just five decimal places
	// to avoid exponents
	const sanitize = (v) => Math.round(v * 100000) / 100000;

	const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

	function isNullish(v) {
	    return v == null;
	}

	const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

	/**
	 * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,
	 * but false if a number or multiple colors
	 */
	const isColorString = (type, testProp) => (v) => {
	    return Boolean((typeof v === "string" &&
	        singleColorRegex.test(v) &&
	        v.startsWith(type)) ||
	        (testProp &&
	            !isNullish(v) &&
	            Object.prototype.hasOwnProperty.call(v, testProp)));
	};
	const splitColor = (aName, bName, cName) => (v) => {
	    if (typeof v !== "string")
	        return v;
	    const [a, b, c, alpha] = v.match(floatRegex);
	    return {
	        [aName]: parseFloat(a),
	        [bName]: parseFloat(b),
	        [cName]: parseFloat(c),
	        alpha: alpha !== undefined ? parseFloat(alpha) : 1,
	    };
	};

	const clampRgbUnit = (v) => clamp(0, 255, v);
	const rgbUnit = {
	    ...number,
	    transform: (v) => Math.round(clampRgbUnit(v)),
	};
	const rgba = {
	    test: /*@__PURE__*/ isColorString("rgb", "red"),
	    parse: /*@__PURE__*/ splitColor("red", "green", "blue"),
	    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" +
	        rgbUnit.transform(red) +
	        ", " +
	        rgbUnit.transform(green) +
	        ", " +
	        rgbUnit.transform(blue) +
	        ", " +
	        sanitize(alpha.transform(alpha$1)) +
	        ")",
	};

	function parseHex(v) {
	    let r = "";
	    let g = "";
	    let b = "";
	    let a = "";
	    // If we have 6 characters, ie #FF0000
	    if (v.length > 5) {
	        r = v.substring(1, 3);
	        g = v.substring(3, 5);
	        b = v.substring(5, 7);
	        a = v.substring(7, 9);
	        // Or we have 3 characters, ie #F00
	    }
	    else {
	        r = v.substring(1, 2);
	        g = v.substring(2, 3);
	        b = v.substring(3, 4);
	        a = v.substring(4, 5);
	        r += r;
	        g += g;
	        b += b;
	        a += a;
	    }
	    return {
	        red: parseInt(r, 16),
	        green: parseInt(g, 16),
	        blue: parseInt(b, 16),
	        alpha: a ? parseInt(a, 16) / 255 : 1,
	    };
	}
	const hex = {
	    test: /*@__PURE__*/ isColorString("#"),
	    parse: parseHex,
	    transform: rgba.transform,
	};

	const hsla = {
	    test: /*@__PURE__*/ isColorString("hsl", "hue"),
	    parse: /*@__PURE__*/ splitColor("hue", "saturation", "lightness"),
	    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
	        return ("hsla(" +
	            Math.round(hue) +
	            ", " +
	            percent.transform(sanitize(saturation)) +
	            ", " +
	            percent.transform(sanitize(lightness)) +
	            ", " +
	            sanitize(alpha.transform(alpha$1)) +
	            ")");
	    },
	};

	const color = {
	    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
	    parse: (v) => {
	        if (rgba.test(v)) {
	            return rgba.parse(v);
	        }
	        else if (hsla.test(v)) {
	            return hsla.parse(v);
	        }
	        else {
	            return hex.parse(v);
	        }
	    },
	    transform: (v) => {
	        return typeof v === "string"
	            ? v
	            : v.hasOwnProperty("red")
	                ? rgba.transform(v)
	                : hsla.transform(v);
	    },
	};

	const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

	function test(v) {
	    var _a, _b;
	    return (isNaN(v) &&
	        typeof v === "string" &&
	        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +
	            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >
	            0);
	}
	const NUMBER_TOKEN = "number";
	const COLOR_TOKEN = "color";
	const VAR_TOKEN = "var";
	const VAR_FUNCTION_TOKEN = "var(";
	const SPLIT_TOKEN = "${}";
	// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
	const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
	function analyseComplexValue(value) {
	    const originalValue = value.toString();
	    const values = [];
	    const indexes = {
	        color: [],
	        number: [],
	        var: [],
	    };
	    const types = [];
	    let i = 0;
	    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
	        if (color.test(parsedValue)) {
	            indexes.color.push(i);
	            types.push(COLOR_TOKEN);
	            values.push(color.parse(parsedValue));
	        }
	        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
	            indexes.var.push(i);
	            types.push(VAR_TOKEN);
	            values.push(parsedValue);
	        }
	        else {
	            indexes.number.push(i);
	            types.push(NUMBER_TOKEN);
	            values.push(parseFloat(parsedValue));
	        }
	        ++i;
	        return SPLIT_TOKEN;
	    });
	    const split = tokenised.split(SPLIT_TOKEN);
	    return { values, split, indexes, types };
	}
	function parseComplexValue(v) {
	    return analyseComplexValue(v).values;
	}
	function createTransformer(source) {
	    const { split, types } = analyseComplexValue(source);
	    const numSections = split.length;
	    return (v) => {
	        let output = "";
	        for (let i = 0; i < numSections; i++) {
	            output += split[i];
	            if (v[i] !== undefined) {
	                const type = types[i];
	                if (type === NUMBER_TOKEN) {
	                    output += sanitize(v[i]);
	                }
	                else if (type === COLOR_TOKEN) {
	                    output += color.transform(v[i]);
	                }
	                else {
	                    output += v[i];
	                }
	            }
	        }
	        return output;
	    };
	}
	const convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
	function getAnimatableNone$1(v) {
	    const parsed = parseComplexValue(v);
	    const transformer = createTransformer(v);
	    return transformer(parsed.map(convertNumbersToZero));
	}
	const complex = {
	    test,
	    parse: parseComplexValue,
	    createTransformer,
	    getAnimatableNone: getAnimatableNone$1,
	};

	/**
	 * Properties that should default to 1 or 100%
	 */
	const maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
	function applyDefaultFilter(v) {
	    const [name, value] = v.slice(0, -1).split("(");
	    if (name === "drop-shadow")
	        return v;
	    const [number] = value.match(floatRegex) || [];
	    if (!number)
	        return v;
	    const unit = value.replace(number, "");
	    let defaultValue = maxDefaults.has(name) ? 1 : 0;
	    if (number !== value)
	        defaultValue *= 100;
	    return name + "(" + defaultValue + unit + ")";
	}
	const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
	const filter = {
	    ...complex,
	    getAnimatableNone: (v) => {
	        const functions = v.match(functionRegex);
	        return functions ? functions.map(applyDefaultFilter).join(" ") : v;
	    },
	};

	const browserNumberValueTypes = {
	    // Border props
	    borderWidth: px,
	    borderTopWidth: px,
	    borderRightWidth: px,
	    borderBottomWidth: px,
	    borderLeftWidth: px,
	    borderRadius: px,
	    radius: px,
	    borderTopLeftRadius: px,
	    borderTopRightRadius: px,
	    borderBottomRightRadius: px,
	    borderBottomLeftRadius: px,
	    // Positioning props
	    width: px,
	    maxWidth: px,
	    height: px,
	    maxHeight: px,
	    top: px,
	    right: px,
	    bottom: px,
	    left: px,
	    // Spacing props
	    padding: px,
	    paddingTop: px,
	    paddingRight: px,
	    paddingBottom: px,
	    paddingLeft: px,
	    margin: px,
	    marginTop: px,
	    marginRight: px,
	    marginBottom: px,
	    marginLeft: px,
	    // Misc
	    backgroundPositionX: px,
	    backgroundPositionY: px,
	};

	const transformValueTypes = {
	    rotate: degrees,
	    rotateX: degrees,
	    rotateY: degrees,
	    rotateZ: degrees,
	    scale,
	    scaleX: scale,
	    scaleY: scale,
	    scaleZ: scale,
	    skew: degrees,
	    skewX: degrees,
	    skewY: degrees,
	    distance: px,
	    translateX: px,
	    translateY: px,
	    translateZ: px,
	    x: px,
	    y: px,
	    z: px,
	    perspective: px,
	    transformPerspective: px,
	    opacity: alpha,
	    originX: progressPercentage,
	    originY: progressPercentage,
	    originZ: px,
	};

	const int = {
	    ...number,
	    transform: Math.round,
	};

	const numberValueTypes = {
	    ...browserNumberValueTypes,
	    ...transformValueTypes,
	    zIndex: int,
	    size: px,
	    // SVG
	    fillOpacity: alpha,
	    strokeOpacity: alpha,
	    numOctaves: int,
	};

	/**
	 * A map of default value types for common values
	 */
	const defaultValueTypes = {
	    ...numberValueTypes,
	    // Color props
	    color,
	    backgroundColor: color,
	    outlineColor: color,
	    fill: color,
	    stroke: color,
	    // Border props
	    borderColor: color,
	    borderTopColor: color,
	    borderRightColor: color,
	    borderBottomColor: color,
	    borderLeftColor: color,
	    filter,
	    WebkitFilter: filter,
	};
	/**
	 * Gets the default ValueType for the provided value key
	 */
	const getDefaultValueType = (key) => defaultValueTypes[key];

	function getAnimatableNone(key, value) {
	    let defaultValueType = getDefaultValueType(key);
	    if (defaultValueType !== filter)
	        defaultValueType = complex;
	    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
	    return defaultValueType.getAnimatableNone
	        ? defaultValueType.getAnimatableNone(value)
	        : undefined;
	}

	/**
	 * If we encounter keyframes like "none" or "0" and we also have keyframes like
	 * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for
	 * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into
	 * zero equivalents, i.e. "#fff0" or "0px 0px".
	 */
	const invalidTemplates = new Set(["auto", "none", "0"]);
	function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
	    let i = 0;
	    let animatableTemplate = undefined;
	    while (i < unresolvedKeyframes.length && !animatableTemplate) {
	        const keyframe = unresolvedKeyframes[i];
	        if (typeof keyframe === "string" &&
	            !invalidTemplates.has(keyframe) &&
	            analyseComplexValue(keyframe).values.length) {
	            animatableTemplate = unresolvedKeyframes[i];
	        }
	        i++;
	    }
	    if (animatableTemplate && name) {
	        for (const noneIndex of noneKeyframeIndexes) {
	            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
	        }
	    }
	}

	class DOMKeyframesResolver extends KeyframeResolver {
	    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
	        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);
	    }
	    readKeyframes() {
	        const { unresolvedKeyframes, element, name } = this;
	        if (!element || !element.current)
	            return;
	        super.readKeyframes();
	        /**
	         * If any keyframe is a CSS variable, we need to find its value by sampling the element
	         */
	        for (let i = 0; i < unresolvedKeyframes.length; i++) {
	            let keyframe = unresolvedKeyframes[i];
	            if (typeof keyframe === "string") {
	                keyframe = keyframe.trim();
	                if (isCSSVariableToken(keyframe)) {
	                    const resolved = getVariableValue(keyframe, element.current);
	                    if (resolved !== undefined) {
	                        unresolvedKeyframes[i] = resolved;
	                    }
	                    if (i === unresolvedKeyframes.length - 1) {
	                        this.finalKeyframe = keyframe;
	                    }
	                }
	            }
	        }
	        /**
	         * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.
	         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which
	         * have a far bigger performance impact.
	         */
	        this.resolveNoneKeyframes();
	        /**
	         * Check to see if unit type has changed. If so schedule jobs that will
	         * temporarily set styles to the destination keyframes.
	         * Skip if we have more than two keyframes or this isn't a positional value.
	         * TODO: We can throw if there are multiple keyframes and the value type changes.
	         */
	        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
	            return;
	        }
	        const [origin, target] = unresolvedKeyframes;
	        const originType = findDimensionValueType(origin);
	        const targetType = findDimensionValueType(target);
	        /**
	         * Either we don't recognise these value types or we can animate between them.
	         */
	        if (originType === targetType)
	            return;
	        /**
	         * If both values are numbers or pixels, we can animate between them by
	         * converting them to numbers.
	         */
	        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
	            for (let i = 0; i < unresolvedKeyframes.length; i++) {
	                const value = unresolvedKeyframes[i];
	                if (typeof value === "string") {
	                    unresolvedKeyframes[i] = parseFloat(value);
	                }
	            }
	        }
	        else {
	            /**
	             * Else, the only way to resolve this is by measuring the element.
	             */
	            this.needsMeasurement = true;
	        }
	    }
	    resolveNoneKeyframes() {
	        const { unresolvedKeyframes, name } = this;
	        const noneKeyframeIndexes = [];
	        for (let i = 0; i < unresolvedKeyframes.length; i++) {
	            if (isNone(unresolvedKeyframes[i])) {
	                noneKeyframeIndexes.push(i);
	            }
	        }
	        if (noneKeyframeIndexes.length) {
	            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
	        }
	    }
	    measureInitialState() {
	        const { element, unresolvedKeyframes, name } = this;
	        if (!element || !element.current)
	            return;
	        if (name === "height") {
	            this.suspendedScrollY = window.pageYOffset;
	        }
	        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
	        unresolvedKeyframes[0] = this.measuredOrigin;
	        // Set final key frame to measure after next render
	        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
	        if (measureKeyframe !== undefined) {
	            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
	        }
	    }
	    measureEndState() {
	        var _a;
	        const { element, name, unresolvedKeyframes } = this;
	        if (!element || !element.current)
	            return;
	        const value = element.getValue(name);
	        value && value.jump(this.measuredOrigin, false);
	        const finalKeyframeIndex = unresolvedKeyframes.length - 1;
	        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
	        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
	        if (finalKeyframe !== null && this.finalKeyframe === undefined) {
	            this.finalKeyframe = finalKeyframe;
	        }
	        // If we removed transform values, reapply them before the next render
	        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
	            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
	                element
	                    .getValue(unsetTransformName)
	                    .set(unsetTransformValue);
	            });
	        }
	        this.resolveNoneKeyframes();
	    }
	}

	function isGenerator(type) {
	    return typeof type === "function";
	}

	let now;
	function clearTime() {
	    now = undefined;
	}
	/**
	 * An eventloop-synchronous alternative to performance.now().
	 *
	 * Ensures that time measurements remain consistent within a synchronous context.
	 * Usually calling performance.now() twice within the same synchronous context
	 * will return different values which isn't useful for animations when we're usually
	 * trying to sync animations to the same frame.
	 */
	const time = {
	    now: () => {
	        if (now === undefined) {
	            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming
	                ? frameData.timestamp
	                : performance.now());
	        }
	        return now;
	    },
	    set: (newTime) => {
	        now = newTime;
	        queueMicrotask(clearTime);
	    },
	};

	/**
	 * Check if a value is animatable. Examples:
	 *
	 * ✅: 100, "100px", "#fff"
	 * ❌: "block", "url(2.jpg)"
	 * @param value
	 *
	 * @internal
	 */
	const isAnimatable = (value, name) => {
	    // If the list of keys tat might be non-animatable grows, replace with Set
	    if (name === "zIndex")
	        return false;
	    // If it's a number or a keyframes array, we can animate it. We might at some point
	    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
	    // but for now lets leave it like this for performance reasons
	    if (typeof value === "number" || Array.isArray(value))
	        return true;
	    if (typeof value === "string" && // It's animatable if we have a string
	        (complex.test(value) || value === "0") && // And it contains numbers and/or colors
	        !value.startsWith("url(") // Unless it starts with "url("
	    ) {
	        return true;
	    }
	    return false;
	};

	function hasKeyframesChanged(keyframes) {
	    const current = keyframes[0];
	    if (keyframes.length === 1)
	        return true;
	    for (let i = 0; i < keyframes.length; i++) {
	        if (keyframes[i] !== current)
	            return true;
	    }
	}
	function canAnimate(keyframes, name, type, velocity) {
	    /**
	     * Check if we're able to animate between the start and end keyframes,
	     * and throw a warning if we're attempting to animate between one that's
	     * animatable and another that isn't.
	     */
	    const originKeyframe = keyframes[0];
	    if (originKeyframe === null)
	        return false;
	    /**
	     * These aren't traditionally animatable but we do support them.
	     * In future we could look into making this more generic or replacing
	     * this function with mix() === mixImmediate
	     */
	    if (name === "display" || name === "visibility")
	        return true;
	    const targetKeyframe = keyframes[keyframes.length - 1];
	    const isOriginAnimatable = isAnimatable(originKeyframe, name);
	    const isTargetAnimatable = isAnimatable(targetKeyframe, name);
	    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
	    // Always skip if any of these are true
	    if (!isOriginAnimatable || !isTargetAnimatable) {
	        return false;
	    }
	    return (hasKeyframesChanged(keyframes) ||
	        ((type === "spring" || isGenerator(type)) && velocity));
	}

	/**
	 * Maximum time allowed between an animation being created and it being
	 * resolved for us to use the latter as the start time.
	 *
	 * This is to ensure that while we prefer to "start" an animation as soon
	 * as it's triggered, we also want to avoid a visual jump if there's a big delay
	 * between these two moments.
	 */
	const MAX_RESOLVE_DELAY = 40;
	class BaseAnimation {
	    constructor({ autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {
	        // Track whether the animation has been stopped. Stopped animations won't restart.
	        this.isStopped = false;
	        this.hasAttemptedResolve = false;
	        this.createdAt = time.now();
	        this.options = {
	            autoplay,
	            delay,
	            type,
	            repeat,
	            repeatDelay,
	            repeatType,
	            ...options,
	        };
	        this.updateFinishedPromise();
	    }
	    /**
	     * This method uses the createdAt and resolvedAt to calculate the
	     * animation startTime. *Ideally*, we would use the createdAt time as t=0
	     * as the following frame would then be the first frame of the animation in
	     * progress, which would feel snappier.
	     *
	     * However, if there's a delay (main thread work) between the creation of
	     * the animation and the first commited frame, we prefer to use resolvedAt
	     * to avoid a sudden jump into the animation.
	     */
	    calcStartTime() {
	        if (!this.resolvedAt)
	            return this.createdAt;
	        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
	            ? this.resolvedAt
	            : this.createdAt;
	    }
	    /**
	     * A getter for resolved data. If keyframes are not yet resolved, accessing
	     * this.resolved will synchronously flush all pending keyframe resolvers.
	     * This is a deoptimisation, but at its worst still batches read/writes.
	     */
	    get resolved() {
	        if (!this._resolved && !this.hasAttemptedResolve) {
	            flushKeyframeResolvers();
	        }
	        return this._resolved;
	    }
	    /**
	     * A method to be called when the keyframes resolver completes. This method
	     * will check if its possible to run the animation and, if not, skip it.
	     * Otherwise, it will call initPlayback on the implementing class.
	     */
	    onKeyframesResolved(keyframes, finalKeyframe) {
	        this.resolvedAt = time.now();
	        this.hasAttemptedResolve = true;
	        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;
	        /**
	         * If we can't animate this value with the resolved keyframes
	         * then we should complete it immediately.
	         */
	        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {
	            // Finish immediately
	            if (!delay) {
	                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));
	                onComplete === null || onComplete === void 0 ? void 0 : onComplete();
	                this.resolveFinishedPromise();
	                return;
	            }
	            // Finish after a delay
	            else {
	                this.options.duration = 0;
	            }
	        }
	        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);
	        if (resolvedAnimation === false)
	            return;
	        this._resolved = {
	            keyframes,
	            finalKeyframe,
	            ...resolvedAnimation,
	        };
	        this.onPostResolved();
	    }
	    onPostResolved() { }
	    /**
	     * Allows the returned animation to be awaited or promise-chained. Currently
	     * resolves when the animation finishes at all but in a future update could/should
	     * reject if its cancels.
	     */
	    then(resolve, reject) {
	        return this.currentFinishedPromise.then(resolve, reject);
	    }
	    flatten() {
	        this.options.type = "keyframes";
	        this.options.ease = "linear";
	    }
	    updateFinishedPromise() {
	        this.currentFinishedPromise = new Promise((resolve) => {
	            this.resolveFinishedPromise = resolve;
	        });
	    }
	}

	/*
	  Progress within given range

	  Given a lower limit and an upper limit, we return the progress
	  (expressed as a number 0-1) represented by the given value, and
	  limit that progress to within 0-1.

	  @param [number]: Lower limit
	  @param [number]: Upper limit
	  @param [number]: Value to find progress within given range
	  @return [number]: Progress of value within range as expressed 0-1
	*/
	const progress = (from, to, value) => {
	    const toFromDifference = to - from;
	    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
	};

	const generateLinearEasing = (easing, duration, // as milliseconds
	resolution = 10 // as milliseconds
	) => {
	    let points = "";
	    const numPoints = Math.max(Math.round(duration / resolution), 2);
	    for (let i = 0; i < numPoints; i++) {
	        points += easing(progress(0, numPoints - 1, i)) + ", ";
	    }
	    return `linear(${points.substring(0, points.length - 2)})`;
	};

	/*
	  Convert velocity into velocity per second

	  @param [number]: Unit per frame
	  @param [number]: Frame duration in ms
	*/
	function velocityPerSecond(velocity, frameDuration) {
	    return frameDuration ? velocity * (1000 / frameDuration) : 0;
	}

	const velocitySampleDuration = 5; // ms
	function calcGeneratorVelocity(resolveValue, t, current) {
	    const prevT = Math.max(t - velocitySampleDuration, 0);
	    return velocityPerSecond(current - resolveValue(prevT), t - prevT);
	}

	const springDefaults = {
	    // Default spring physics
	    stiffness: 100,
	    damping: 10,
	    mass: 1.0,
	    velocity: 0.0,
	    // Default duration/bounce-based options
	    duration: 800, // in ms
	    bounce: 0.3,
	    visualDuration: 0.3, // in seconds
	    // Rest thresholds
	    restSpeed: {
	        granular: 0.01,
	        default: 2,
	    },
	    restDelta: {
	        granular: 0.005,
	        default: 0.5,
	    },
	    // Limits
	    minDuration: 0.01, // in seconds
	    maxDuration: 10.0, // in seconds
	    minDamping: 0.05,
	    maxDamping: 1,
	};

	const safeMin = 0.001;
	function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {
	    let envelope;
	    let derivative;
	    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
	    let dampingRatio = 1 - bounce;
	    /**
	     * Restrict dampingRatio and duration to within acceptable ranges.
	     */
	    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
	    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
	    if (dampingRatio < 1) {
	        /**
	         * Underdamped spring
	         */
	        envelope = (undampedFreq) => {
	            const exponentialDecay = undampedFreq * dampingRatio;
	            const delta = exponentialDecay * duration;
	            const a = exponentialDecay - velocity;
	            const b = calcAngularFreq(undampedFreq, dampingRatio);
	            const c = Math.exp(-delta);
	            return safeMin - (a / b) * c;
	        };
	        derivative = (undampedFreq) => {
	            const exponentialDecay = undampedFreq * dampingRatio;
	            const delta = exponentialDecay * duration;
	            const d = delta * velocity + velocity;
	            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
	            const f = Math.exp(-delta);
	            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
	            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
	            return (factor * ((d - e) * f)) / g;
	        };
	    }
	    else {
	        /**
	         * Critically-damped spring
	         */
	        envelope = (undampedFreq) => {
	            const a = Math.exp(-undampedFreq * duration);
	            const b = (undampedFreq - velocity) * duration + 1;
	            return -safeMin + a * b;
	        };
	        derivative = (undampedFreq) => {
	            const a = Math.exp(-undampedFreq * duration);
	            const b = (velocity - undampedFreq) * (duration * duration);
	            return a * b;
	        };
	    }
	    const initialGuess = 5 / duration;
	    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
	    duration = secondsToMilliseconds(duration);
	    if (isNaN(undampedFreq)) {
	        return {
	            stiffness: springDefaults.stiffness,
	            damping: springDefaults.damping,
	            duration,
	        };
	    }
	    else {
	        const stiffness = Math.pow(undampedFreq, 2) * mass;
	        return {
	            stiffness,
	            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
	            duration,
	        };
	    }
	}
	const rootIterations = 12;
	function approximateRoot(envelope, derivative, initialGuess) {
	    let result = initialGuess;
	    for (let i = 1; i < rootIterations; i++) {
	        result = result - envelope(result) / derivative(result);
	    }
	    return result;
	}
	function calcAngularFreq(undampedFreq, dampingRatio) {
	    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
	}

	/**
	 * Implement a practical max duration for keyframe generation
	 * to prevent infinite loops
	 */
	const maxGeneratorDuration = 20000;
	function calcGeneratorDuration(generator) {
	    let duration = 0;
	    const timeStep = 50;
	    let state = generator.next(duration);
	    while (!state.done && duration < maxGeneratorDuration) {
	        duration += timeStep;
	        state = generator.next(duration);
	    }
	    return duration >= maxGeneratorDuration ? Infinity : duration;
	}

	const durationKeys = ["duration", "bounce"];
	const physicsKeys = ["stiffness", "damping", "mass"];
	function isSpringType(options, keys) {
	    return keys.some((key) => options[key] !== undefined);
	}
	function getSpringOptions(options) {
	    let springOptions = {
	        velocity: springDefaults.velocity,
	        stiffness: springDefaults.stiffness,
	        damping: springDefaults.damping,
	        mass: springDefaults.mass,
	        isResolvedFromDuration: false,
	        ...options,
	    };
	    // stiffness/damping/mass overrides duration/bounce
	    if (!isSpringType(options, physicsKeys) &&
	        isSpringType(options, durationKeys)) {
	        if (options.visualDuration) {
	            const visualDuration = options.visualDuration;
	            const root = (2 * Math.PI) / (visualDuration * 1.2);
	            const stiffness = root * root;
	            const damping = 2 * clamp(0.05, 1, 1 - options.bounce) * Math.sqrt(stiffness);
	            springOptions = {
	                ...springOptions,
	                mass: springDefaults.mass,
	                stiffness,
	                damping,
	            };
	        }
	        else {
	            const derived = findSpring(options);
	            springOptions = {
	                ...springOptions,
	                ...derived,
	                mass: springDefaults.mass,
	            };
	            springOptions.isResolvedFromDuration = true;
	        }
	    }
	    return springOptions;
	}
	function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
	    const options = typeof optionsOrVisualDuration !== "object"
	        ? {
	            visualDuration: optionsOrVisualDuration,
	            keyframes: [0, 1],
	            bounce,
	        }
	        : optionsOrVisualDuration;
	    let { restSpeed, restDelta } = options;
	    const origin = options.keyframes[0];
	    const target = options.keyframes[options.keyframes.length - 1];
	    /**
	     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
	     * to reduce GC during animation.
	     */
	    const state = { done: false, value: origin };
	    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({
	        ...options,
	        velocity: -millisecondsToSeconds(options.velocity || 0),
	    });
	    const initialVelocity = velocity || 0.0;
	    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
	    const initialDelta = target - origin;
	    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
	    /**
	     * If we're working on a granular scale, use smaller defaults for determining
	     * when the spring is finished.
	     *
	     * These defaults have been selected emprically based on what strikes a good
	     * ratio between feeling good and finishing as soon as changes are imperceptible.
	     */
	    const isGranularScale = Math.abs(initialDelta) < 5;
	    restSpeed || (restSpeed = isGranularScale
	        ? springDefaults.restSpeed.granular
	        : springDefaults.restSpeed.default);
	    restDelta || (restDelta = isGranularScale
	        ? springDefaults.restDelta.granular
	        : springDefaults.restDelta.default);
	    let resolveSpring;
	    if (dampingRatio < 1) {
	        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
	        // Underdamped spring
	        resolveSpring = (t) => {
	            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
	            return (target -
	                envelope *
	                    (((initialVelocity +
	                        dampingRatio * undampedAngularFreq * initialDelta) /
	                        angularFreq) *
	                        Math.sin(angularFreq * t) +
	                        initialDelta * Math.cos(angularFreq * t)));
	        };
	    }
	    else if (dampingRatio === 1) {
	        // Critically damped spring
	        resolveSpring = (t) => target -
	            Math.exp(-undampedAngularFreq * t) *
	                (initialDelta +
	                    (initialVelocity + undampedAngularFreq * initialDelta) * t);
	    }
	    else {
	        // Overdamped spring
	        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
	        resolveSpring = (t) => {
	            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
	            // When performing sinh or cosh values can hit Infinity so we cap them here
	            const freqForT = Math.min(dampedAngularFreq * t, 300);
	            return (target -
	                (envelope *
	                    ((initialVelocity +
	                        dampingRatio * undampedAngularFreq * initialDelta) *
	                        Math.sinh(freqForT) +
	                        dampedAngularFreq *
	                            initialDelta *
	                            Math.cosh(freqForT))) /
	                    dampedAngularFreq);
	        };
	    }
	    const generator = {
	        calculatedDuration: isResolvedFromDuration ? duration || null : null,
	        next: (t) => {
	            const current = resolveSpring(t);
	            if (!isResolvedFromDuration) {
	                let currentVelocity = 0.0;
	                /**
	                 * We only need to calculate velocity for under-damped springs
	                 * as over- and critically-damped springs can't overshoot, so
	                 * checking only for displacement is enough.
	                 */
	                if (dampingRatio < 1) {
	                    currentVelocity =
	                        t === 0
	                            ? secondsToMilliseconds(initialVelocity)
	                            : calcGeneratorVelocity(resolveSpring, t, current);
	                }
	                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
	                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
	                state.done =
	                    isBelowVelocityThreshold && isBelowDisplacementThreshold;
	            }
	            else {
	                state.done = t >= duration;
	            }
	            state.value = state.done ? target : current;
	            return state;
	        },
	        toString: () => {
	            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
	            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
	            return calculatedDuration + "ms " + easing;
	        },
	    };
	    return generator;
	}

	function inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {
	    const origin = keyframes[0];
	    const state = {
	        done: false,
	        value: origin,
	    };
	    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);
	    const nearestBoundary = (v) => {
	        if (min === undefined)
	            return max;
	        if (max === undefined)
	            return min;
	        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
	    };
	    let amplitude = power * velocity;
	    const ideal = origin + amplitude;
	    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
	    /**
	     * If the target has changed we need to re-calculate the amplitude, otherwise
	     * the animation will start from the wrong position.
	     */
	    if (target !== ideal)
	        amplitude = target - origin;
	    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
	    const calcLatest = (t) => target + calcDelta(t);
	    const applyFriction = (t) => {
	        const delta = calcDelta(t);
	        const latest = calcLatest(t);
	        state.done = Math.abs(delta) <= restDelta;
	        state.value = state.done ? target : latest;
	    };
	    /**
	     * Ideally this would resolve for t in a stateless way, we could
	     * do that by always precalculating the animation but as we know
	     * this will be done anyway we can assume that spring will
	     * be discovered during that.
	     */
	    let timeReachedBoundary;
	    let spring$1;
	    const checkCatchBoundary = (t) => {
	        if (!isOutOfBounds(state.value))
	            return;
	        timeReachedBoundary = t;
	        spring$1 = spring({
	            keyframes: [state.value, nearestBoundary(state.value)],
	            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000
	            damping: bounceDamping,
	            stiffness: bounceStiffness,
	            restDelta,
	            restSpeed,
	        });
	    };
	    checkCatchBoundary(0);
	    return {
	        calculatedDuration: null,
	        next: (t) => {
	            /**
	             * We need to resolve the friction to figure out if we need a
	             * spring but we don't want to do this twice per frame. So here
	             * we flag if we updated for this frame and later if we did
	             * we can skip doing it again.
	             */
	            let hasUpdatedFrame = false;
	            if (!spring$1 && timeReachedBoundary === undefined) {
	                hasUpdatedFrame = true;
	                applyFriction(t);
	                checkCatchBoundary(t);
	            }
	            /**
	             * If we have a spring and the provided t is beyond the moment the friction
	             * animation crossed the min/max boundary, use the spring.
	             */
	            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
	                return spring$1.next(t - timeReachedBoundary);
	            }
	            else {
	                !hasUpdatedFrame && applyFriction(t);
	                return state;
	            }
	        },
	    };
	}

	const easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);
	const easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);
	const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);

	const isEasingArray = (ease) => {
	    return Array.isArray(ease) && typeof ease[0] !== "number";
	};

	const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

	const easingLookup = {
	    linear: noop,
	    easeIn,
	    easeInOut,
	    easeOut,
	    circIn,
	    circInOut,
	    circOut,
	    backIn,
	    backInOut,
	    backOut,
	    anticipate,
	};
	const easingDefinitionToFunction = (definition) => {
	    if (isBezierDefinition(definition)) {
	        // If cubic bezier definition, create bezier curve
	        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
	        const [x1, y1, x2, y2] = definition;
	        return cubicBezier(x1, y1, x2, y2);
	    }
	    else if (typeof definition === "string") {
	        // Else lookup from table
	        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
	        return easingLookup[definition];
	    }
	    return definition;
	};

	/**
	 * Pipe
	 * Compose other transformers to run linearily
	 * pipe(min(20), max(40))
	 * @param  {...functions} transformers
	 * @return {function}
	 */
	const combineFunctions = (a, b) => (v) => b(a(v));
	const pipe = (...transformers) => transformers.reduce(combineFunctions);

	/*
	  Value in range from progress

	  Given a lower limit and an upper limit, we return the value within
	  that range as expressed by progress (usually a number from 0 to 1)

	  So progress = 0.5 would change

	  from -------- to

	  to

	  from ---- to

	  E.g. from = 10, to = 20, progress = 0.5 => 15

	  @param [number]: Lower limit of range
	  @param [number]: Upper limit of range
	  @param [number]: The progress between lower and upper limits expressed 0-1
	  @return [number]: Value as calculated from progress within range (not limited within range)
	*/
	const mixNumber$1 = (from, to, progress) => {
	    return from + (to - from) * progress;
	};

	// Adapted from https://gist.github.com/mjackson/5311256
	function hueToRgb(p, q, t) {
	    if (t < 0)
	        t += 1;
	    if (t > 1)
	        t -= 1;
	    if (t < 1 / 6)
	        return p + (q - p) * 6 * t;
	    if (t < 1 / 2)
	        return q;
	    if (t < 2 / 3)
	        return p + (q - p) * (2 / 3 - t) * 6;
	    return p;
	}
	function hslaToRgba({ hue, saturation, lightness, alpha }) {
	    hue /= 360;
	    saturation /= 100;
	    lightness /= 100;
	    let red = 0;
	    let green = 0;
	    let blue = 0;
	    if (!saturation) {
	        red = green = blue = lightness;
	    }
	    else {
	        const q = lightness < 0.5
	            ? lightness * (1 + saturation)
	            : lightness + saturation - lightness * saturation;
	        const p = 2 * lightness - q;
	        red = hueToRgb(p, q, hue + 1 / 3);
	        green = hueToRgb(p, q, hue);
	        blue = hueToRgb(p, q, hue - 1 / 3);
	    }
	    return {
	        red: Math.round(red * 255),
	        green: Math.round(green * 255),
	        blue: Math.round(blue * 255),
	        alpha,
	    };
	}

	function mixImmediate(a, b) {
	    return (p) => (p > 0 ? b : a);
	}

	// Linear color space blending
	// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
	// Demonstrated http://codepen.io/osublake/pen/xGVVaN
	const mixLinearColor = (from, to, v) => {
	    const fromExpo = from * from;
	    const expo = v * (to * to - fromExpo) + fromExpo;
	    return expo < 0 ? 0 : Math.sqrt(expo);
	};
	const colorTypes = [hex, rgba, hsla];
	const getColorType = (v) => colorTypes.find((type) => type.test(v));
	function asRGBA(color) {
	    const type = getColorType(color);
	    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
	    if (!Boolean(type))
	        return false;
	    let model = type.parse(color);
	    if (type === hsla) {
	        // TODO Remove this cast - needed since Motion's stricter typing
	        model = hslaToRgba(model);
	    }
	    return model;
	}
	const mixColor = (from, to) => {
	    const fromRGBA = asRGBA(from);
	    const toRGBA = asRGBA(to);
	    if (!fromRGBA || !toRGBA) {
	        return mixImmediate(from, to);
	    }
	    const blended = { ...fromRGBA };
	    return (v) => {
	        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
	        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
	        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
	        blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
	        return rgba.transform(blended);
	    };
	};

	const invisibleValues = new Set(["none", "hidden"]);
	/**
	 * Returns a function that, when provided a progress value between 0 and 1,
	 * will return the "none" or "hidden" string only when the progress is that of
	 * the origin or target.
	 */
	function mixVisibility(origin, target) {
	    if (invisibleValues.has(origin)) {
	        return (p) => (p <= 0 ? origin : target);
	    }
	    else {
	        return (p) => (p >= 1 ? target : origin);
	    }
	}

	function mixNumber(a, b) {
	    return (p) => mixNumber$1(a, b, p);
	}
	function getMixer(a) {
	    if (typeof a === "number") {
	        return mixNumber;
	    }
	    else if (typeof a === "string") {
	        return isCSSVariableToken(a)
	            ? mixImmediate
	            : color.test(a)
	                ? mixColor
	                : mixComplex;
	    }
	    else if (Array.isArray(a)) {
	        return mixArray;
	    }
	    else if (typeof a === "object") {
	        return color.test(a) ? mixColor : mixObject;
	    }
	    return mixImmediate;
	}
	function mixArray(a, b) {
	    const output = [...a];
	    const numValues = output.length;
	    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
	    return (p) => {
	        for (let i = 0; i < numValues; i++) {
	            output[i] = blendValue[i](p);
	        }
	        return output;
	    };
	}
	function mixObject(a, b) {
	    const output = { ...a, ...b };
	    const blendValue = {};
	    for (const key in output) {
	        if (a[key] !== undefined && b[key] !== undefined) {
	            blendValue[key] = getMixer(a[key])(a[key], b[key]);
	        }
	    }
	    return (v) => {
	        for (const key in blendValue) {
	            output[key] = blendValue[key](v);
	        }
	        return output;
	    };
	}
	function matchOrder(origin, target) {
	    var _a;
	    const orderedOrigin = [];
	    const pointers = { color: 0, var: 0, number: 0 };
	    for (let i = 0; i < target.values.length; i++) {
	        const type = target.types[i];
	        const originIndex = origin.indexes[type][pointers[type]];
	        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
	        orderedOrigin[i] = originValue;
	        pointers[type]++;
	    }
	    return orderedOrigin;
	}
	const mixComplex = (origin, target) => {
	    const template = complex.createTransformer(target);
	    const originStats = analyseComplexValue(origin);
	    const targetStats = analyseComplexValue(target);
	    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&
	        originStats.indexes.color.length === targetStats.indexes.color.length &&
	        originStats.indexes.number.length >= targetStats.indexes.number.length;
	    if (canInterpolate) {
	        if ((invisibleValues.has(origin) &&
	            !targetStats.values.length) ||
	            (invisibleValues.has(target) &&
	                !originStats.values.length)) {
	            return mixVisibility(origin, target);
	        }
	        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
	    }
	    else {
	        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
	        return mixImmediate(origin, target);
	    }
	};

	function mix(from, to, p) {
	    if (typeof from === "number" &&
	        typeof to === "number" &&
	        typeof p === "number") {
	        return mixNumber$1(from, to, p);
	    }
	    const mixer = getMixer(from);
	    return mixer(from, to);
	}

	function createMixers(output, ease, customMixer) {
	    const mixers = [];
	    const mixerFactory = customMixer || mix;
	    const numMixers = output.length - 1;
	    for (let i = 0; i < numMixers; i++) {
	        let mixer = mixerFactory(output[i], output[i + 1]);
	        if (ease) {
	            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
	            mixer = pipe(easingFunction, mixer);
	        }
	        mixers.push(mixer);
	    }
	    return mixers;
	}
	/**
	 * Create a function that maps from a numerical input array to a generic output array.
	 *
	 * Accepts:
	 *   - Numbers
	 *   - Colors (hex, hsl, hsla, rgb, rgba)
	 *   - Complex (combinations of one or more numbers or strings)
	 *
	 * ```jsx
	 * const mixColor = interpolate([0, 1], ['#fff', '#000'])
	 *
	 * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
	 * ```
	 *
	 * TODO Revist this approach once we've moved to data models for values,
	 * probably not needed to pregenerate mixer functions.
	 *
	 * @public
	 */
	function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
	    const inputLength = input.length;
	    invariant(inputLength === output.length, "Both input and output ranges must be the same length");
	    /**
	     * If we're only provided a single input, we can just make a function
	     * that returns the output.
	     */
	    if (inputLength === 1)
	        return () => output[0];
	    if (inputLength === 2 && input[0] === input[1])
	        return () => output[1];
	    // If input runs highest -> lowest, reverse both arrays
	    if (input[0] > input[inputLength - 1]) {
	        input = [...input].reverse();
	        output = [...output].reverse();
	    }
	    const mixers = createMixers(output, ease, mixer);
	    const numMixers = mixers.length;
	    const interpolator = (v) => {
	        let i = 0;
	        if (numMixers > 1) {
	            for (; i < input.length - 2; i++) {
	                if (v < input[i + 1])
	                    break;
	            }
	        }
	        const progressInRange = progress(input[i], input[i + 1], v);
	        return mixers[i](progressInRange);
	    };
	    return isClamp
	        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))
	        : interpolator;
	}

	function fillOffset(offset, remaining) {
	    const min = offset[offset.length - 1];
	    for (let i = 1; i <= remaining; i++) {
	        const offsetProgress = progress(0, remaining, i);
	        offset.push(mixNumber$1(min, 1, offsetProgress));
	    }
	}

	function defaultOffset(arr) {
	    const offset = [0];
	    fillOffset(offset, arr.length - 1);
	    return offset;
	}

	function convertOffsetToTimes(offset, duration) {
	    return offset.map((o) => o * duration);
	}

	function defaultEasing(values, easing) {
	    return values.map(() => easing || easeInOut).splice(0, values.length - 1);
	}
	function keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "easeInOut", }) {
	    /**
	     * Easing functions can be externally defined as strings. Here we convert them
	     * into actual functions.
	     */
	    const easingFunctions = isEasingArray(ease)
	        ? ease.map(easingDefinitionToFunction)
	        : easingDefinitionToFunction(ease);
	    /**
	     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
	     * to reduce GC during animation.
	     */
	    const state = {
	        done: false,
	        value: keyframeValues[0],
	    };
	    /**
	     * Create a times array based on the provided 0-1 offsets
	     */
	    const absoluteTimes = convertOffsetToTimes(
	    // Only use the provided offsets if they're the correct length
	    // TODO Maybe we should warn here if there's a length mismatch
	    times && times.length === keyframeValues.length
	        ? times
	        : defaultOffset(keyframeValues), duration);
	    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
	        ease: Array.isArray(easingFunctions)
	            ? easingFunctions
	            : defaultEasing(keyframeValues, easingFunctions),
	    });
	    return {
	        calculatedDuration: duration,
	        next: (t) => {
	            state.value = mapTimeToKeyframe(t);
	            state.done = t >= duration;
	            return state;
	        },
	    };
	}

	const frameloopDriver = (update) => {
	    const passTimestamp = ({ timestamp }) => update(timestamp);
	    return {
	        start: () => frame.update(passTimestamp, true),
	        stop: () => cancelFrame(passTimestamp),
	        /**
	         * If we're processing this frame we can use the
	         * framelocked timestamp to keep things in sync.
	         */
	        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
	    };
	};

	const generators = {
	    decay: inertia,
	    inertia,
	    tween: keyframes,
	    keyframes: keyframes,
	    spring,
	};
	const percentToProgress = (percent) => percent / 100;
	/**
	 * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of
	 * features we expose publically. Mostly the compatibility is to ensure visual identity
	 * between both WAAPI and main thread animations.
	 */
	class MainThreadAnimation extends BaseAnimation {
	    constructor(options) {
	        super(options);
	        /**
	         * The time at which the animation was paused.
	         */
	        this.holdTime = null;
	        /**
	         * The time at which the animation was cancelled.
	         */
	        this.cancelTime = null;
	        /**
	         * The current time of the animation.
	         */
	        this.currentTime = 0;
	        /**
	         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.
	         */
	        this.playbackSpeed = 1;
	        /**
	         * The state of the animation to apply when the animation is resolved. This
	         * allows calls to the public API to control the animation before it is resolved,
	         * without us having to resolve it first.
	         */
	        this.pendingPlayState = "running";
	        /**
	         * The time at which the animation was started.
	         */
	        this.startTime = null;
	        this.state = "idle";
	        /**
	         * This method is bound to the instance to fix a pattern where
	         * animation.stop is returned as a reference from a useEffect.
	         */
	        this.stop = () => {
	            this.resolver.cancel();
	            this.isStopped = true;
	            if (this.state === "idle")
	                return;
	            this.teardown();
	            const { onStop } = this.options;
	            onStop && onStop();
	        };
	        const { name, motionValue, element, keyframes } = this.options;
	        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
	        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
	        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
	        this.resolver.scheduleResolve();
	    }
	    flatten() {
	        super.flatten();
	        // If we've already resolved the animation, re-initialise it
	        if (this._resolved) {
	            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
	        }
	    }
	    initPlayback(keyframes$1) {
	        const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;
	        const generatorFactory = isGenerator(type)
	            ? type
	            : generators[type] || keyframes;
	        /**
	         * If our generator doesn't support mixing numbers, we need to replace keyframes with
	         * [0, 100] and then make a function that maps that to the actual keyframes.
	         *
	         * 100 is chosen instead of 1 as it works nicer with spring animations.
	         */
	        let mapPercentToKeyframes;
	        let mirroredGenerator;
	        if (generatorFactory !== keyframes &&
	            typeof keyframes$1[0] !== "number") {
	            if (process.env.NODE_ENV !== "production") {
	                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
	            }
	            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
	            keyframes$1 = [0, 100];
	        }
	        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });
	        /**
	         * If we have a mirror repeat type we need to create a second generator that outputs the
	         * mirrored (not reversed) animation and later ping pong between the two generators.
	         */
	        if (repeatType === "mirror") {
	            mirroredGenerator = generatorFactory({
	                ...this.options,
	                keyframes: [...keyframes$1].reverse(),
	                velocity: -velocity,
	            });
	        }
	        /**
	         * If duration is undefined and we have repeat options,
	         * we need to calculate a duration from the generator.
	         *
	         * We set it to the generator itself to cache the duration.
	         * Any timeline resolver will need to have already precalculated
	         * the duration by this step.
	         */
	        if (generator.calculatedDuration === null) {
	            generator.calculatedDuration = calcGeneratorDuration(generator);
	        }
	        const { calculatedDuration } = generator;
	        const resolvedDuration = calculatedDuration + repeatDelay;
	        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
	        return {
	            generator,
	            mirroredGenerator,
	            mapPercentToKeyframes,
	            calculatedDuration,
	            resolvedDuration,
	            totalDuration,
	        };
	    }
	    onPostResolved() {
	        const { autoplay = true } = this.options;
	        this.play();
	        if (this.pendingPlayState === "paused" || !autoplay) {
	            this.pause();
	        }
	        else {
	            this.state = this.pendingPlayState;
	        }
	    }
	    tick(timestamp, sample = false) {
	        const { resolved } = this;
	        // If the animations has failed to resolve, return the final keyframe.
	        if (!resolved) {
	            const { keyframes } = this.options;
	            return { done: true, value: keyframes[keyframes.length - 1] };
	        }
	        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;
	        if (this.startTime === null)
	            return generator.next(0);
	        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;
	        /**
	         * requestAnimationFrame timestamps can come through as lower than
	         * the startTime as set by performance.now(). Here we prevent this,
	         * though in the future it could be possible to make setting startTime
	         * a pending operation that gets resolved here.
	         */
	        if (this.speed > 0) {
	            this.startTime = Math.min(this.startTime, timestamp);
	        }
	        else if (this.speed < 0) {
	            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
	        }
	        // Update currentTime
	        if (sample) {
	            this.currentTime = timestamp;
	        }
	        else if (this.holdTime !== null) {
	            this.currentTime = this.holdTime;
	        }
	        else {
	            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =
	            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for
	            // example.
	            this.currentTime =
	                Math.round(timestamp - this.startTime) * this.speed;
	        }
	        // Rebase on delay
	        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);
	        const isInDelayPhase = this.speed >= 0
	            ? timeWithoutDelay < 0
	            : timeWithoutDelay > totalDuration;
	        this.currentTime = Math.max(timeWithoutDelay, 0);
	        // If this animation has finished, set the current time  to the total duration.
	        if (this.state === "finished" && this.holdTime === null) {
	            this.currentTime = totalDuration;
	        }
	        let elapsed = this.currentTime;
	        let frameGenerator = generator;
	        if (repeat) {
	            /**
	             * Get the current progress (0-1) of the animation. If t is >
	             * than duration we'll get values like 2.5 (midway through the
	             * third iteration)
	             */
	            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
	            /**
	             * Get the current iteration (0 indexed). For instance the floor of
	             * 2.5 is 2.
	             */
	            let currentIteration = Math.floor(progress);
	            /**
	             * Get the current progress of the iteration by taking the remainder
	             * so 2.5 is 0.5 through iteration 2
	             */
	            let iterationProgress = progress % 1.0;
	            /**
	             * If iteration progress is 1 we count that as the end
	             * of the previous iteration.
	             */
	            if (!iterationProgress && progress >= 1) {
	                iterationProgress = 1;
	            }
	            iterationProgress === 1 && currentIteration--;
	            currentIteration = Math.min(currentIteration, repeat + 1);
	            /**
	             * Reverse progress if we're not running in "normal" direction
	             */
	            const isOddIteration = Boolean(currentIteration % 2);
	            if (isOddIteration) {
	                if (repeatType === "reverse") {
	                    iterationProgress = 1 - iterationProgress;
	                    if (repeatDelay) {
	                        iterationProgress -= repeatDelay / resolvedDuration;
	                    }
	                }
	                else if (repeatType === "mirror") {
	                    frameGenerator = mirroredGenerator;
	                }
	            }
	            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
	        }
	        /**
	         * If we're in negative time, set state as the initial keyframe.
	         * This prevents delay: x, duration: 0 animations from finishing
	         * instantly.
	         */
	        const state = isInDelayPhase
	            ? { done: false, value: keyframes[0] }
	            : frameGenerator.next(elapsed);
	        if (mapPercentToKeyframes) {
	            state.value = mapPercentToKeyframes(state.value);
	        }
	        let { done } = state;
	        if (!isInDelayPhase && calculatedDuration !== null) {
	            done =
	                this.speed >= 0
	                    ? this.currentTime >= totalDuration
	                    : this.currentTime <= 0;
	        }
	        const isAnimationFinished = this.holdTime === null &&
	            (this.state === "finished" || (this.state === "running" && done));
	        if (isAnimationFinished && finalKeyframe !== undefined) {
	            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);
	        }
	        if (onUpdate) {
	            onUpdate(state.value);
	        }
	        if (isAnimationFinished) {
	            this.finish();
	        }
	        return state;
	    }
	    get duration() {
	        const { resolved } = this;
	        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;
	    }
	    get time() {
	        return millisecondsToSeconds(this.currentTime);
	    }
	    set time(newTime) {
	        newTime = secondsToMilliseconds(newTime);
	        this.currentTime = newTime;
	        if (this.holdTime !== null || this.speed === 0) {
	            this.holdTime = newTime;
	        }
	        else if (this.driver) {
	            this.startTime = this.driver.now() - newTime / this.speed;
	        }
	    }
	    get speed() {
	        return this.playbackSpeed;
	    }
	    set speed(newSpeed) {
	        const hasChanged = this.playbackSpeed !== newSpeed;
	        this.playbackSpeed = newSpeed;
	        if (hasChanged) {
	            this.time = millisecondsToSeconds(this.currentTime);
	        }
	    }
	    play() {
	        if (!this.resolver.isScheduled) {
	            this.resolver.resume();
	        }
	        if (!this._resolved) {
	            this.pendingPlayState = "running";
	            return;
	        }
	        if (this.isStopped)
	            return;
	        const { driver = frameloopDriver, onPlay, startTime } = this.options;
	        if (!this.driver) {
	            this.driver = driver((timestamp) => this.tick(timestamp));
	        }
	        onPlay && onPlay();
	        const now = this.driver.now();
	        if (this.holdTime !== null) {
	            this.startTime = now - this.holdTime;
	        }
	        else if (!this.startTime) {
	            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
	        }
	        else if (this.state === "finished") {
	            this.startTime = now;
	        }
	        if (this.state === "finished") {
	            this.updateFinishedPromise();
	        }
	        this.cancelTime = this.startTime;
	        this.holdTime = null;
	        /**
	         * Set playState to running only after we've used it in
	         * the previous logic.
	         */
	        this.state = "running";
	        this.driver.start();
	    }
	    pause() {
	        var _a;
	        if (!this._resolved) {
	            this.pendingPlayState = "paused";
	            return;
	        }
	        this.state = "paused";
	        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
	    }
	    complete() {
	        if (this.state !== "running") {
	            this.play();
	        }
	        this.pendingPlayState = this.state = "finished";
	        this.holdTime = null;
	    }
	    finish() {
	        this.teardown();
	        this.state = "finished";
	        const { onComplete } = this.options;
	        onComplete && onComplete();
	    }
	    cancel() {
	        if (this.cancelTime !== null) {
	            this.tick(this.cancelTime);
	        }
	        this.teardown();
	        this.updateFinishedPromise();
	    }
	    teardown() {
	        this.state = "idle";
	        this.stopDriver();
	        this.resolveFinishedPromise();
	        this.updateFinishedPromise();
	        this.startTime = this.cancelTime = null;
	        this.resolver.cancel();
	    }
	    stopDriver() {
	        if (!this.driver)
	            return;
	        this.driver.stop();
	        this.driver = undefined;
	    }
	    sample(time) {
	        this.startTime = 0;
	        return this.tick(time, true);
	    }
	}

	/**
	 * A list of values that can be hardware-accelerated.
	 */
	const acceleratedValues = new Set([
	    "opacity",
	    "clipPath",
	    "filter",
	    "transform",
	    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
	    // or until we implement support for linear() easing.
	    // "background-color"
	]);

	function memo(callback) {
	    let result;
	    return () => {
	        if (result === undefined)
	            result = callback();
	        return result;
	    };
	}

	/**
	 * Add the ability for test suites to manually set support flags
	 * to better test more environments.
	 */
	const supportsFlags = {
	    linearEasing: undefined,
	};

	function memoSupports(callback, supportsFlag) {
	    const memoized = memo(callback);
	    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };
	}

	const supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {
	    try {
	        document
	            .createElement("div")
	            .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
	    }
	    catch (e) {
	        return false;
	    }
	    return true;
	}, "linearEasing");

	function isWaapiSupportedEasing(easing) {
	    return Boolean((typeof easing === "function" && supportsLinearEasing()) ||
	        !easing ||
	        (typeof easing === "string" &&
	            (easing in supportedWaapiEasing || supportsLinearEasing())) ||
	        isBezierDefinition(easing) ||
	        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));
	}
	const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
	const supportedWaapiEasing = {
	    linear: "linear",
	    ease: "ease",
	    easeIn: "ease-in",
	    easeOut: "ease-out",
	    easeInOut: "ease-in-out",
	    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),
	    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),
	    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
	    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
	};
	function mapEasingToNativeEasing(easing, duration) {
	    if (!easing) {
	        return undefined;
	    }
	    else if (typeof easing === "function" && supportsLinearEasing()) {
	        return generateLinearEasing(easing, duration);
	    }
	    else if (isBezierDefinition(easing)) {
	        return cubicBezierAsString(easing);
	    }
	    else if (Array.isArray(easing)) {
	        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||
	            supportedWaapiEasing.easeOut);
	    }
	    else {
	        return supportedWaapiEasing[easing];
	    }
	}

	function startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {
	    const keyframeOptions = { [valueName]: keyframes };
	    if (times)
	        keyframeOptions.offset = times;
	    const easing = mapEasingToNativeEasing(ease, duration);
	    /**
	     * If this is an easing array, apply to keyframes, not animation as a whole
	     */
	    if (Array.isArray(easing))
	        keyframeOptions.easing = easing;
	    return element.animate(keyframeOptions, {
	        delay,
	        duration,
	        easing: !Array.isArray(easing) ? easing : "linear",
	        fill: "both",
	        iterations: repeat + 1,
	        direction: repeatType === "reverse" ? "alternate" : "normal",
	    });
	}

	function attachTimeline(animation, timeline) {
	    animation.timeline = timeline;
	    animation.onfinish = null;
	}

	const supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

	/**
	 * 10ms is chosen here as it strikes a balance between smooth
	 * results (more than one keyframe per frame at 60fps) and
	 * keyframe quantity.
	 */
	const sampleDelta = 10; //ms
	/**
	 * Implement a practical max duration for keyframe generation
	 * to prevent infinite loops
	 */
	const maxDuration = 20000;
	/**
	 * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.
	 * WAAPI doesn't support spring or function easings so we run these as JS animation before
	 * handing off.
	 */
	function requiresPregeneratedKeyframes(options) {
	    return (isGenerator(options.type) ||
	        options.type === "spring" ||
	        !isWaapiSupportedEasing(options.ease));
	}
	function pregenerateKeyframes(keyframes, options) {
	    /**
	     * Create a main-thread animation to pregenerate keyframes.
	     * We sample this at regular intervals to generate keyframes that we then
	     * linearly interpolate between.
	     */
	    const sampleAnimation = new MainThreadAnimation({
	        ...options,
	        keyframes,
	        repeat: 0,
	        delay: 0,
	        isGenerator: true,
	    });
	    let state = { done: false, value: keyframes[0] };
	    const pregeneratedKeyframes = [];
	    /**
	     * Bail after 20 seconds of pre-generated keyframes as it's likely
	     * we're heading for an infinite loop.
	     */
	    let t = 0;
	    while (!state.done && t < maxDuration) {
	        state = sampleAnimation.sample(t);
	        pregeneratedKeyframes.push(state.value);
	        t += sampleDelta;
	    }
	    return {
	        times: undefined,
	        keyframes: pregeneratedKeyframes,
	        duration: t - sampleDelta,
	        ease: "linear",
	    };
	}
	const unsupportedEasingFunctions = {
	    anticipate,
	    backInOut,
	    circInOut,
	};
	function isUnsupportedEase(key) {
	    return key in unsupportedEasingFunctions;
	}
	class AcceleratedAnimation extends BaseAnimation {
	    constructor(options) {
	        super(options);
	        const { name, motionValue, element, keyframes } = this.options;
	        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);
	        this.resolver.scheduleResolve();
	    }
	    initPlayback(keyframes, finalKeyframe) {
	        var _a;
	        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;
	        /**
	         * If element has since been unmounted, return false to indicate
	         * the animation failed to initialised.
	         */
	        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {
	            return false;
	        }
	        /**
	         * If the user has provided an easing function name that isn't supported
	         * by WAAPI (like "anticipate"), we need to provide the corressponding
	         * function. This will later get converted to a linear() easing function.
	         */
	        if (typeof ease === "string" &&
	            supportsLinearEasing() &&
	            isUnsupportedEase(ease)) {
	            ease = unsupportedEasingFunctions[ease];
	        }
	        /**
	         * If this animation needs pre-generated keyframes then generate.
	         */
	        if (requiresPregeneratedKeyframes(this.options)) {
	            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;
	            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);
	            keyframes = pregeneratedAnimation.keyframes;
	            // If this is a very short animation, ensure we have
	            // at least two keyframes to animate between as older browsers
	            // can't animate between a single keyframe.
	            if (keyframes.length === 1) {
	                keyframes[1] = keyframes[0];
	            }
	            duration = pregeneratedAnimation.duration;
	            times = pregeneratedAnimation.times;
	            ease = pregeneratedAnimation.ease;
	            type = "keyframes";
	        }
	        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });
	        // Override the browser calculated startTime with one synchronised to other JS
	        // and WAAPI animations starting this event loop.
	        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
	        if (this.pendingTimeline) {
	            attachTimeline(animation, this.pendingTimeline);
	            this.pendingTimeline = undefined;
	        }
	        else {
	            /**
	             * Prefer the `onfinish` prop as it's more widely supported than
	             * the `finished` promise.
	             *
	             * Here, we synchronously set the provided MotionValue to the end
	             * keyframe. If we didn't, when the WAAPI animation is finished it would
	             * be removed from the element which would then revert to its old styles.
	             */
	            animation.onfinish = () => {
	                const { onComplete } = this.options;
	                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));
	                onComplete && onComplete();
	                this.cancel();
	                this.resolveFinishedPromise();
	            };
	        }
	        return {
	            animation,
	            duration,
	            times,
	            type,
	            ease,
	            keyframes: keyframes,
	        };
	    }
	    get duration() {
	        const { resolved } = this;
	        if (!resolved)
	            return 0;
	        const { duration } = resolved;
	        return millisecondsToSeconds(duration);
	    }
	    get time() {
	        const { resolved } = this;
	        if (!resolved)
	            return 0;
	        const { animation } = resolved;
	        return millisecondsToSeconds(animation.currentTime || 0);
	    }
	    set time(newTime) {
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        const { animation } = resolved;
	        animation.currentTime = secondsToMilliseconds(newTime);
	    }
	    get speed() {
	        const { resolved } = this;
	        if (!resolved)
	            return 1;
	        const { animation } = resolved;
	        return animation.playbackRate;
	    }
	    set speed(newSpeed) {
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        const { animation } = resolved;
	        animation.playbackRate = newSpeed;
	    }
	    get state() {
	        const { resolved } = this;
	        if (!resolved)
	            return "idle";
	        const { animation } = resolved;
	        return animation.playState;
	    }
	    get startTime() {
	        const { resolved } = this;
	        if (!resolved)
	            return null;
	        const { animation } = resolved;
	        // Coerce to number as TypeScript incorrectly types this
	        // as CSSNumberish
	        return animation.startTime;
	    }
	    /**
	     * Replace the default DocumentTimeline with another AnimationTimeline.
	     * Currently used for scroll animations.
	     */
	    attachTimeline(timeline) {
	        if (!this._resolved) {
	            this.pendingTimeline = timeline;
	        }
	        else {
	            const { resolved } = this;
	            if (!resolved)
	                return noop;
	            const { animation } = resolved;
	            attachTimeline(animation, timeline);
	        }
	        return noop;
	    }
	    play() {
	        if (this.isStopped)
	            return;
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        const { animation } = resolved;
	        if (animation.playState === "finished") {
	            this.updateFinishedPromise();
	        }
	        animation.play();
	    }
	    pause() {
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        const { animation } = resolved;
	        animation.pause();
	    }
	    stop() {
	        this.resolver.cancel();
	        this.isStopped = true;
	        if (this.state === "idle")
	            return;
	        this.resolveFinishedPromise();
	        this.updateFinishedPromise();
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        const { animation, keyframes, duration, type, ease, times } = resolved;
	        if (animation.playState === "idle" ||
	            animation.playState === "finished") {
	            return;
	        }
	        /**
	         * WAAPI doesn't natively have any interruption capabilities.
	         *
	         * Rather than read commited styles back out of the DOM, we can
	         * create a renderless JS animation and sample it twice to calculate
	         * its current value, "previous" value, and therefore allow
	         * Motion to calculate velocity for any subsequent animation.
	         */
	        if (this.time) {
	            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;
	            const sampleAnimation = new MainThreadAnimation({
	                ...options,
	                keyframes,
	                duration,
	                type,
	                ease,
	                times,
	                isGenerator: true,
	            });
	            const sampleTime = secondsToMilliseconds(this.time);
	            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
	        }
	        const { onStop } = this.options;
	        onStop && onStop();
	        this.cancel();
	    }
	    complete() {
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        resolved.animation.finish();
	    }
	    cancel() {
	        const { resolved } = this;
	        if (!resolved)
	            return;
	        resolved.animation.cancel();
	    }
	    static supports(options) {
	        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;
	        return (supportsWaapi() &&
	            name &&
	            acceleratedValues.has(name) &&
	            motionValue &&
	            motionValue.owner &&
	            motionValue.owner.current instanceof HTMLElement &&
	            /**
	             * If we're outputting values to onUpdate then we can't use WAAPI as there's
	             * no way to read the value from WAAPI every frame.
	             */
	            !motionValue.owner.getProps().onUpdate &&
	            !repeatDelay &&
	            repeatType !== "mirror" &&
	            damping !== 0 &&
	            type !== "inertia");
	    }
	}

	const supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);

	class GroupPlaybackControls {
	    constructor(animations) {
	        // Bound to accomodate common `return animation.stop` pattern
	        this.stop = () => this.runAll("stop");
	        this.animations = animations.filter(Boolean);
	    }
	    then(onResolve, onReject) {
	        return Promise.all(this.animations).then(onResolve).catch(onReject);
	    }
	    /**
	     * TODO: Filter out cancelled or stopped animations before returning
	     */
	    getAll(propName) {
	        return this.animations[0][propName];
	    }
	    setAll(propName, newValue) {
	        for (let i = 0; i < this.animations.length; i++) {
	            this.animations[i][propName] = newValue;
	        }
	    }
	    attachTimeline(timeline, fallback) {
	        const subscriptions = this.animations.map((animation) => {
	            if (supportsScrollTimeline() && animation.attachTimeline) {
	                return animation.attachTimeline(timeline);
	            }
	            else {
	                return fallback(animation);
	            }
	        });
	        return () => {
	            subscriptions.forEach((cancel, i) => {
	                cancel && cancel();
	                this.animations[i].stop();
	            });
	        };
	    }
	    get time() {
	        return this.getAll("time");
	    }
	    set time(time) {
	        this.setAll("time", time);
	    }
	    get speed() {
	        return this.getAll("speed");
	    }
	    set speed(speed) {
	        this.setAll("speed", speed);
	    }
	    get startTime() {
	        return this.getAll("startTime");
	    }
	    get duration() {
	        let max = 0;
	        for (let i = 0; i < this.animations.length; i++) {
	            max = Math.max(max, this.animations[i].duration);
	        }
	        return max;
	    }
	    runAll(methodName) {
	        this.animations.forEach((controls) => controls[methodName]());
	    }
	    flatten() {
	        this.runAll("flatten");
	    }
	    play() {
	        this.runAll("play");
	    }
	    pause() {
	        this.runAll("pause");
	    }
	    cancel() {
	        this.runAll("cancel");
	    }
	    complete() {
	        this.runAll("complete");
	    }
	}

	/**
	 * Decide whether a transition is defined on a given Transition.
	 * This filters out orchestration options and returns true
	 * if any options are left.
	 */
	function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
	    return !!Object.keys(transition).length;
	}

	const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
	    const valueTransition = getValueTransition(transition, name) || {};
	    /**
	     * Most transition values are currently completely overwritten by value-specific
	     * transitions. In the future it'd be nicer to blend these transitions. But for now
	     * delay actually does inherit from the root transition if not value-specific.
	     */
	    const delay = valueTransition.delay || transition.delay || 0;
	    /**
	     * Elapsed isn't a public transition option but can be passed through from
	     * optimized appear effects in milliseconds.
	     */
	    let { elapsed = 0 } = transition;
	    elapsed = elapsed - secondsToMilliseconds(delay);
	    let options = {
	        keyframes: Array.isArray(target) ? target : [null, target],
	        ease: "easeOut",
	        velocity: value.getVelocity(),
	        ...valueTransition,
	        delay: -elapsed,
	        onUpdate: (v) => {
	            value.set(v);
	            valueTransition.onUpdate && valueTransition.onUpdate(v);
	        },
	        onComplete: () => {
	            onComplete();
	            valueTransition.onComplete && valueTransition.onComplete();
	        },
	        name,
	        motionValue: value,
	        element: isHandoff ? undefined : element,
	    };
	    /**
	     * If there's no transition defined for this value, we can generate
	     * unqiue transition settings for this value.
	     */
	    if (!isTransitionDefined(valueTransition)) {
	        options = {
	            ...options,
	            ...getDefaultTransition(name, options),
	        };
	    }
	    /**
	     * Both WAAPI and our internal animation functions use durations
	     * as defined by milliseconds, while our external API defines them
	     * as seconds.
	     */
	    if (options.duration) {
	        options.duration = secondsToMilliseconds(options.duration);
	    }
	    if (options.repeatDelay) {
	        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
	    }
	    if (options.from !== undefined) {
	        options.keyframes[0] = options.from;
	    }
	    let shouldSkip = false;
	    if (options.type === false ||
	        (options.duration === 0 && !options.repeatDelay)) {
	        options.duration = 0;
	        if (options.delay === 0) {
	            shouldSkip = true;
	        }
	    }
	    if (instantAnimationState.current ||
	        MotionGlobalConfig.skipAnimations) {
	        shouldSkip = true;
	        options.duration = 0;
	        options.delay = 0;
	    }
	    /**
	     * If we can or must skip creating the animation, and apply only
	     * the final keyframe, do so. We also check once keyframes are resolved but
	     * this early check prevents the need to create an animation at all.
	     */
	    if (shouldSkip && !isHandoff && value.get() !== undefined) {
	        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
	        if (finalKeyframe !== undefined) {
	            frame.update(() => {
	                options.onUpdate(finalKeyframe);
	                options.onComplete();
	            });
	            // We still want to return some animation controls here rather
	            // than returning undefined
	            return new GroupPlaybackControls([]);
	        }
	    }
	    /**
	     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via
	     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
	     * optimised animation.
	     */
	    if (!isHandoff && AcceleratedAnimation.supports(options)) {
	        return new AcceleratedAnimation(options);
	    }
	    else {
	        return new MainThreadAnimation(options);
	    }
	};

	const isCustomValue = (v) => {
	    return Boolean(v && typeof v === "object" && v.mix && v.toValue);
	};
	const resolveFinalValueInKeyframes = (v) => {
	    // TODO maybe throw if v.length - 1 is placeholder token?
	    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
	};

	function addUniqueItem(arr, item) {
	    if (arr.indexOf(item) === -1)
	        arr.push(item);
	}
	function removeItem(arr, item) {
	    const index = arr.indexOf(item);
	    if (index > -1)
	        arr.splice(index, 1);
	}

	class SubscriptionManager {
	    constructor() {
	        this.subscriptions = [];
	    }
	    add(handler) {
	        addUniqueItem(this.subscriptions, handler);
	        return () => removeItem(this.subscriptions, handler);
	    }
	    notify(a, b, c) {
	        const numSubscriptions = this.subscriptions.length;
	        if (!numSubscriptions)
	            return;
	        if (numSubscriptions === 1) {
	            /**
	             * If there's only a single handler we can just call it without invoking a loop.
	             */
	            this.subscriptions[0](a, b, c);
	        }
	        else {
	            for (let i = 0; i < numSubscriptions; i++) {
	                /**
	                 * Check whether the handler exists before firing as it's possible
	                 * the subscriptions were modified during this loop running.
	                 */
	                const handler = this.subscriptions[i];
	                handler && handler(a, b, c);
	            }
	        }
	    }
	    getSize() {
	        return this.subscriptions.length;
	    }
	    clear() {
	        this.subscriptions.length = 0;
	    }
	}

	/**
	 * Maximum time between the value of two frames, beyond which we
	 * assume the velocity has since been 0.
	 */
	const MAX_VELOCITY_DELTA = 30;
	const isFloat = (value) => {
	    return !isNaN(parseFloat(value));
	};
	/**
	 * `MotionValue` is used to track the state and velocity of motion values.
	 *
	 * @public
	 */
	class MotionValue {
	    /**
	     * @param init - The initiating value
	     * @param config - Optional configuration options
	     *
	     * -  `transformer`: A function to transform incoming values with.
	     *
	     * @internal
	     */
	    constructor(init, options = {}) {
	        /**
	         * This will be replaced by the build step with the latest version number.
	         * When MotionValues are provided to motion components, warn if versions are mixed.
	         */
	        this.version = "11.15.0";
	        /**
	         * Tracks whether this value can output a velocity. Currently this is only true
	         * if the value is numerical, but we might be able to widen the scope here and support
	         * other value types.
	         *
	         * @internal
	         */
	        this.canTrackVelocity = null;
	        /**
	         * An object containing a SubscriptionManager for each active event.
	         */
	        this.events = {};
	        this.updateAndNotify = (v, render = true) => {
	            const currentTime = time.now();
	            /**
	             * If we're updating the value during another frame or eventloop
	             * than the previous frame, then the we set the previous frame value
	             * to current.
	             */
	            if (this.updatedAt !== currentTime) {
	                this.setPrevFrameValue();
	            }
	            this.prev = this.current;
	            this.setCurrent(v);
	            // Update update subscribers
	            if (this.current !== this.prev && this.events.change) {
	                this.events.change.notify(this.current);
	            }
	            // Update render subscribers
	            if (render && this.events.renderRequest) {
	                this.events.renderRequest.notify(this.current);
	            }
	        };
	        this.hasAnimated = false;
	        this.setCurrent(init);
	        this.owner = options.owner;
	    }
	    setCurrent(current) {
	        this.current = current;
	        this.updatedAt = time.now();
	        if (this.canTrackVelocity === null && current !== undefined) {
	            this.canTrackVelocity = isFloat(this.current);
	        }
	    }
	    setPrevFrameValue(prevFrameValue = this.current) {
	        this.prevFrameValue = prevFrameValue;
	        this.prevUpdatedAt = this.updatedAt;
	    }
	    /**
	     * Adds a function that will be notified when the `MotionValue` is updated.
	     *
	     * It returns a function that, when called, will cancel the subscription.
	     *
	     * When calling `onChange` inside a React component, it should be wrapped with the
	     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
	     * from the `useEffect` function to ensure you don't add duplicate subscribers..
	     *
	     * ```jsx
	     * export const MyComponent = () => {
	     *   const x = useMotionValue(0)
	     *   const y = useMotionValue(0)
	     *   const opacity = useMotionValue(1)
	     *
	     *   useEffect(() => {
	     *     function updateOpacity() {
	     *       const maxXY = Math.max(x.get(), y.get())
	     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
	     *       opacity.set(newOpacity)
	     *     }
	     *
	     *     const unsubscribeX = x.on("change", updateOpacity)
	     *     const unsubscribeY = y.on("change", updateOpacity)
	     *
	     *     return () => {
	     *       unsubscribeX()
	     *       unsubscribeY()
	     *     }
	     *   }, [])
	     *
	     *   return <motion.div style={{ x }} />
	     * }
	     * ```
	     *
	     * @param subscriber - A function that receives the latest value.
	     * @returns A function that, when called, will cancel this subscription.
	     *
	     * @deprecated
	     */
	    onChange(subscription) {
	        if (process.env.NODE_ENV !== "production") {
	            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
	        }
	        return this.on("change", subscription);
	    }
	    on(eventName, callback) {
	        if (!this.events[eventName]) {
	            this.events[eventName] = new SubscriptionManager();
	        }
	        const unsubscribe = this.events[eventName].add(callback);
	        if (eventName === "change") {
	            return () => {
	                unsubscribe();
	                /**
	                 * If we have no more change listeners by the start
	                 * of the next frame, stop active animations.
	                 */
	                frame.read(() => {
	                    if (!this.events.change.getSize()) {
	                        this.stop();
	                    }
	                });
	            };
	        }
	        return unsubscribe;
	    }
	    clearListeners() {
	        for (const eventManagers in this.events) {
	            this.events[eventManagers].clear();
	        }
	    }
	    /**
	     * Attaches a passive effect to the `MotionValue`.
	     *
	     * @internal
	     */
	    attach(passiveEffect, stopPassiveEffect) {
	        this.passiveEffect = passiveEffect;
	        this.stopPassiveEffect = stopPassiveEffect;
	    }
	    /**
	     * Sets the state of the `MotionValue`.
	     *
	     * @remarks
	     *
	     * ```jsx
	     * const x = useMotionValue(0)
	     * x.set(10)
	     * ```
	     *
	     * @param latest - Latest value to set.
	     * @param render - Whether to notify render subscribers. Defaults to `true`
	     *
	     * @public
	     */
	    set(v, render = true) {
	        if (!render || !this.passiveEffect) {
	            this.updateAndNotify(v, render);
	        }
	        else {
	            this.passiveEffect(v, this.updateAndNotify);
	        }
	    }
	    setWithVelocity(prev, current, delta) {
	        this.set(current);
	        this.prev = undefined;
	        this.prevFrameValue = prev;
	        this.prevUpdatedAt = this.updatedAt - delta;
	    }
	    /**
	     * Set the state of the `MotionValue`, stopping any active animations,
	     * effects, and resets velocity to `0`.
	     */
	    jump(v, endAnimation = true) {
	        this.updateAndNotify(v);
	        this.prev = v;
	        this.prevUpdatedAt = this.prevFrameValue = undefined;
	        endAnimation && this.stop();
	        if (this.stopPassiveEffect)
	            this.stopPassiveEffect();
	    }
	    /**
	     * Returns the latest state of `MotionValue`
	     *
	     * @returns - The latest state of `MotionValue`
	     *
	     * @public
	     */
	    get() {
	        return this.current;
	    }
	    /**
	     * @public
	     */
	    getPrevious() {
	        return this.prev;
	    }
	    /**
	     * Returns the latest velocity of `MotionValue`
	     *
	     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
	     *
	     * @public
	     */
	    getVelocity() {
	        const currentTime = time.now();
	        if (!this.canTrackVelocity ||
	            this.prevFrameValue === undefined ||
	            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
	            return 0;
	        }
	        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
	        // Casts because of parseFloat's poor typing
	        return velocityPerSecond(parseFloat(this.current) -
	            parseFloat(this.prevFrameValue), delta);
	    }
	    /**
	     * Registers a new animation to control this `MotionValue`. Only one
	     * animation can drive a `MotionValue` at one time.
	     *
	     * ```jsx
	     * value.start()
	     * ```
	     *
	     * @param animation - A function that starts the provided animation
	     *
	     * @internal
	     */
	    start(startAnimation) {
	        this.stop();
	        return new Promise((resolve) => {
	            this.hasAnimated = true;
	            this.animation = startAnimation(resolve);
	            if (this.events.animationStart) {
	                this.events.animationStart.notify();
	            }
	        }).then(() => {
	            if (this.events.animationComplete) {
	                this.events.animationComplete.notify();
	            }
	            this.clearAnimation();
	        });
	    }
	    /**
	     * Stop the currently active animation.
	     *
	     * @public
	     */
	    stop() {
	        if (this.animation) {
	            this.animation.stop();
	            if (this.events.animationCancel) {
	                this.events.animationCancel.notify();
	            }
	        }
	        this.clearAnimation();
	    }
	    /**
	     * Returns `true` if this value is currently animating.
	     *
	     * @public
	     */
	    isAnimating() {
	        return !!this.animation;
	    }
	    clearAnimation() {
	        delete this.animation;
	    }
	    /**
	     * Destroy and clean up subscribers to this `MotionValue`.
	     *
	     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
	     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
	     * created a `MotionValue` via the `motionValue` function.
	     *
	     * @public
	     */
	    destroy() {
	        this.clearListeners();
	        this.stop();
	        if (this.stopPassiveEffect) {
	            this.stopPassiveEffect();
	        }
	    }
	}
	function motionValue(init, options) {
	    return new MotionValue(init, options);
	}

	/**
	 * Set VisualElement's MotionValue, creating a new MotionValue for it if
	 * it doesn't exist.
	 */
	function setMotionValue(visualElement, key, value) {
	    if (visualElement.hasValue(key)) {
	        visualElement.getValue(key).set(value);
	    }
	    else {
	        visualElement.addValue(key, motionValue(value));
	    }
	}
	function setTarget(visualElement, definition) {
	    const resolved = resolveVariant(visualElement, definition);
	    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
	    target = { ...target, ...transitionEnd };
	    for (const key in target) {
	        const value = resolveFinalValueInKeyframes(target[key]);
	        setMotionValue(visualElement, key, value);
	    }
	}

	/**
	 * Convert camelCase to dash-case properties.
	 */
	const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

	const optimizedAppearDataId = "framerAppearId";
	const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

	function getOptimisedAppearId(visualElement) {
	    return visualElement.props[optimizedAppearDataAttribute];
	}

	const isMotionValue = (value) => Boolean(value && value.getVelocity);

	function isWillChangeMotionValue(value) {
	    return Boolean(isMotionValue(value) && value.add);
	}

	function addValueToWillChange(visualElement, key) {
	    const willChange = visualElement.getValue("willChange");
	    /**
	     * It could be that a user has set willChange to a regular MotionValue,
	     * in which case we can't add the value to it.
	     */
	    if (isWillChangeMotionValue(willChange)) {
	        return willChange.add(key);
	    }
	}

	/**
	 * Decide whether we should block this animation. Previously, we achieved this
	 * just by checking whether the key was listed in protectedKeys, but this
	 * posed problems if an animation was triggered by afterChildren and protectedKeys
	 * had been set to true in the meantime.
	 */
	function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
	    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
	    needsAnimating[key] = false;
	    return shouldBlock;
	}
	function animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {
	    var _a;
	    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
	    if (transitionOverride)
	        transition = transitionOverride;
	    const animations = [];
	    const animationTypeState = type &&
	        visualElement.animationState &&
	        visualElement.animationState.getState()[type];
	    for (const key in target) {
	        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
	        const valueTarget = target[key];
	        if (valueTarget === undefined ||
	            (animationTypeState &&
	                shouldBlockAnimation(animationTypeState, key))) {
	            continue;
	        }
	        const valueTransition = {
	            delay,
	            ...getValueTransition(transition || {}, key),
	        };
	        /**
	         * If this is the first time a value is being animated, check
	         * to see if we're handling off from an existing animation.
	         */
	        let isHandoff = false;
	        if (window.MotionHandoffAnimation) {
	            const appearId = getOptimisedAppearId(visualElement);
	            if (appearId) {
	                const startTime = window.MotionHandoffAnimation(appearId, key, frame);
	                if (startTime !== null) {
	                    valueTransition.startTime = startTime;
	                    isHandoff = true;
	                }
	            }
	        }
	        addValueToWillChange(visualElement, key);
	        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)
	            ? { type: false }
	            : valueTransition, visualElement, isHandoff));
	        const animation = value.animation;
	        if (animation) {
	            animations.push(animation);
	        }
	    }
	    if (transitionEnd) {
	        Promise.all(animations).then(() => {
	            frame.update(() => {
	                transitionEnd && setTarget(visualElement, transitionEnd);
	            });
	        });
	    }
	    return animations;
	}

	function animateVariant(visualElement, variant, options = {}) {
	    var _a;
	    const resolved = resolveVariant(visualElement, variant, options.type === "exit"
	        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom
	        : undefined);
	    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
	    if (options.transitionOverride) {
	        transition = options.transitionOverride;
	    }
	    /**
	     * If we have a variant, create a callback that runs it as an animation.
	     * Otherwise, we resolve a Promise immediately for a composable no-op.
	     */
	    const getAnimation = resolved
	        ? () => Promise.all(animateTarget(visualElement, resolved, options))
	        : () => Promise.resolve();
	    /**
	     * If we have children, create a callback that runs all their animations.
	     * Otherwise, we resolve a Promise immediately for a composable no-op.
	     */
	    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size
	        ? (forwardDelay = 0) => {
	            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;
	            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
	        }
	        : () => Promise.resolve();
	    /**
	     * If the transition explicitly defines a "when" option, we need to resolve either
	     * this animation or all children animations before playing the other.
	     */
	    const { when } = transition;
	    if (when) {
	        const [first, last] = when === "beforeChildren"
	            ? [getAnimation, getChildAnimations]
	            : [getChildAnimations, getAnimation];
	        return first().then(() => last());
	    }
	    else {
	        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
	    }
	}
	function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
	    const animations = [];
	    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
	    const generateStaggerDuration = staggerDirection === 1
	        ? (i = 0) => i * staggerChildren
	        : (i = 0) => maxStaggerDuration - i * staggerChildren;
	    Array.from(visualElement.variantChildren)
	        .sort(sortByTreeOrder)
	        .forEach((child, i) => {
	        child.notify("AnimationStart", variant);
	        animations.push(animateVariant(child, variant, {
	            ...options,
	            delay: delayChildren + generateStaggerDuration(i),
	        }).then(() => child.notify("AnimationComplete", variant)));
	    });
	    return Promise.all(animations);
	}
	function sortByTreeOrder(a, b) {
	    return a.sortNodePosition(b);
	}

	function animateVisualElement(visualElement, definition, options = {}) {
	    visualElement.notify("AnimationStart", definition);
	    let animation;
	    if (Array.isArray(definition)) {
	        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));
	        animation = Promise.all(animations);
	    }
	    else if (typeof definition === "string") {
	        animation = animateVariant(visualElement, definition, options);
	    }
	    else {
	        const resolvedDefinition = typeof definition === "function"
	            ? resolveVariant(visualElement, definition, options.custom)
	            : definition;
	        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
	    }
	    return animation.then(() => {
	        visualElement.notify("AnimationComplete", definition);
	    });
	}

	const numVariantProps = variantProps.length;
	function getVariantContext(visualElement) {
	    if (!visualElement)
	        return undefined;
	    if (!visualElement.isControllingVariants) {
	        const context = visualElement.parent
	            ? getVariantContext(visualElement.parent) || {}
	            : {};
	        if (visualElement.props.initial !== undefined) {
	            context.initial = visualElement.props.initial;
	        }
	        return context;
	    }
	    const context = {};
	    for (let i = 0; i < numVariantProps; i++) {
	        const name = variantProps[i];
	        const prop = visualElement.props[name];
	        if (isVariantLabel(prop) || prop === false) {
	            context[name] = prop;
	        }
	    }
	    return context;
	}

	const reversePriorityOrder = [...variantPriorityOrder].reverse();
	const numAnimationTypes = variantPriorityOrder.length;
	function animateList(visualElement) {
	    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
	}
	function createAnimationState(visualElement) {
	    let animate = animateList(visualElement);
	    let state = createState();
	    let isInitialRender = true;
	    /**
	     * This function will be used to reduce the animation definitions for
	     * each active animation type into an object of resolved values for it.
	     */
	    const buildResolvedTypeValues = (type) => (acc, definition) => {
	        var _a;
	        const resolved = resolveVariant(visualElement, definition, type === "exit"
	            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom
	            : undefined);
	        if (resolved) {
	            const { transition, transitionEnd, ...target } = resolved;
	            acc = { ...acc, ...target, ...transitionEnd };
	        }
	        return acc;
	    };
	    /**
	     * This just allows us to inject mocked animation functions
	     * @internal
	     */
	    function setAnimateFunction(makeAnimator) {
	        animate = makeAnimator(visualElement);
	    }
	    /**
	     * When we receive new props, we need to:
	     * 1. Create a list of protected keys for each type. This is a directory of
	     *    value keys that are currently being "handled" by types of a higher priority
	     *    so that whenever an animation is played of a given type, these values are
	     *    protected from being animated.
	     * 2. Determine if an animation type needs animating.
	     * 3. Determine if any values have been removed from a type and figure out
	     *    what to animate those to.
	     */
	    function animateChanges(changedActiveType) {
	        const { props } = visualElement;
	        const context = getVariantContext(visualElement.parent) || {};
	        /**
	         * A list of animations that we'll build into as we iterate through the animation
	         * types. This will get executed at the end of the function.
	         */
	        const animations = [];
	        /**
	         * Keep track of which values have been removed. Then, as we hit lower priority
	         * animation types, we can check if they contain removed values and animate to that.
	         */
	        const removedKeys = new Set();
	        /**
	         * A dictionary of all encountered keys. This is an object to let us build into and
	         * copy it without iteration. Each time we hit an animation type we set its protected
	         * keys - the keys its not allowed to animate - to the latest version of this object.
	         */
	        let encounteredKeys = {};
	        /**
	         * If a variant has been removed at a given index, and this component is controlling
	         * variant animations, we want to ensure lower-priority variants are forced to animate.
	         */
	        let removedVariantIndex = Infinity;
	        /**
	         * Iterate through all animation types in reverse priority order. For each, we want to
	         * detect which values it's handling and whether or not they've changed (and therefore
	         * need to be animated). If any values have been removed, we want to detect those in
	         * lower priority props and flag for animation.
	         */
	        for (let i = 0; i < numAnimationTypes; i++) {
	            const type = reversePriorityOrder[i];
	            const typeState = state[type];
	            const prop = props[type] !== undefined
	                ? props[type]
	                : context[type];
	            const propIsVariant = isVariantLabel(prop);
	            /**
	             * If this type has *just* changed isActive status, set activeDelta
	             * to that status. Otherwise set to null.
	             */
	            const activeDelta = type === changedActiveType ? typeState.isActive : null;
	            if (activeDelta === false)
	                removedVariantIndex = i;
	            /**
	             * If this prop is an inherited variant, rather than been set directly on the
	             * component itself, we want to make sure we allow the parent to trigger animations.
	             *
	             * TODO: Can probably change this to a !isControllingVariants check
	             */
	            let isInherited = prop === context[type] &&
	                prop !== props[type] &&
	                propIsVariant;
	            /**
	             *
	             */
	            if (isInherited &&
	                isInitialRender &&
	                visualElement.manuallyAnimateOnMount) {
	                isInherited = false;
	            }
	            /**
	             * Set all encountered keys so far as the protected keys for this type. This will
	             * be any key that has been animated or otherwise handled by active, higher-priortiy types.
	             */
	            typeState.protectedKeys = { ...encounteredKeys };
	            // Check if we can skip analysing this prop early
	            if (
	            // If it isn't active and hasn't *just* been set as inactive
	            (!typeState.isActive && activeDelta === null) ||
	                // If we didn't and don't have any defined prop for this animation type
	                (!prop && !typeState.prevProp) ||
	                // Or if the prop doesn't define an animation
	                isAnimationControls(prop) ||
	                typeof prop === "boolean") {
	                continue;
	            }
	            /**
	             * As we go look through the values defined on this type, if we detect
	             * a changed value or a value that was removed in a higher priority, we set
	             * this to true and add this prop to the animation list.
	             */
	            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
	            let shouldAnimateType = variantDidChange ||
	                // If we're making this variant active, we want to always make it active
	                (type === changedActiveType &&
	                    typeState.isActive &&
	                    !isInherited &&
	                    propIsVariant) ||
	                // If we removed a higher-priority variant (i is in reverse order)
	                (i > removedVariantIndex && propIsVariant);
	            let handledRemovedValues = false;
	            /**
	             * As animations can be set as variant lists, variants or target objects, we
	             * coerce everything to an array if it isn't one already
	             */
	            const definitionList = Array.isArray(prop) ? prop : [prop];
	            /**
	             * Build an object of all the resolved values. We'll use this in the subsequent
	             * animateChanges calls to determine whether a value has changed.
	             */
	            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
	            if (activeDelta === false)
	                resolvedValues = {};
	            /**
	             * Now we need to loop through all the keys in the prev prop and this prop,
	             * and decide:
	             * 1. If the value has changed, and needs animating
	             * 2. If it has been removed, and needs adding to the removedKeys set
	             * 3. If it has been removed in a higher priority type and needs animating
	             * 4. If it hasn't been removed in a higher priority but hasn't changed, and
	             *    needs adding to the type's protectedKeys list.
	             */
	            const { prevResolvedValues = {} } = typeState;
	            const allKeys = {
	                ...prevResolvedValues,
	                ...resolvedValues,
	            };
	            const markToAnimate = (key) => {
	                shouldAnimateType = true;
	                if (removedKeys.has(key)) {
	                    handledRemovedValues = true;
	                    removedKeys.delete(key);
	                }
	                typeState.needsAnimating[key] = true;
	                const motionValue = visualElement.getValue(key);
	                if (motionValue)
	                    motionValue.liveStyle = false;
	            };
	            for (const key in allKeys) {
	                const next = resolvedValues[key];
	                const prev = prevResolvedValues[key];
	                // If we've already handled this we can just skip ahead
	                if (encounteredKeys.hasOwnProperty(key))
	                    continue;
	                /**
	                 * If the value has changed, we probably want to animate it.
	                 */
	                let valueHasChanged = false;
	                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
	                    valueHasChanged = !shallowCompare(next, prev);
	                }
	                else {
	                    valueHasChanged = next !== prev;
	                }
	                if (valueHasChanged) {
	                    if (next !== undefined && next !== null) {
	                        // If next is defined and doesn't equal prev, it needs animating
	                        markToAnimate(key);
	                    }
	                    else {
	                        // If it's undefined, it's been removed.
	                        removedKeys.add(key);
	                    }
	                }
	                else if (next !== undefined && removedKeys.has(key)) {
	                    /**
	                     * If next hasn't changed and it isn't undefined, we want to check if it's
	                     * been removed by a higher priority
	                     */
	                    markToAnimate(key);
	                }
	                else {
	                    /**
	                     * If it hasn't changed, we add it to the list of protected values
	                     * to ensure it doesn't get animated.
	                     */
	                    typeState.protectedKeys[key] = true;
	                }
	            }
	            /**
	             * Update the typeState so next time animateChanges is called we can compare the
	             * latest prop and resolvedValues to these.
	             */
	            typeState.prevProp = prop;
	            typeState.prevResolvedValues = resolvedValues;
	            /**
	             *
	             */
	            if (typeState.isActive) {
	                encounteredKeys = { ...encounteredKeys, ...resolvedValues };
	            }
	            if (isInitialRender && visualElement.blockInitialAnimation) {
	                shouldAnimateType = false;
	            }
	            /**
	             * If this is an inherited prop we want to skip this animation
	             * unless the inherited variants haven't changed on this render.
	             */
	            const willAnimateViaParent = isInherited && variantDidChange;
	            const needsAnimating = !willAnimateViaParent || handledRemovedValues;
	            if (shouldAnimateType && needsAnimating) {
	                animations.push(...definitionList.map((animation) => ({
	                    animation: animation,
	                    options: { type },
	                })));
	            }
	        }
	        /**
	         * If there are some removed value that haven't been dealt with,
	         * we need to create a new animation that falls back either to the value
	         * defined in the style prop, or the last read value.
	         */
	        if (removedKeys.size) {
	            const fallbackAnimation = {};
	            removedKeys.forEach((key) => {
	                const fallbackTarget = visualElement.getBaseTarget(key);
	                const motionValue = visualElement.getValue(key);
	                if (motionValue)
	                    motionValue.liveStyle = true;
	                // @ts-expect-error - @mattgperry to figure if we should do something here
	                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
	            });
	            animations.push({ animation: fallbackAnimation });
	        }
	        let shouldAnimate = Boolean(animations.length);
	        if (isInitialRender &&
	            (props.initial === false || props.initial === props.animate) &&
	            !visualElement.manuallyAnimateOnMount) {
	            shouldAnimate = false;
	        }
	        isInitialRender = false;
	        return shouldAnimate ? animate(animations) : Promise.resolve();
	    }
	    /**
	     * Change whether a certain animation type is active.
	     */
	    function setActive(type, isActive) {
	        var _a;
	        // If the active state hasn't changed, we can safely do nothing here
	        if (state[type].isActive === isActive)
	            return Promise.resolve();
	        // Propagate active change to children
	        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });
	        state[type].isActive = isActive;
	        const animations = animateChanges(type);
	        for (const key in state) {
	            state[key].protectedKeys = {};
	        }
	        return animations;
	    }
	    return {
	        animateChanges,
	        setActive,
	        setAnimateFunction,
	        getState: () => state,
	        reset: () => {
	            state = createState();
	            isInitialRender = true;
	        },
	    };
	}
	function checkVariantsDidChange(prev, next) {
	    if (typeof next === "string") {
	        return next !== prev;
	    }
	    else if (Array.isArray(next)) {
	        return !shallowCompare(next, prev);
	    }
	    return false;
	}
	function createTypeState(isActive = false) {
	    return {
	        isActive,
	        protectedKeys: {},
	        needsAnimating: {},
	        prevResolvedValues: {},
	    };
	}
	function createState() {
	    return {
	        animate: createTypeState(true),
	        whileInView: createTypeState(),
	        whileHover: createTypeState(),
	        whileTap: createTypeState(),
	        whileDrag: createTypeState(),
	        whileFocus: createTypeState(),
	        exit: createTypeState(),
	    };
	}

	class Feature {
	    constructor(node) {
	        this.isMounted = false;
	        this.node = node;
	    }
	    update() { }
	}

	class AnimationFeature extends Feature {
	    /**
	     * We dynamically generate the AnimationState manager as it contains a reference
	     * to the underlying animation library. We only want to load that if we load this,
	     * so people can optionally code split it out using the `m` component.
	     */
	    constructor(node) {
	        super(node);
	        node.animationState || (node.animationState = createAnimationState(node));
	    }
	    updateAnimationControlsSubscription() {
	        const { animate } = this.node.getProps();
	        if (isAnimationControls(animate)) {
	            this.unmountControls = animate.subscribe(this.node);
	        }
	    }
	    /**
	     * Subscribe any provided AnimationControls to the component's VisualElement
	     */
	    mount() {
	        this.updateAnimationControlsSubscription();
	    }
	    update() {
	        const { animate } = this.node.getProps();
	        const { animate: prevAnimate } = this.node.prevProps || {};
	        if (animate !== prevAnimate) {
	            this.updateAnimationControlsSubscription();
	        }
	    }
	    unmount() {
	        var _a;
	        this.node.animationState.reset();
	        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
	    }
	}

	let id$1 = 0;
	class ExitAnimationFeature extends Feature {
	    constructor() {
	        super(...arguments);
	        this.id = id$1++;
	    }
	    update() {
	        if (!this.node.presenceContext)
	            return;
	        const { isPresent, onExitComplete } = this.node.presenceContext;
	        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
	        if (!this.node.animationState || isPresent === prevIsPresent) {
	            return;
	        }
	        const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
	        if (onExitComplete && !isPresent) {
	            exitAnimation.then(() => onExitComplete(this.id));
	        }
	    }
	    mount() {
	        const { register } = this.node.presenceContext || {};
	        if (register) {
	            this.unmount = register(this.id);
	        }
	    }
	    unmount() { }
	}

	const animations = {
	    animation: {
	        Feature: AnimationFeature,
	    },
	    exit: {
	        Feature: ExitAnimationFeature,
	    },
	};

	const isDragging = {
	    x: false,
	    y: false,
	};
	function isDragActive() {
	    return isDragging.x || isDragging.y;
	}

	function resolveElements(elementOrSelector, scope, selectorCache) {
	    var _a;
	    if (elementOrSelector instanceof Element) {
	        return [elementOrSelector];
	    }
	    else if (typeof elementOrSelector === "string") {
	        let root = document;
	        if (scope) {
	            // TODO: Refactor to utils package
	            // invariant(
	            //     Boolean(scope.current),
	            //     "Scope provided, but no element detected."
	            // )
	            root = scope.current;
	        }
	        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);
	        return elements ? Array.from(elements) : [];
	    }
	    return Array.from(elementOrSelector);
	}

	function setupGesture(elementOrSelector, options) {
	    const elements = resolveElements(elementOrSelector);
	    const gestureAbortController = new AbortController();
	    const eventOptions = {
	        passive: true,
	        ...options,
	        signal: gestureAbortController.signal,
	    };
	    const cancel = () => gestureAbortController.abort();
	    return [elements, eventOptions, cancel];
	}

	/**
	 * Filter out events that are not pointer events, or are triggering
	 * while a Motion gesture is active.
	 */
	function filterEvents$1(callback) {
	    return (event) => {
	        if (event.pointerType === "touch" || isDragActive())
	            return;
	        callback(event);
	    };
	}
	/**
	 * Create a hover gesture. hover() is different to .addEventListener("pointerenter")
	 * in that it has an easier syntax, filters out polyfilled touch events, interoperates
	 * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.
	 *
	 * @public
	 */
	function hover(elementOrSelector, onHoverStart, options = {}) {
	    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
	    const onPointerEnter = filterEvents$1((enterEvent) => {
	        const { target } = enterEvent;
	        const onHoverEnd = onHoverStart(enterEvent);
	        if (!onHoverEnd || !target)
	            return;
	        const onPointerLeave = filterEvents$1((leaveEvent) => {
	            onHoverEnd(leaveEvent);
	            target.removeEventListener("pointerleave", onPointerLeave);
	        });
	        target.addEventListener("pointerleave", onPointerLeave, eventOptions);
	    });
	    elements.forEach((element) => {
	        element.addEventListener("pointerenter", onPointerEnter, eventOptions);
	    });
	    return cancel;
	}

	const isPrimaryPointer = (event) => {
	    if (event.pointerType === "mouse") {
	        return typeof event.button !== "number" || event.button <= 0;
	    }
	    else {
	        /**
	         * isPrimary is true for all mice buttons, whereas every touch point
	         * is regarded as its own input. So subsequent concurrent touch points
	         * will be false.
	         *
	         * Specifically match against false here as incomplete versions of
	         * PointerEvents in very old browser might have it set as undefined.
	         */
	        return event.isPrimary !== false;
	    }
	};

	const isPressing = new WeakSet();

	/**
	 * Filter out events that are not "Enter" keys.
	 */
	function filterEvents(callback) {
	    return (event) => {
	        if (event.key !== "Enter")
	            return;
	        callback(event);
	    };
	}
	function firePointerEvent(target, type) {
	    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
	}
	const enableKeyboardPress = (focusEvent, eventOptions) => {
	    const element = focusEvent.currentTarget;
	    if (!element)
	        return;
	    const handleKeydown = filterEvents(() => {
	        if (isPressing.has(element))
	            return;
	        firePointerEvent(element, "down");
	        const handleKeyup = filterEvents(() => {
	            firePointerEvent(element, "up");
	        });
	        const handleBlur = () => firePointerEvent(element, "cancel");
	        element.addEventListener("keyup", handleKeyup, eventOptions);
	        element.addEventListener("blur", handleBlur, eventOptions);
	    });
	    element.addEventListener("keydown", handleKeydown, eventOptions);
	    /**
	     * Add an event listener that fires on blur to remove the keydown events.
	     */
	    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
	};

	const focusableElements = new Set([
	    "BUTTON",
	    "INPUT",
	    "SELECT",
	    "TEXTAREA",
	    "A",
	]);
	function isElementKeyboardAccessible(element) {
	    return focusableElements.has(element.tagName) || element.tabIndex !== -1;
	}

	/**
	 * Recursively traverse up the tree to check whether the provided child node
	 * is the parent or a descendant of it.
	 *
	 * @param parent - Element to find
	 * @param child - Element to test against parent
	 */
	const isNodeOrChild = (parent, child) => {
	    if (!child) {
	        return false;
	    }
	    else if (parent === child) {
	        return true;
	    }
	    else {
	        return isNodeOrChild(parent, child.parentElement);
	    }
	};

	/**
	 * Filter out events that are not primary pointer events, or are triggering
	 * while a Motion gesture is active.
	 */
	function isValidPressEvent(event) {
	    return isPrimaryPointer(event) && !isDragActive();
	}
	/**
	 * Create a press gesture.
	 *
	 * Press is different to `"pointerdown"`, `"pointerup"` in that it
	 * automatically filters out secondary pointer events like right
	 * click and multitouch.
	 *
	 * It also adds accessibility support for keyboards, where
	 * an element with a press gesture will receive focus and
	 *  trigger on Enter `"keydown"` and `"keyup"` events.
	 *
	 * This is different to a browser's `"click"` event, which does
	 * respond to keyboards but only for the `"click"` itself, rather
	 * than the press start and end/cancel. The element also needs
	 * to be focusable for this to work, whereas a press gesture will
	 * make an element focusable by default.
	 *
	 * @public
	 */
	function press(elementOrSelector, onPressStart, options = {}) {
	    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);
	    const startPress = (startEvent) => {
	        const element = startEvent.currentTarget;
	        if (!isValidPressEvent(startEvent) || isPressing.has(element))
	            return;
	        isPressing.add(element);
	        const onPressEnd = onPressStart(startEvent);
	        const onPointerEnd = (endEvent, success) => {
	            window.removeEventListener("pointerup", onPointerUp);
	            window.removeEventListener("pointercancel", onPointerCancel);
	            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {
	                return;
	            }
	            isPressing.delete(element);
	            if (onPressEnd) {
	                onPressEnd(endEvent, { success });
	            }
	        };
	        const onPointerUp = (upEvent) => {
	            onPointerEnd(upEvent, options.useGlobalTarget ||
	                isNodeOrChild(element, upEvent.target));
	        };
	        const onPointerCancel = (cancelEvent) => {
	            onPointerEnd(cancelEvent, false);
	        };
	        window.addEventListener("pointerup", onPointerUp, eventOptions);
	        window.addEventListener("pointercancel", onPointerCancel, eventOptions);
	    };
	    elements.forEach((element) => {
	        if (!isElementKeyboardAccessible(element)) {
	            element.tabIndex = 0;
	        }
	        const target = options.useGlobalTarget ? window : element;
	        target.addEventListener("pointerdown", startPress, eventOptions);
	        element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);
	    });
	    return cancelEvents;
	}

	function setDragLock(axis) {
	    if (axis === "x" || axis === "y") {
	        if (isDragging[axis]) {
	            return null;
	        }
	        else {
	            isDragging[axis] = true;
	            return () => {
	                isDragging[axis] = false;
	            };
	        }
	    }
	    else {
	        if (isDragging.x || isDragging.y) {
	            return null;
	        }
	        else {
	            isDragging.x = isDragging.y = true;
	            return () => {
	                isDragging.x = isDragging.y = false;
	            };
	        }
	    }
	}

	function extractEventInfo(event) {
	    return {
	        point: {
	            x: event.pageX,
	            y: event.pageY,
	        },
	    };
	}
	const addPointerInfo = (handler) => {
	    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
	};

	function addDomEvent(target, eventName, handler, options = { passive: true }) {
	    target.addEventListener(eventName, handler, options);
	    return () => target.removeEventListener(eventName, handler);
	}

	function addPointerEvent(target, eventName, handler, options) {
	    return addDomEvent(target, eventName, addPointerInfo(handler), options);
	}

	const distance = (a, b) => Math.abs(a - b);
	function distance2D(a, b) {
	    // Multi-dimensional
	    const xDelta = distance(a.x, b.x);
	    const yDelta = distance(a.y, b.y);
	    return Math.sqrt(xDelta ** 2 + yDelta ** 2);
	}

	/**
	 * @internal
	 */
	class PanSession {
	    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {
	        /**
	         * @internal
	         */
	        this.startEvent = null;
	        /**
	         * @internal
	         */
	        this.lastMoveEvent = null;
	        /**
	         * @internal
	         */
	        this.lastMoveEventInfo = null;
	        /**
	         * @internal
	         */
	        this.handlers = {};
	        /**
	         * @internal
	         */
	        this.contextWindow = window;
	        this.updatePoint = () => {
	            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
	                return;
	            const info = getPanInfo(this.lastMoveEventInfo, this.history);
	            const isPanStarted = this.startEvent !== null;
	            // Only start panning if the offset is larger than 3 pixels. If we make it
	            // any larger than this we'll want to reset the pointer history
	            // on the first update to avoid visual snapping to the cursoe.
	            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;
	            if (!isPanStarted && !isDistancePastThreshold)
	                return;
	            const { point } = info;
	            const { timestamp } = frameData;
	            this.history.push({ ...point, timestamp });
	            const { onStart, onMove } = this.handlers;
	            if (!isPanStarted) {
	                onStart && onStart(this.lastMoveEvent, info);
	                this.startEvent = this.lastMoveEvent;
	            }
	            onMove && onMove(this.lastMoveEvent, info);
	        };
	        this.handlePointerMove = (event, info) => {
	            this.lastMoveEvent = event;
	            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
	            // Throttle mouse move event to once per frame
	            frame.update(this.updatePoint, true);
	        };
	        this.handlePointerUp = (event, info) => {
	            this.end();
	            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
	            if (this.dragSnapToOrigin)
	                resumeAnimation && resumeAnimation();
	            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
	                return;
	            const panInfo = getPanInfo(event.type === "pointercancel"
	                ? this.lastMoveEventInfo
	                : transformPoint(info, this.transformPagePoint), this.history);
	            if (this.startEvent && onEnd) {
	                onEnd(event, panInfo);
	            }
	            onSessionEnd && onSessionEnd(event, panInfo);
	        };
	        // If we have more than one touch, don't start detecting this gesture
	        if (!isPrimaryPointer(event))
	            return;
	        this.dragSnapToOrigin = dragSnapToOrigin;
	        this.handlers = handlers;
	        this.transformPagePoint = transformPagePoint;
	        this.contextWindow = contextWindow || window;
	        const info = extractEventInfo(event);
	        const initialInfo = transformPoint(info, this.transformPagePoint);
	        const { point } = initialInfo;
	        const { timestamp } = frameData;
	        this.history = [{ ...point, timestamp }];
	        const { onSessionStart } = handlers;
	        onSessionStart &&
	            onSessionStart(event, getPanInfo(initialInfo, this.history));
	        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
	    }
	    updateHandlers(handlers) {
	        this.handlers = handlers;
	    }
	    end() {
	        this.removeListeners && this.removeListeners();
	        cancelFrame(this.updatePoint);
	    }
	}
	function transformPoint(info, transformPagePoint) {
	    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
	}
	function subtractPoint(a, b) {
	    return { x: a.x - b.x, y: a.y - b.y };
	}
	function getPanInfo({ point }, history) {
	    return {
	        point,
	        delta: subtractPoint(point, lastDevicePoint(history)),
	        offset: subtractPoint(point, startDevicePoint(history)),
	        velocity: getVelocity(history, 0.1),
	    };
	}
	function startDevicePoint(history) {
	    return history[0];
	}
	function lastDevicePoint(history) {
	    return history[history.length - 1];
	}
	function getVelocity(history, timeDelta) {
	    if (history.length < 2) {
	        return { x: 0, y: 0 };
	    }
	    let i = history.length - 1;
	    let timestampedPoint = null;
	    const lastPoint = lastDevicePoint(history);
	    while (i >= 0) {
	        timestampedPoint = history[i];
	        if (lastPoint.timestamp - timestampedPoint.timestamp >
	            secondsToMilliseconds(timeDelta)) {
	            break;
	        }
	        i--;
	    }
	    if (!timestampedPoint) {
	        return { x: 0, y: 0 };
	    }
	    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
	    if (time === 0) {
	        return { x: 0, y: 0 };
	    }
	    const currentVelocity = {
	        x: (lastPoint.x - timestampedPoint.x) / time,
	        y: (lastPoint.y - timestampedPoint.y) / time,
	    };
	    if (currentVelocity.x === Infinity) {
	        currentVelocity.x = 0;
	    }
	    if (currentVelocity.y === Infinity) {
	        currentVelocity.y = 0;
	    }
	    return currentVelocity;
	}

	function isRefObject(ref) {
	    return (ref &&
	        typeof ref === "object" &&
	        Object.prototype.hasOwnProperty.call(ref, "current"));
	}

	const SCALE_PRECISION = 0.0001;
	const SCALE_MIN = 1 - SCALE_PRECISION;
	const SCALE_MAX = 1 + SCALE_PRECISION;
	const TRANSLATE_PRECISION = 0.01;
	const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
	const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
	function calcLength(axis) {
	    return axis.max - axis.min;
	}
	function isNear(value, target, maxDistance) {
	    return Math.abs(value - target) <= maxDistance;
	}
	function calcAxisDelta(delta, source, target, origin = 0.5) {
	    delta.origin = origin;
	    delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
	    delta.scale = calcLength(target) / calcLength(source);
	    delta.translate =
	        mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
	    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||
	        isNaN(delta.scale)) {
	        delta.scale = 1.0;
	    }
	    if ((delta.translate >= TRANSLATE_MIN &&
	        delta.translate <= TRANSLATE_MAX) ||
	        isNaN(delta.translate)) {
	        delta.translate = 0.0;
	    }
	}
	function calcBoxDelta(delta, source, target, origin) {
	    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);
	    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);
	}
	function calcRelativeAxis(target, relative, parent) {
	    target.min = parent.min + relative.min;
	    target.max = target.min + calcLength(relative);
	}
	function calcRelativeBox(target, relative, parent) {
	    calcRelativeAxis(target.x, relative.x, parent.x);
	    calcRelativeAxis(target.y, relative.y, parent.y);
	}
	function calcRelativeAxisPosition(target, layout, parent) {
	    target.min = layout.min - parent.min;
	    target.max = target.min + calcLength(layout);
	}
	function calcRelativePosition(target, layout, parent) {
	    calcRelativeAxisPosition(target.x, layout.x, parent.x);
	    calcRelativeAxisPosition(target.y, layout.y, parent.y);
	}

	/**
	 * Apply constraints to a point. These constraints are both physical along an
	 * axis, and an elastic factor that determines how much to constrain the point
	 * by if it does lie outside the defined parameters.
	 */
	function applyConstraints(point, { min, max }, elastic) {
	    if (min !== undefined && point < min) {
	        // If we have a min point defined, and this is outside of that, constrain
	        point = elastic
	            ? mixNumber$1(min, point, elastic.min)
	            : Math.max(point, min);
	    }
	    else if (max !== undefined && point > max) {
	        // If we have a max point defined, and this is outside of that, constrain
	        point = elastic
	            ? mixNumber$1(max, point, elastic.max)
	            : Math.min(point, max);
	    }
	    return point;
	}
	/**
	 * Calculate constraints in terms of the viewport when defined relatively to the
	 * measured axis. This is measured from the nearest edge, so a max constraint of 200
	 * on an axis with a max value of 300 would return a constraint of 500 - axis length
	 */
	function calcRelativeAxisConstraints(axis, min, max) {
	    return {
	        min: min !== undefined ? axis.min + min : undefined,
	        max: max !== undefined
	            ? axis.max + max - (axis.max - axis.min)
	            : undefined,
	    };
	}
	/**
	 * Calculate constraints in terms of the viewport when
	 * defined relatively to the measured bounding box.
	 */
	function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
	    return {
	        x: calcRelativeAxisConstraints(layoutBox.x, left, right),
	        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
	    };
	}
	/**
	 * Calculate viewport constraints when defined as another viewport-relative axis
	 */
	function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
	    let min = constraintsAxis.min - layoutAxis.min;
	    let max = constraintsAxis.max - layoutAxis.max;
	    // If the constraints axis is actually smaller than the layout axis then we can
	    // flip the constraints
	    if (constraintsAxis.max - constraintsAxis.min <
	        layoutAxis.max - layoutAxis.min) {
	        [min, max] = [max, min];
	    }
	    return { min, max };
	}
	/**
	 * Calculate viewport constraints when defined as another viewport-relative box
	 */
	function calcViewportConstraints(layoutBox, constraintsBox) {
	    return {
	        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
	        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
	    };
	}
	/**
	 * Calculate a transform origin relative to the source axis, between 0-1, that results
	 * in an asthetically pleasing scale/transform needed to project from source to target.
	 */
	function calcOrigin$1(source, target) {
	    let origin = 0.5;
	    const sourceLength = calcLength(source);
	    const targetLength = calcLength(target);
	    if (targetLength > sourceLength) {
	        origin = progress(target.min, target.max - sourceLength, source.min);
	    }
	    else if (sourceLength > targetLength) {
	        origin = progress(source.min, source.max - targetLength, target.min);
	    }
	    return clamp(0, 1, origin);
	}
	/**
	 * Rebase the calculated viewport constraints relative to the layout.min point.
	 */
	function rebaseAxisConstraints(layout, constraints) {
	    const relativeConstraints = {};
	    if (constraints.min !== undefined) {
	        relativeConstraints.min = constraints.min - layout.min;
	    }
	    if (constraints.max !== undefined) {
	        relativeConstraints.max = constraints.max - layout.min;
	    }
	    return relativeConstraints;
	}
	const defaultElastic = 0.35;
	/**
	 * Accepts a dragElastic prop and returns resolved elastic values for each axis.
	 */
	function resolveDragElastic(dragElastic = defaultElastic) {
	    if (dragElastic === false) {
	        dragElastic = 0;
	    }
	    else if (dragElastic === true) {
	        dragElastic = defaultElastic;
	    }
	    return {
	        x: resolveAxisElastic(dragElastic, "left", "right"),
	        y: resolveAxisElastic(dragElastic, "top", "bottom"),
	    };
	}
	function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
	    return {
	        min: resolvePointElastic(dragElastic, minLabel),
	        max: resolvePointElastic(dragElastic, maxLabel),
	    };
	}
	function resolvePointElastic(dragElastic, label) {
	    return typeof dragElastic === "number"
	        ? dragElastic
	        : dragElastic[label] || 0;
	}

	const createAxisDelta = () => ({
	    translate: 0,
	    scale: 1,
	    origin: 0,
	    originPoint: 0,
	});
	const createDelta = () => ({
	    x: createAxisDelta(),
	    y: createAxisDelta(),
	});
	const createAxis = () => ({ min: 0, max: 0 });
	const createBox = () => ({
	    x: createAxis(),
	    y: createAxis(),
	});

	function eachAxis(callback) {
	    return [callback("x"), callback("y")];
	}

	/**
	 * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
	 * it's easier to consider each axis individually. This function returns a bounding box
	 * as a map of single-axis min/max values.
	 */
	function convertBoundingBoxToBox({ top, left, right, bottom, }) {
	    return {
	        x: { min: left, max: right },
	        y: { min: top, max: bottom },
	    };
	}
	function convertBoxToBoundingBox({ x, y }) {
	    return { top: y.min, right: x.max, bottom: y.max, left: x.min };
	}
	/**
	 * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
	 * provided by Framer to allow measured points to be corrected for device scaling. This is used
	 * when measuring DOM elements and DOM event points.
	 */
	function transformBoxPoints(point, transformPoint) {
	    if (!transformPoint)
	        return point;
	    const topLeft = transformPoint({ x: point.left, y: point.top });
	    const bottomRight = transformPoint({ x: point.right, y: point.bottom });
	    return {
	        top: topLeft.y,
	        left: topLeft.x,
	        bottom: bottomRight.y,
	        right: bottomRight.x,
	    };
	}

	function isIdentityScale(scale) {
	    return scale === undefined || scale === 1;
	}
	function hasScale({ scale, scaleX, scaleY }) {
	    return (!isIdentityScale(scale) ||
	        !isIdentityScale(scaleX) ||
	        !isIdentityScale(scaleY));
	}
	function hasTransform(values) {
	    return (hasScale(values) ||
	        has2DTranslate(values) ||
	        values.z ||
	        values.rotate ||
	        values.rotateX ||
	        values.rotateY ||
	        values.skewX ||
	        values.skewY);
	}
	function has2DTranslate(values) {
	    return is2DTranslate(values.x) || is2DTranslate(values.y);
	}
	function is2DTranslate(value) {
	    return value && value !== "0%";
	}

	/**
	 * Scales a point based on a factor and an originPoint
	 */
	function scalePoint(point, scale, originPoint) {
	    const distanceFromOrigin = point - originPoint;
	    const scaled = scale * distanceFromOrigin;
	    return originPoint + scaled;
	}
	/**
	 * Applies a translate/scale delta to a point
	 */
	function applyPointDelta(point, translate, scale, originPoint, boxScale) {
	    if (boxScale !== undefined) {
	        point = scalePoint(point, boxScale, originPoint);
	    }
	    return scalePoint(point, scale, originPoint) + translate;
	}
	/**
	 * Applies a translate/scale delta to an axis
	 */
	function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
	    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
	    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
	}
	/**
	 * Applies a translate/scale delta to a box
	 */
	function applyBoxDelta(box, { x, y }) {
	    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
	    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
	}
	const TREE_SCALE_SNAP_MIN = 0.999999999999;
	const TREE_SCALE_SNAP_MAX = 1.0000000000001;
	/**
	 * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
	 * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
	 *
	 * This is the final nested loop within updateLayoutDelta for future refactoring
	 */
	function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
	    const treeLength = treePath.length;
	    if (!treeLength)
	        return;
	    // Reset the treeScale
	    treeScale.x = treeScale.y = 1;
	    let node;
	    let delta;
	    for (let i = 0; i < treeLength; i++) {
	        node = treePath[i];
	        delta = node.projectionDelta;
	        /**
	         * TODO: Prefer to remove this, but currently we have motion components with
	         * display: contents in Framer.
	         */
	        const { visualElement } = node.options;
	        if (visualElement &&
	            visualElement.props.style &&
	            visualElement.props.style.display === "contents") {
	            continue;
	        }
	        if (isSharedTransition &&
	            node.options.layoutScroll &&
	            node.scroll &&
	            node !== node.root) {
	            transformBox(box, {
	                x: -node.scroll.offset.x,
	                y: -node.scroll.offset.y,
	            });
	        }
	        if (delta) {
	            // Incoporate each ancestor's scale into a culmulative treeScale for this component
	            treeScale.x *= delta.x.scale;
	            treeScale.y *= delta.y.scale;
	            // Apply each ancestor's calculated delta into this component's recorded layout box
	            applyBoxDelta(box, delta);
	        }
	        if (isSharedTransition && hasTransform(node.latestValues)) {
	            transformBox(box, node.latestValues);
	        }
	    }
	    /**
	     * Snap tree scale back to 1 if it's within a non-perceivable threshold.
	     * This will help reduce useless scales getting rendered.
	     */
	    if (treeScale.x < TREE_SCALE_SNAP_MAX &&
	        treeScale.x > TREE_SCALE_SNAP_MIN) {
	        treeScale.x = 1.0;
	    }
	    if (treeScale.y < TREE_SCALE_SNAP_MAX &&
	        treeScale.y > TREE_SCALE_SNAP_MIN) {
	        treeScale.y = 1.0;
	    }
	}
	function translateAxis(axis, distance) {
	    axis.min = axis.min + distance;
	    axis.max = axis.max + distance;
	}
	/**
	 * Apply a transform to an axis from the latest resolved motion values.
	 * This function basically acts as a bridge between a flat motion value map
	 * and applyAxisDelta
	 */
	function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
	    const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
	    // Apply the axis delta to the final axis
	    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
	}
	/**
	 * Apply a transform to a box from the latest resolved motion values.
	 */
	function transformBox(box, transform) {
	    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
	    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
	}

	function measureViewportBox(instance, transformPoint) {
	    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
	}
	function measurePageBox(element, rootProjectionNode, transformPagePoint) {
	    const viewportBox = measureViewportBox(element, transformPagePoint);
	    const { scroll } = rootProjectionNode;
	    if (scroll) {
	        translateAxis(viewportBox.x, scroll.offset.x);
	        translateAxis(viewportBox.y, scroll.offset.y);
	    }
	    return viewportBox;
	}

	// Fixes https://github.com/motiondivision/motion/issues/2270
	const getContextWindow = ({ current }) => {
	    return current ? current.ownerDocument.defaultView : null;
	};

	const elementDragControls = new WeakMap();
	/**
	 *
	 */
	// let latestPointerEvent: PointerEvent
	class VisualElementDragControls {
	    constructor(visualElement) {
	        this.openDragLock = null;
	        this.isDragging = false;
	        this.currentDirection = null;
	        this.originPoint = { x: 0, y: 0 };
	        /**
	         * The permitted boundaries of travel, in pixels.
	         */
	        this.constraints = false;
	        this.hasMutatedConstraints = false;
	        /**
	         * The per-axis resolved elastic values.
	         */
	        this.elastic = createBox();
	        this.visualElement = visualElement;
	    }
	    start(originEvent, { snapToCursor = false } = {}) {
	        /**
	         * Don't start dragging if this component is exiting
	         */
	        const { presenceContext } = this.visualElement;
	        if (presenceContext && presenceContext.isPresent === false)
	            return;
	        const onSessionStart = (event) => {
	            const { dragSnapToOrigin } = this.getProps();
	            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch
	            // the component.
	            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
	            if (snapToCursor) {
	                this.snapToCursor(extractEventInfo(event).point);
	            }
	        };
	        const onStart = (event, info) => {
	            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
	            const { drag, dragPropagation, onDragStart } = this.getProps();
	            if (drag && !dragPropagation) {
	                if (this.openDragLock)
	                    this.openDragLock();
	                this.openDragLock = setDragLock(drag);
	                // If we don 't have the lock, don't start dragging
	                if (!this.openDragLock)
	                    return;
	            }
	            this.isDragging = true;
	            this.currentDirection = null;
	            this.resolveConstraints();
	            if (this.visualElement.projection) {
	                this.visualElement.projection.isAnimationBlocked = true;
	                this.visualElement.projection.target = undefined;
	            }
	            /**
	             * Record gesture origin
	             */
	            eachAxis((axis) => {
	                let current = this.getAxisMotionValue(axis).get() || 0;
	                /**
	                 * If the MotionValue is a percentage value convert to px
	                 */
	                if (percent.test(current)) {
	                    const { projection } = this.visualElement;
	                    if (projection && projection.layout) {
	                        const measuredAxis = projection.layout.layoutBox[axis];
	                        if (measuredAxis) {
	                            const length = calcLength(measuredAxis);
	                            current = length * (parseFloat(current) / 100);
	                        }
	                    }
	                }
	                this.originPoint[axis] = current;
	            });
	            // Fire onDragStart event
	            if (onDragStart) {
	                frame.postRender(() => onDragStart(event, info));
	            }
	            addValueToWillChange(this.visualElement, "transform");
	            const { animationState } = this.visualElement;
	            animationState && animationState.setActive("whileDrag", true);
	        };
	        const onMove = (event, info) => {
	            // latestPointerEvent = event
	            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();
	            // If we didn't successfully receive the gesture lock, early return.
	            if (!dragPropagation && !this.openDragLock)
	                return;
	            const { offset } = info;
	            // Attempt to detect drag direction if directionLock is true
	            if (dragDirectionLock && this.currentDirection === null) {
	                this.currentDirection = getCurrentDirection(offset);
	                // If we've successfully set a direction, notify listener
	                if (this.currentDirection !== null) {
	                    onDirectionLock && onDirectionLock(this.currentDirection);
	                }
	                return;
	            }
	            // Update each point with the latest position
	            this.updateAxis("x", info.point, offset);
	            this.updateAxis("y", info.point, offset);
	            /**
	             * Ideally we would leave the renderer to fire naturally at the end of
	             * this frame but if the element is about to change layout as the result
	             * of a re-render we want to ensure the browser can read the latest
	             * bounding box to ensure the pointer and element don't fall out of sync.
	             */
	            this.visualElement.render();
	            /**
	             * This must fire after the render call as it might trigger a state
	             * change which itself might trigger a layout update.
	             */
	            onDrag && onDrag(event, info);
	        };
	        const onSessionEnd = (event, info) => this.stop(event, info);
	        const resumeAnimation = () => eachAxis((axis) => {
	            var _a;
	            return this.getAnimationState(axis) === "paused" &&
	                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
	        });
	        const { dragSnapToOrigin } = this.getProps();
	        this.panSession = new PanSession(originEvent, {
	            onSessionStart,
	            onStart,
	            onMove,
	            onSessionEnd,
	            resumeAnimation,
	        }, {
	            transformPagePoint: this.visualElement.getTransformPagePoint(),
	            dragSnapToOrigin,
	            contextWindow: getContextWindow(this.visualElement),
	        });
	    }
	    stop(event, info) {
	        const isDragging = this.isDragging;
	        this.cancel();
	        if (!isDragging)
	            return;
	        const { velocity } = info;
	        this.startAnimation(velocity);
	        const { onDragEnd } = this.getProps();
	        if (onDragEnd) {
	            frame.postRender(() => onDragEnd(event, info));
	        }
	    }
	    cancel() {
	        this.isDragging = false;
	        const { projection, animationState } = this.visualElement;
	        if (projection) {
	            projection.isAnimationBlocked = false;
	        }
	        this.panSession && this.panSession.end();
	        this.panSession = undefined;
	        const { dragPropagation } = this.getProps();
	        if (!dragPropagation && this.openDragLock) {
	            this.openDragLock();
	            this.openDragLock = null;
	        }
	        animationState && animationState.setActive("whileDrag", false);
	    }
	    updateAxis(axis, _point, offset) {
	        const { drag } = this.getProps();
	        // If we're not dragging this axis, do an early return.
	        if (!offset || !shouldDrag(axis, drag, this.currentDirection))
	            return;
	        const axisValue = this.getAxisMotionValue(axis);
	        let next = this.originPoint[axis] + offset[axis];
	        // Apply constraints
	        if (this.constraints && this.constraints[axis]) {
	            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
	        }
	        axisValue.set(next);
	    }
	    resolveConstraints() {
	        var _a;
	        const { dragConstraints, dragElastic } = this.getProps();
	        const layout = this.visualElement.projection &&
	            !this.visualElement.projection.layout
	            ? this.visualElement.projection.measure(false)
	            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
	        const prevConstraints = this.constraints;
	        if (dragConstraints && isRefObject(dragConstraints)) {
	            if (!this.constraints) {
	                this.constraints = this.resolveRefConstraints();
	            }
	        }
	        else {
	            if (dragConstraints && layout) {
	                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
	            }
	            else {
	                this.constraints = false;
	            }
	        }
	        this.elastic = resolveDragElastic(dragElastic);
	        /**
	         * If we're outputting to external MotionValues, we want to rebase the measured constraints
	         * from viewport-relative to component-relative.
	         */
	        if (prevConstraints !== this.constraints &&
	            layout &&
	            this.constraints &&
	            !this.hasMutatedConstraints) {
	            eachAxis((axis) => {
	                if (this.constraints !== false &&
	                    this.getAxisMotionValue(axis)) {
	                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
	                }
	            });
	        }
	    }
	    resolveRefConstraints() {
	        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
	        if (!constraints || !isRefObject(constraints))
	            return false;
	        const constraintsElement = constraints.current;
	        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
	        const { projection } = this.visualElement;
	        // TODO
	        if (!projection || !projection.layout)
	            return false;
	        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
	        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
	        /**
	         * If there's an onMeasureDragConstraints listener we call it and
	         * if different constraints are returned, set constraints to that
	         */
	        if (onMeasureDragConstraints) {
	            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
	            this.hasMutatedConstraints = !!userConstraints;
	            if (userConstraints) {
	                measuredConstraints = convertBoundingBoxToBox(userConstraints);
	            }
	        }
	        return measuredConstraints;
	    }
	    startAnimation(velocity) {
	        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();
	        const constraints = this.constraints || {};
	        const momentumAnimations = eachAxis((axis) => {
	            if (!shouldDrag(axis, drag, this.currentDirection)) {
	                return;
	            }
	            let transition = (constraints && constraints[axis]) || {};
	            if (dragSnapToOrigin)
	                transition = { min: 0, max: 0 };
	            /**
	             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
	             * of spring animations so we should look into adding a disable spring option to `inertia`.
	             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
	             * using the value of `dragElastic`.
	             */
	            const bounceStiffness = dragElastic ? 200 : 1000000;
	            const bounceDamping = dragElastic ? 40 : 10000000;
	            const inertia = {
	                type: "inertia",
	                velocity: dragMomentum ? velocity[axis] : 0,
	                bounceStiffness,
	                bounceDamping,
	                timeConstant: 750,
	                restDelta: 1,
	                restSpeed: 10,
	                ...dragTransition,
	                ...transition,
	            };
	            // If we're not animating on an externally-provided `MotionValue` we can use the
	            // component's animation controls which will handle interactions with whileHover (etc),
	            // otherwise we just have to animate the `MotionValue` itself.
	            return this.startAxisValueAnimation(axis, inertia);
	        });
	        // Run all animations and then resolve the new drag constraints.
	        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
	    }
	    startAxisValueAnimation(axis, transition) {
	        const axisValue = this.getAxisMotionValue(axis);
	        addValueToWillChange(this.visualElement, axis);
	        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
	    }
	    stopAnimation() {
	        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
	    }
	    pauseAnimation() {
	        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });
	    }
	    getAnimationState(axis) {
	        var _a;
	        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
	    }
	    /**
	     * Drag works differently depending on which props are provided.
	     *
	     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
	     * - Otherwise, we apply the delta to the x/y motion values.
	     */
	    getAxisMotionValue(axis) {
	        const dragKey = `_drag${axis.toUpperCase()}`;
	        const props = this.visualElement.getProps();
	        const externalMotionValue = props[dragKey];
	        return externalMotionValue
	            ? externalMotionValue
	            : this.visualElement.getValue(axis, (props.initial
	                ? props.initial[axis]
	                : undefined) || 0);
	    }
	    snapToCursor(point) {
	        eachAxis((axis) => {
	            const { drag } = this.getProps();
	            // If we're not dragging this axis, do an early return.
	            if (!shouldDrag(axis, drag, this.currentDirection))
	                return;
	            const { projection } = this.visualElement;
	            const axisValue = this.getAxisMotionValue(axis);
	            if (projection && projection.layout) {
	                const { min, max } = projection.layout.layoutBox[axis];
	                axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));
	            }
	        });
	    }
	    /**
	     * When the viewport resizes we want to check if the measured constraints
	     * have changed and, if so, reposition the element within those new constraints
	     * relative to where it was before the resize.
	     */
	    scalePositionWithinConstraints() {
	        if (!this.visualElement.current)
	            return;
	        const { drag, dragConstraints } = this.getProps();
	        const { projection } = this.visualElement;
	        if (!isRefObject(dragConstraints) || !projection || !this.constraints)
	            return;
	        /**
	         * Stop current animations as there can be visual glitching if we try to do
	         * this mid-animation
	         */
	        this.stopAnimation();
	        /**
	         * Record the relative position of the dragged element relative to the
	         * constraints box and save as a progress value.
	         */
	        const boxProgress = { x: 0, y: 0 };
	        eachAxis((axis) => {
	            const axisValue = this.getAxisMotionValue(axis);
	            if (axisValue && this.constraints !== false) {
	                const latest = axisValue.get();
	                boxProgress[axis] = calcOrigin$1({ min: latest, max: latest }, this.constraints[axis]);
	            }
	        });
	        /**
	         * Update the layout of this element and resolve the latest drag constraints
	         */
	        const { transformTemplate } = this.visualElement.getProps();
	        this.visualElement.current.style.transform = transformTemplate
	            ? transformTemplate({}, "")
	            : "none";
	        projection.root && projection.root.updateScroll();
	        projection.updateLayout();
	        this.resolveConstraints();
	        /**
	         * For each axis, calculate the current progress of the layout axis
	         * within the new constraints.
	         */
	        eachAxis((axis) => {
	            if (!shouldDrag(axis, drag, null))
	                return;
	            /**
	             * Calculate a new transform based on the previous box progress
	             */
	            const axisValue = this.getAxisMotionValue(axis);
	            const { min, max } = this.constraints[axis];
	            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
	        });
	    }
	    addListeners() {
	        if (!this.visualElement.current)
	            return;
	        elementDragControls.set(this.visualElement, this);
	        const element = this.visualElement.current;
	        /**
	         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
	         */
	        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
	            const { drag, dragListener = true } = this.getProps();
	            drag && dragListener && this.start(event);
	        });
	        const measureDragConstraints = () => {
	            const { dragConstraints } = this.getProps();
	            if (isRefObject(dragConstraints) && dragConstraints.current) {
	                this.constraints = this.resolveRefConstraints();
	            }
	        };
	        const { projection } = this.visualElement;
	        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
	        if (projection && !projection.layout) {
	            projection.root && projection.root.updateScroll();
	            projection.updateLayout();
	        }
	        frame.read(measureDragConstraints);
	        /**
	         * Attach a window resize listener to scale the draggable target within its defined
	         * constraints as the window resizes.
	         */
	        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
	        /**
	         * If the element's layout changes, calculate the delta and apply that to
	         * the drag gesture's origin point.
	         */
	        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {
	            if (this.isDragging && hasLayoutChanged) {
	                eachAxis((axis) => {
	                    const motionValue = this.getAxisMotionValue(axis);
	                    if (!motionValue)
	                        return;
	                    this.originPoint[axis] += delta[axis].translate;
	                    motionValue.set(motionValue.get() + delta[axis].translate);
	                });
	                this.visualElement.render();
	            }
	        }));
	        return () => {
	            stopResizeListener();
	            stopPointerListener();
	            stopMeasureLayoutListener();
	            stopLayoutUpdateListener && stopLayoutUpdateListener();
	        };
	    }
	    getProps() {
	        const props = this.visualElement.getProps();
	        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;
	        return {
	            ...props,
	            drag,
	            dragDirectionLock,
	            dragPropagation,
	            dragConstraints,
	            dragElastic,
	            dragMomentum,
	        };
	    }
	}
	function shouldDrag(direction, drag, currentDirection) {
	    return ((drag === true || drag === direction) &&
	        (currentDirection === null || currentDirection === direction));
	}
	/**
	 * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
	 * than the provided threshold, return `null`.
	 *
	 * @param offset - The x/y offset from origin.
	 * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
	 */
	function getCurrentDirection(offset, lockThreshold = 10) {
	    let direction = null;
	    if (Math.abs(offset.y) > lockThreshold) {
	        direction = "y";
	    }
	    else if (Math.abs(offset.x) > lockThreshold) {
	        direction = "x";
	    }
	    return direction;
	}

	class DragGesture extends Feature {
	    constructor(node) {
	        super(node);
	        this.removeGroupControls = noop;
	        this.removeListeners = noop;
	        this.controls = new VisualElementDragControls(node);
	    }
	    mount() {
	        // If we've been provided a DragControls for manual control over the drag gesture,
	        // subscribe this component to it on mount.
	        const { dragControls } = this.node.getProps();
	        if (dragControls) {
	            this.removeGroupControls = dragControls.subscribe(this.controls);
	        }
	        this.removeListeners = this.controls.addListeners() || noop;
	    }
	    unmount() {
	        this.removeGroupControls();
	        this.removeListeners();
	    }
	}

	const asyncHandler = (handler) => (event, info) => {
	    if (handler) {
	        frame.postRender(() => handler(event, info));
	    }
	};
	class PanGesture extends Feature {
	    constructor() {
	        super(...arguments);
	        this.removePointerDownListener = noop;
	    }
	    onPointerDown(pointerDownEvent) {
	        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
	            transformPagePoint: this.node.getTransformPagePoint(),
	            contextWindow: getContextWindow(this.node),
	        });
	    }
	    createPanHandlers() {
	        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
	        return {
	            onSessionStart: asyncHandler(onPanSessionStart),
	            onStart: asyncHandler(onPanStart),
	            onMove: onPan,
	            onEnd: (event, info) => {
	                delete this.session;
	                if (onPanEnd) {
	                    frame.postRender(() => onPanEnd(event, info));
	                }
	            },
	        };
	    }
	    mount() {
	        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
	    }
	    update() {
	        this.session && this.session.updateHandlers(this.createPanHandlers());
	    }
	    unmount() {
	        this.removePointerDownListener();
	        this.session && this.session.end();
	    }
	}

	var jsxRuntime = {exports: {}};

	var reactJsxRuntime_production_min = {};

	/**
	 * @license React
	 * react-jsx-runtime.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var hasRequiredReactJsxRuntime_production_min;

	function requireReactJsxRuntime_production_min () {
		if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
		hasRequiredReactJsxRuntime_production_min = 1;

		var f = requireReact(),
		  k = Symbol.for("react.element"),
		  l = Symbol.for("react.fragment"),
		  m = Object.prototype.hasOwnProperty,
		  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
		  p = {
		    key: !0,
		    ref: !0,
		    __self: !0,
		    __source: !0
		  };
		function q(c, a, g) {
		  var b,
		    d = {},
		    e = null,
		    h = null;
		  void 0 !== g && (e = "" + g);
		  void 0 !== a.key && (e = "" + a.key);
		  void 0 !== a.ref && (h = a.ref);
		  for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
		  if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
		  return {
		    $$typeof: k,
		    type: c,
		    key: e,
		    ref: h,
		    props: d,
		    _owner: n.current
		  };
		}
		reactJsxRuntime_production_min.Fragment = l;
		reactJsxRuntime_production_min.jsx = q;
		reactJsxRuntime_production_min.jsxs = q;
		return reactJsxRuntime_production_min;
	}

	var reactJsxRuntime_development = {};

	var hasRequiredReactJsxRuntime_development;

	function requireReactJsxRuntime_development () {
		if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
		hasRequiredReactJsxRuntime_development = 1;

		if (process.env.NODE_ENV !== "production") {
		  (function () {

		    var React = requireReact();

		    // ATTENTION
		    // When adding new symbols to this file,
		    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
		    // The Symbol used to tag the ReactElement-like types.
		    var REACT_ELEMENT_TYPE = Symbol.for('react.element');
		    var REACT_PORTAL_TYPE = Symbol.for('react.portal');
		    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
		    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
		    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
		    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
		    var REACT_CONTEXT_TYPE = Symbol.for('react.context');
		    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
		    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
		    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
		    var REACT_MEMO_TYPE = Symbol.for('react.memo');
		    var REACT_LAZY_TYPE = Symbol.for('react.lazy');
		    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
		    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
		    var FAUX_ITERATOR_SYMBOL = '@@iterator';
		    function getIteratorFn(maybeIterable) {
		      if (maybeIterable === null || typeof maybeIterable !== 'object') {
		        return null;
		      }
		      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
		      if (typeof maybeIterator === 'function') {
		        return maybeIterator;
		      }
		      return null;
		    }
		    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
		    function error(format) {
		      {
		        {
		          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
		            args[_key2 - 1] = arguments[_key2];
		          }
		          printWarning('error', format, args);
		        }
		      }
		    }
		    function printWarning(level, format, args) {
		      // When changing this logic, you might want to also
		      // update consoleWithStackDev.www.js as well.
		      {
		        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
		        var stack = ReactDebugCurrentFrame.getStackAddendum();
		        if (stack !== '') {
		          format += '%s';
		          args = args.concat([stack]);
		        } // eslint-disable-next-line react-internal/safe-string-coercion

		        var argsWithFormat = args.map(function (item) {
		          return String(item);
		        }); // Careful: RN currently depends on this prefix

		        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
		        // breaks IE9: https://github.com/facebook/react/issues/13610
		        // eslint-disable-next-line react-internal/no-production-logging

		        Function.prototype.apply.call(console[level], console, argsWithFormat);
		      }
		    }

		    // -----------------------------------------------------------------------------

		    var enableScopeAPI = false; // Experimental Create Event Handle API.
		    var enableCacheElement = false;
		    var enableTransitionTracing = false; // No known bugs, but needs performance testing

		    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
		    // stuff. Intended to enable React core members to more easily debug scheduling
		    // issues in DEV builds.

		    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

		    var REACT_MODULE_REFERENCE;
		    {
		      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
		    }
		    function isValidElementType(type) {
		      if (typeof type === 'string' || typeof type === 'function') {
		        return true;
		      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).

		      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
		        return true;
		      }
		      if (typeof type === 'object' && type !== null) {
		        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||
		        // This needs to include all possible module reference object
		        // types supported by any Flight configuration anywhere since
		        // we don't know which Flight build this will end up being used
		        // with.
		        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
		          return true;
		        }
		      }
		      return false;
		    }
		    function getWrappedName(outerType, innerType, wrapperName) {
		      var displayName = outerType.displayName;
		      if (displayName) {
		        return displayName;
		      }
		      var functionName = innerType.displayName || innerType.name || '';
		      return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
		    } // Keep in sync with react-reconciler/getComponentNameFromFiber

		    function getContextName(type) {
		      return type.displayName || 'Context';
		    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.

		    function getComponentNameFromType(type) {
		      if (type == null) {
		        // Host root, text node or just invalid type.
		        return null;
		      }
		      {
		        if (typeof type.tag === 'number') {
		          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
		        }
		      }
		      if (typeof type === 'function') {
		        return type.displayName || type.name || null;
		      }
		      if (typeof type === 'string') {
		        return type;
		      }
		      switch (type) {
		        case REACT_FRAGMENT_TYPE:
		          return 'Fragment';
		        case REACT_PORTAL_TYPE:
		          return 'Portal';
		        case REACT_PROFILER_TYPE:
		          return 'Profiler';
		        case REACT_STRICT_MODE_TYPE:
		          return 'StrictMode';
		        case REACT_SUSPENSE_TYPE:
		          return 'Suspense';
		        case REACT_SUSPENSE_LIST_TYPE:
		          return 'SuspenseList';
		      }
		      if (typeof type === 'object') {
		        switch (type.$$typeof) {
		          case REACT_CONTEXT_TYPE:
		            var context = type;
		            return getContextName(context) + '.Consumer';
		          case REACT_PROVIDER_TYPE:
		            var provider = type;
		            return getContextName(provider._context) + '.Provider';
		          case REACT_FORWARD_REF_TYPE:
		            return getWrappedName(type, type.render, 'ForwardRef');
		          case REACT_MEMO_TYPE:
		            var outerName = type.displayName || null;
		            if (outerName !== null) {
		              return outerName;
		            }
		            return getComponentNameFromType(type.type) || 'Memo';
		          case REACT_LAZY_TYPE:
		            {
		              var lazyComponent = type;
		              var payload = lazyComponent._payload;
		              var init = lazyComponent._init;
		              try {
		                return getComponentNameFromType(init(payload));
		              } catch (x) {
		                return null;
		              }
		            }

		          // eslint-disable-next-line no-fallthrough
		        }
		      }
		      return null;
		    }
		    var assign = Object.assign;

		    // Helpers to patch console.logs to avoid logging during side-effect free
		    // replaying on render function. This currently only patches the object
		    // lazily which won't cover if the log function was extracted eagerly.
		    // We could also eagerly patch the method.
		    var disabledDepth = 0;
		    var prevLog;
		    var prevInfo;
		    var prevWarn;
		    var prevError;
		    var prevGroup;
		    var prevGroupCollapsed;
		    var prevGroupEnd;
		    function disabledLog() {}
		    disabledLog.__reactDisabledLog = true;
		    function disableLogs() {
		      {
		        if (disabledDepth === 0) {
		          /* eslint-disable react-internal/no-production-logging */
		          prevLog = console.log;
		          prevInfo = console.info;
		          prevWarn = console.warn;
		          prevError = console.error;
		          prevGroup = console.group;
		          prevGroupCollapsed = console.groupCollapsed;
		          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

		          var props = {
		            configurable: true,
		            enumerable: true,
		            value: disabledLog,
		            writable: true
		          }; // $FlowFixMe Flow thinks console is immutable.

		          Object.defineProperties(console, {
		            info: props,
		            log: props,
		            warn: props,
		            error: props,
		            group: props,
		            groupCollapsed: props,
		            groupEnd: props
		          });
		          /* eslint-enable react-internal/no-production-logging */
		        }
		        disabledDepth++;
		      }
		    }
		    function reenableLogs() {
		      {
		        disabledDepth--;
		        if (disabledDepth === 0) {
		          /* eslint-disable react-internal/no-production-logging */
		          var props = {
		            configurable: true,
		            enumerable: true,
		            writable: true
		          }; // $FlowFixMe Flow thinks console is immutable.

		          Object.defineProperties(console, {
		            log: assign({}, props, {
		              value: prevLog
		            }),
		            info: assign({}, props, {
		              value: prevInfo
		            }),
		            warn: assign({}, props, {
		              value: prevWarn
		            }),
		            error: assign({}, props, {
		              value: prevError
		            }),
		            group: assign({}, props, {
		              value: prevGroup
		            }),
		            groupCollapsed: assign({}, props, {
		              value: prevGroupCollapsed
		            }),
		            groupEnd: assign({}, props, {
		              value: prevGroupEnd
		            })
		          });
		          /* eslint-enable react-internal/no-production-logging */
		        }
		        if (disabledDepth < 0) {
		          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
		        }
		      }
		    }
		    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
		    var prefix;
		    function describeBuiltInComponentFrame(name, source, ownerFn) {
		      {
		        if (prefix === undefined) {
		          // Extract the VM specific prefix used by each line.
		          try {
		            throw Error();
		          } catch (x) {
		            var match = x.stack.trim().match(/\n( *(at )?)/);
		            prefix = match && match[1] || '';
		          }
		        } // We use the prefix to ensure our stacks line up with native stack frames.

		        return '\n' + prefix + name;
		      }
		    }
		    var reentry = false;
		    var componentFrameCache;
		    {
		      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
		      componentFrameCache = new PossiblyWeakMap();
		    }
		    function describeNativeComponentFrame(fn, construct) {
		      // If something asked for a stack inside a fake render, it should get ignored.
		      if (!fn || reentry) {
		        return '';
		      }
		      {
		        var frame = componentFrameCache.get(fn);
		        if (frame !== undefined) {
		          return frame;
		        }
		      }
		      var control;
		      reentry = true;
		      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

		      Error.prepareStackTrace = undefined;
		      var previousDispatcher;
		      {
		        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
		        // for warnings.

		        ReactCurrentDispatcher.current = null;
		        disableLogs();
		      }
		      try {
		        // This should throw.
		        if (construct) {
		          // Something should be setting the props in the constructor.
		          var Fake = function () {
		            throw Error();
		          }; // $FlowFixMe

		          Object.defineProperty(Fake.prototype, 'props', {
		            set: function () {
		              // We use a throwing setter instead of frozen or non-writable props
		              // because that won't throw in a non-strict mode function.
		              throw Error();
		            }
		          });
		          if (typeof Reflect === 'object' && Reflect.construct) {
		            // We construct a different control for this case to include any extra
		            // frames added by the construct call.
		            try {
		              Reflect.construct(Fake, []);
		            } catch (x) {
		              control = x;
		            }
		            Reflect.construct(fn, [], Fake);
		          } else {
		            try {
		              Fake.call();
		            } catch (x) {
		              control = x;
		            }
		            fn.call(Fake.prototype);
		          }
		        } else {
		          try {
		            throw Error();
		          } catch (x) {
		            control = x;
		          }
		          fn();
		        }
		      } catch (sample) {
		        // This is inlined manually because closure doesn't do it for us.
		        if (sample && control && typeof sample.stack === 'string') {
		          // This extracts the first frame from the sample that isn't also in the control.
		          // Skipping one frame that we assume is the frame that calls the two.
		          var sampleLines = sample.stack.split('\n');
		          var controlLines = control.stack.split('\n');
		          var s = sampleLines.length - 1;
		          var c = controlLines.length - 1;
		          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
		            // We expect at least one stack frame to be shared.
		            // Typically this will be the root most one. However, stack frames may be
		            // cut off due to maximum stack limits. In this case, one maybe cut off
		            // earlier than the other. We assume that the sample is longer or the same
		            // and there for cut off earlier. So we should find the root most frame in
		            // the sample somewhere in the control.
		            c--;
		          }
		          for (; s >= 1 && c >= 0; s--, c--) {
		            // Next we find the first one that isn't the same which should be the
		            // frame that called our sample function and the control.
		            if (sampleLines[s] !== controlLines[c]) {
		              // In V8, the first line is describing the message but other VMs don't.
		              // If we're about to return the first line, and the control is also on the same
		              // line, that's a pretty good indicator that our sample threw at same line as
		              // the control. I.e. before we entered the sample frame. So we ignore this result.
		              // This can happen if you passed a class to function component, or non-function.
		              if (s !== 1 || c !== 1) {
		                do {
		                  s--;
		                  c--; // We may still have similar intermediate frames from the construct call.
		                  // The next one that isn't the same should be our match though.

		                  if (c < 0 || sampleLines[s] !== controlLines[c]) {
		                    // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
		                    var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
		                    // but we have a user-provided "displayName"
		                    // splice it in to make the stack more readable.

		                    if (fn.displayName && _frame.includes('<anonymous>')) {
		                      _frame = _frame.replace('<anonymous>', fn.displayName);
		                    }
		                    {
		                      if (typeof fn === 'function') {
		                        componentFrameCache.set(fn, _frame);
		                      }
		                    } // Return the line we found.

		                    return _frame;
		                  }
		                } while (s >= 1 && c >= 0);
		              }
		              break;
		            }
		          }
		        }
		      } finally {
		        reentry = false;
		        {
		          ReactCurrentDispatcher.current = previousDispatcher;
		          reenableLogs();
		        }
		        Error.prepareStackTrace = previousPrepareStackTrace;
		      } // Fallback to just using the name if we couldn't make it throw.

		      var name = fn ? fn.displayName || fn.name : '';
		      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';
		      {
		        if (typeof fn === 'function') {
		          componentFrameCache.set(fn, syntheticFrame);
		        }
		      }
		      return syntheticFrame;
		    }
		    function describeFunctionComponentFrame(fn, source, ownerFn) {
		      {
		        return describeNativeComponentFrame(fn, false);
		      }
		    }
		    function shouldConstruct(Component) {
		      var prototype = Component.prototype;
		      return !!(prototype && prototype.isReactComponent);
		    }
		    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
		      if (type == null) {
		        return '';
		      }
		      if (typeof type === 'function') {
		        {
		          return describeNativeComponentFrame(type, shouldConstruct(type));
		        }
		      }
		      if (typeof type === 'string') {
		        return describeBuiltInComponentFrame(type);
		      }
		      switch (type) {
		        case REACT_SUSPENSE_TYPE:
		          return describeBuiltInComponentFrame('Suspense');
		        case REACT_SUSPENSE_LIST_TYPE:
		          return describeBuiltInComponentFrame('SuspenseList');
		      }
		      if (typeof type === 'object') {
		        switch (type.$$typeof) {
		          case REACT_FORWARD_REF_TYPE:
		            return describeFunctionComponentFrame(type.render);
		          case REACT_MEMO_TYPE:
		            // Memo may contain any component type so we recursively resolve it.
		            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
		          case REACT_LAZY_TYPE:
		            {
		              var lazyComponent = type;
		              var payload = lazyComponent._payload;
		              var init = lazyComponent._init;
		              try {
		                // Lazy may contain any component type so we recursively resolve it.
		                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
		              } catch (x) {}
		            }
		        }
		      }
		      return '';
		    }
		    var hasOwnProperty = Object.prototype.hasOwnProperty;
		    var loggedTypeFailures = {};
		    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
		    function setCurrentlyValidatingElement(element) {
		      {
		        if (element) {
		          var owner = element._owner;
		          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
		          ReactDebugCurrentFrame.setExtraStackFrame(stack);
		        } else {
		          ReactDebugCurrentFrame.setExtraStackFrame(null);
		        }
		      }
		    }
		    function checkPropTypes(typeSpecs, values, location, componentName, element) {
		      {
		        // $FlowFixMe This is okay but Flow doesn't know it.
		        var has = Function.call.bind(hasOwnProperty);
		        for (var typeSpecName in typeSpecs) {
		          if (has(typeSpecs, typeSpecName)) {
		            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
		            // fail the render phase where it didn't fail before. So we log it.
		            // After these have been cleaned up, we'll let them throw.

		            try {
		              // This is intentionally an invariant that gets caught. It's the same
		              // behavior as without this statement except with a better message.
		              if (typeof typeSpecs[typeSpecName] !== 'function') {
		                // eslint-disable-next-line react-internal/prod-error-codes
		                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
		                err.name = 'Invariant Violation';
		                throw err;
		              }
		              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
		            } catch (ex) {
		              error$1 = ex;
		            }
		            if (error$1 && !(error$1 instanceof Error)) {
		              setCurrentlyValidatingElement(element);
		              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);
		              setCurrentlyValidatingElement(null);
		            }
		            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
		              // Only monitor this failure once because there tends to be a lot of the
		              // same error.
		              loggedTypeFailures[error$1.message] = true;
		              setCurrentlyValidatingElement(element);
		              error('Failed %s type: %s', location, error$1.message);
		              setCurrentlyValidatingElement(null);
		            }
		          }
		        }
		      }
		    }
		    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

		    function isArray(a) {
		      return isArrayImpl(a);
		    }

		    /*
		     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
		     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
		     *
		     * The functions in this module will throw an easier-to-understand,
		     * easier-to-debug exception with a clear errors message message explaining the
		     * problem. (Instead of a confusing exception thrown inside the implementation
		     * of the `value` object).
		     */
		    // $FlowFixMe only called in DEV, so void return is not possible.
		    function typeName(value) {
		      {
		        // toStringTag is needed for namespaced types like Temporal.Instant
		        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
		        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
		        return type;
		      }
		    } // $FlowFixMe only called in DEV, so void return is not possible.

		    function willCoercionThrow(value) {
		      {
		        try {
		          testStringCoercion(value);
		          return false;
		        } catch (e) {
		          return true;
		        }
		      }
		    }
		    function testStringCoercion(value) {
		      // If you ended up here by following an exception call stack, here's what's
		      // happened: you supplied an object or symbol value to React (as a prop, key,
		      // DOM attribute, CSS property, string ref, etc.) and when React tried to
		      // coerce it to a string using `'' + value`, an exception was thrown.
		      //
		      // The most common types that will cause this exception are `Symbol` instances
		      // and Temporal objects like `Temporal.Instant`. But any object that has a
		      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
		      // exception. (Library authors do this to prevent users from using built-in
		      // numeric operators like `+` or comparison operators like `>=` because custom
		      // methods are needed to perform accurate arithmetic or comparison.)
		      //
		      // To fix the problem, coerce this object or symbol value to a string before
		      // passing it to React. The most reliable way is usually `String(value)`.
		      //
		      // To find which value is throwing, check the browser or debugger console.
		      // Before this exception was thrown, there should be `console.error` output
		      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
		      // problem and how that type was used: key, atrribute, input value prop, etc.
		      // In most cases, this console output also shows the component and its
		      // ancestor components where the exception happened.
		      //
		      // eslint-disable-next-line react-internal/safe-string-coercion
		      return '' + value;
		    }
		    function checkKeyStringCoercion(value) {
		      {
		        if (willCoercionThrow(value)) {
		          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));
		          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
		        }
		      }
		    }
		    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
		    var RESERVED_PROPS = {
		      key: true,
		      ref: true,
		      __self: true,
		      __source: true
		    };
		    var specialPropKeyWarningShown;
		    var specialPropRefWarningShown;
		    var didWarnAboutStringRefs;
		    {
		      didWarnAboutStringRefs = {};
		    }
		    function hasValidRef(config) {
		      {
		        if (hasOwnProperty.call(config, 'ref')) {
		          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
		          if (getter && getter.isReactWarning) {
		            return false;
		          }
		        }
		      }
		      return config.ref !== undefined;
		    }
		    function hasValidKey(config) {
		      {
		        if (hasOwnProperty.call(config, 'key')) {
		          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
		          if (getter && getter.isReactWarning) {
		            return false;
		          }
		        }
		      }
		      return config.key !== undefined;
		    }
		    function warnIfStringRefCannotBeAutoConverted(config, self) {
		      {
		        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
		          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
		          if (!didWarnAboutStringRefs[componentName]) {
		            error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
		            didWarnAboutStringRefs[componentName] = true;
		          }
		        }
		      }
		    }
		    function defineKeyPropWarningGetter(props, displayName) {
		      {
		        var warnAboutAccessingKey = function () {
		          if (!specialPropKeyWarningShown) {
		            specialPropKeyWarningShown = true;
		            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
		          }
		        };
		        warnAboutAccessingKey.isReactWarning = true;
		        Object.defineProperty(props, 'key', {
		          get: warnAboutAccessingKey,
		          configurable: true
		        });
		      }
		    }
		    function defineRefPropWarningGetter(props, displayName) {
		      {
		        var warnAboutAccessingRef = function () {
		          if (!specialPropRefWarningShown) {
		            specialPropRefWarningShown = true;
		            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
		          }
		        };
		        warnAboutAccessingRef.isReactWarning = true;
		        Object.defineProperty(props, 'ref', {
		          get: warnAboutAccessingRef,
		          configurable: true
		        });
		      }
		    }
		    /**
		     * Factory method to create a new React element. This no longer adheres to
		     * the class pattern, so do not use new to call it. Also, instanceof check
		     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
		     * if something is a React Element.
		     *
		     * @param {*} type
		     * @param {*} props
		     * @param {*} key
		     * @param {string|object} ref
		     * @param {*} owner
		     * @param {*} self A *temporary* helper to detect places where `this` is
		     * different from the `owner` when React.createElement is called, so that we
		     * can warn. We want to get rid of owner and replace string `ref`s with arrow
		     * functions, and as long as `this` and owner are the same, there will be no
		     * change in behavior.
		     * @param {*} source An annotation object (added by a transpiler or otherwise)
		     * indicating filename, line number, and/or other information.
		     * @internal
		     */

		    var ReactElement = function (type, key, ref, self, source, owner, props) {
		      var element = {
		        // This tag allows us to uniquely identify this as a React Element
		        $$typeof: REACT_ELEMENT_TYPE,
		        // Built-in properties that belong on the element
		        type: type,
		        key: key,
		        ref: ref,
		        props: props,
		        // Record the component responsible for creating this element.
		        _owner: owner
		      };
		      {
		        // The validation flag is currently mutative. We put it on
		        // an external backing store so that we can freeze the whole object.
		        // This can be replaced with a WeakMap once they are implemented in
		        // commonly used development environments.
		        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
		        // the validation flag non-enumerable (where possible, which should
		        // include every environment we run tests in), so the test framework
		        // ignores it.

		        Object.defineProperty(element._store, 'validated', {
		          configurable: false,
		          enumerable: false,
		          writable: true,
		          value: false
		        }); // self and source are DEV only properties.

		        Object.defineProperty(element, '_self', {
		          configurable: false,
		          enumerable: false,
		          writable: false,
		          value: self
		        }); // Two elements created in two different places should be considered
		        // equal for testing purposes and therefore we hide it from enumeration.

		        Object.defineProperty(element, '_source', {
		          configurable: false,
		          enumerable: false,
		          writable: false,
		          value: source
		        });
		        if (Object.freeze) {
		          Object.freeze(element.props);
		          Object.freeze(element);
		        }
		      }
		      return element;
		    };
		    /**
		     * https://github.com/reactjs/rfcs/pull/107
		     * @param {*} type
		     * @param {object} props
		     * @param {string} key
		     */

		    function jsxDEV(type, config, maybeKey, source, self) {
		      {
		        var propName; // Reserved names are extracted

		        var props = {};
		        var key = null;
		        var ref = null; // Currently, key can be spread in as a prop. This causes a potential
		        // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
		        // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
		        // but as an intermediary step, we will use jsxDEV for everything except
		        // <div {...props} key="Hi" />, because we aren't currently able to tell if
		        // key is explicitly declared to be undefined or not.

		        if (maybeKey !== undefined) {
		          {
		            checkKeyStringCoercion(maybeKey);
		          }
		          key = '' + maybeKey;
		        }
		        if (hasValidKey(config)) {
		          {
		            checkKeyStringCoercion(config.key);
		          }
		          key = '' + config.key;
		        }
		        if (hasValidRef(config)) {
		          ref = config.ref;
		          warnIfStringRefCannotBeAutoConverted(config, self);
		        } // Remaining properties are added to a new props object

		        for (propName in config) {
		          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
		            props[propName] = config[propName];
		          }
		        } // Resolve default props

		        if (type && type.defaultProps) {
		          var defaultProps = type.defaultProps;
		          for (propName in defaultProps) {
		            if (props[propName] === undefined) {
		              props[propName] = defaultProps[propName];
		            }
		          }
		        }
		        if (key || ref) {
		          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
		          if (key) {
		            defineKeyPropWarningGetter(props, displayName);
		          }
		          if (ref) {
		            defineRefPropWarningGetter(props, displayName);
		          }
		        }
		        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
		      }
		    }
		    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
		    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
		    function setCurrentlyValidatingElement$1(element) {
		      {
		        if (element) {
		          var owner = element._owner;
		          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
		          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
		        } else {
		          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
		        }
		      }
		    }
		    var propTypesMisspellWarningShown;
		    {
		      propTypesMisspellWarningShown = false;
		    }
		    /**
		     * Verifies the object is a ReactElement.
		     * See https://reactjs.org/docs/react-api.html#isvalidelement
		     * @param {?object} object
		     * @return {boolean} True if `object` is a ReactElement.
		     * @final
		     */

		    function isValidElement(object) {
		      {
		        return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
		      }
		    }
		    function getDeclarationErrorAddendum() {
		      {
		        if (ReactCurrentOwner$1.current) {
		          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
		          if (name) {
		            return '\n\nCheck the render method of `' + name + '`.';
		          }
		        }
		        return '';
		      }
		    }
		    function getSourceInfoErrorAddendum(source) {
		      {
		        if (source !== undefined) {
		          var fileName = source.fileName.replace(/^.*[\\\/]/, '');
		          var lineNumber = source.lineNumber;
		          return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
		        }
		        return '';
		      }
		    }
		    /**
		     * Warn if there's no key explicitly set on dynamic arrays of children or
		     * object keys are not valid. This allows us to keep track of children between
		     * updates.
		     */

		    var ownerHasKeyUseWarning = {};
		    function getCurrentComponentErrorInfo(parentType) {
		      {
		        var info = getDeclarationErrorAddendum();
		        if (!info) {
		          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
		          if (parentName) {
		            info = "\n\nCheck the top-level render call using <" + parentName + ">.";
		          }
		        }
		        return info;
		      }
		    }
		    /**
		     * Warn if the element doesn't have an explicit key assigned to it.
		     * This element is in an array. The array could grow and shrink or be
		     * reordered. All children that haven't already been validated are required to
		     * have a "key" property assigned to it. Error statuses are cached so a warning
		     * will only be shown once.
		     *
		     * @internal
		     * @param {ReactElement} element Element that requires a key.
		     * @param {*} parentType element's parent's type.
		     */

		    function validateExplicitKey(element, parentType) {
		      {
		        if (!element._store || element._store.validated || element.key != null) {
		          return;
		        }
		        element._store.validated = true;
		        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
		        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
		          return;
		        }
		        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
		        // property, it may be the creator of the child that's responsible for
		        // assigning it a key.

		        var childOwner = '';
		        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
		          // Give the component that originally created this child.
		          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
		        }
		        setCurrentlyValidatingElement$1(element);
		        error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
		        setCurrentlyValidatingElement$1(null);
		      }
		    }
		    /**
		     * Ensure that every element either is passed in a static location, in an
		     * array with an explicit keys property defined, or in an object literal
		     * with valid key property.
		     *
		     * @internal
		     * @param {ReactNode} node Statically passed child of any type.
		     * @param {*} parentType node's parent's type.
		     */

		    function validateChildKeys(node, parentType) {
		      {
		        if (typeof node !== 'object') {
		          return;
		        }
		        if (isArray(node)) {
		          for (var i = 0; i < node.length; i++) {
		            var child = node[i];
		            if (isValidElement(child)) {
		              validateExplicitKey(child, parentType);
		            }
		          }
		        } else if (isValidElement(node)) {
		          // This element was passed in a valid location.
		          if (node._store) {
		            node._store.validated = true;
		          }
		        } else if (node) {
		          var iteratorFn = getIteratorFn(node);
		          if (typeof iteratorFn === 'function') {
		            // Entry iterators used to provide implicit keys,
		            // but now we print a separate warning for them later.
		            if (iteratorFn !== node.entries) {
		              var iterator = iteratorFn.call(node);
		              var step;
		              while (!(step = iterator.next()).done) {
		                if (isValidElement(step.value)) {
		                  validateExplicitKey(step.value, parentType);
		                }
		              }
		            }
		          }
		        }
		      }
		    }
		    /**
		     * Given an element, validate that its props follow the propTypes definition,
		     * provided by the type.
		     *
		     * @param {ReactElement} element
		     */

		    function validatePropTypes(element) {
		      {
		        var type = element.type;
		        if (type === null || type === undefined || typeof type === 'string') {
		          return;
		        }
		        var propTypes;
		        if (typeof type === 'function') {
		          propTypes = type.propTypes;
		        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||
		        // Note: Memo only checks outer props here.
		        // Inner props are checked in the reconciler.
		        type.$$typeof === REACT_MEMO_TYPE)) {
		          propTypes = type.propTypes;
		        } else {
		          return;
		        }
		        if (propTypes) {
		          // Intentionally inside to avoid triggering lazy initializers:
		          var name = getComponentNameFromType(type);
		          checkPropTypes(propTypes, element.props, 'prop', name, element);
		        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
		          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

		          var _name = getComponentNameFromType(type);
		          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
		        }
		        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
		          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
		        }
		      }
		    }
		    /**
		     * Given a fragment, validate that it can only be provided with fragment props
		     * @param {ReactElement} fragment
		     */

		    function validateFragmentProps(fragment) {
		      {
		        var keys = Object.keys(fragment.props);
		        for (var i = 0; i < keys.length; i++) {
		          var key = keys[i];
		          if (key !== 'children' && key !== 'key') {
		            setCurrentlyValidatingElement$1(fragment);
		            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
		            setCurrentlyValidatingElement$1(null);
		            break;
		          }
		        }
		        if (fragment.ref !== null) {
		          setCurrentlyValidatingElement$1(fragment);
		          error('Invalid attribute `ref` supplied to `React.Fragment`.');
		          setCurrentlyValidatingElement$1(null);
		        }
		      }
		    }
		    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
		      {
		        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
		        // succeed and there will likely be errors in render.

		        if (!validType) {
		          var info = '';
		          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
		            info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
		          }
		          var sourceInfo = getSourceInfoErrorAddendum(source);
		          if (sourceInfo) {
		            info += sourceInfo;
		          } else {
		            info += getDeclarationErrorAddendum();
		          }
		          var typeString;
		          if (type === null) {
		            typeString = 'null';
		          } else if (isArray(type)) {
		            typeString = 'array';
		          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
		            typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
		            info = ' Did you accidentally export a JSX literal instead of a component?';
		          } else {
		            typeString = typeof type;
		          }
		          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
		        }
		        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
		        // TODO: Drop this when these are no longer allowed as the type argument.

		        if (element == null) {
		          return element;
		        } // Skip key warning if the type isn't valid since our key validation logic
		        // doesn't expect a non-string/function type and can throw confusing errors.
		        // We don't want exception behavior to differ between dev and prod.
		        // (Rendering will throw with a helpful message and as soon as the type is
		        // fixed, the key warnings will appear.)

		        if (validType) {
		          var children = props.children;
		          if (children !== undefined) {
		            if (isStaticChildren) {
		              if (isArray(children)) {
		                for (var i = 0; i < children.length; i++) {
		                  validateChildKeys(children[i], type);
		                }
		                if (Object.freeze) {
		                  Object.freeze(children);
		                }
		              } else {
		                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
		              }
		            } else {
		              validateChildKeys(children, type);
		            }
		          }
		        }
		        if (type === REACT_FRAGMENT_TYPE) {
		          validateFragmentProps(element);
		        } else {
		          validatePropTypes(element);
		        }
		        return element;
		      }
		    } // These two functions exist to still get child warnings in dev
		    // even with the prod transform. This means that jsxDEV is purely
		    // opt-in behavior for better messages but that we won't stop
		    // giving you warnings if you use production apis.

		    function jsxWithValidationStatic(type, props, key) {
		      {
		        return jsxWithValidation(type, props, key, true);
		      }
		    }
		    function jsxWithValidationDynamic(type, props, key) {
		      {
		        return jsxWithValidation(type, props, key, false);
		      }
		    }
		    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.
		    // for now we can ship identical prod functions

		    var jsxs = jsxWithValidationStatic;
		    reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
		    reactJsxRuntime_development.jsx = jsx;
		    reactJsxRuntime_development.jsxs = jsxs;
		  })();
		}
		return reactJsxRuntime_development;
	}

	var hasRequiredJsxRuntime;

	function requireJsxRuntime () {
		if (hasRequiredJsxRuntime) return jsxRuntime.exports;
		hasRequiredJsxRuntime = 1;

		if (process.env.NODE_ENV === 'production') {
		  jsxRuntime.exports = requireReactJsxRuntime_production_min();
		} else {
		  jsxRuntime.exports = requireReactJsxRuntime_development();
		}
		return jsxRuntime.exports;
	}

	var jsxRuntimeExports = requireJsxRuntime();

	/**
	 * @public
	 */
	const PresenceContext = reactExports.createContext(null);

	/**
	 * When a component is the child of `AnimatePresence`, it can use `usePresence`
	 * to access information about whether it's still present in the React tree.
	 *
	 * ```jsx
	 * import { usePresence } from "framer-motion"
	 *
	 * export const Component = () => {
	 *   const [isPresent, safeToRemove] = usePresence()
	 *
	 *   useEffect(() => {
	 *     !isPresent && setTimeout(safeToRemove, 1000)
	 *   }, [isPresent])
	 *
	 *   return <div />
	 * }
	 * ```
	 *
	 * If `isPresent` is `false`, it means that a component has been removed the tree, but
	 * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
	 *
	 * @public
	 */
	function usePresence() {
	    const context = reactExports.useContext(PresenceContext);
	    if (context === null)
	        return [true, null];
	    const { isPresent, onExitComplete, register } = context;
	    // It's safe to call the following hooks conditionally (after an early return) because the context will always
	    // either be null or non-null for the lifespan of the component.
	    const id = reactExports.useId();
	    reactExports.useEffect(() => register(id), []);
	    const safeToRemove = reactExports.useCallback(() => onExitComplete && onExitComplete(id), [id, onExitComplete]);
	    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
	}

	const LayoutGroupContext = reactExports.createContext({});

	/**
	 * Internal, exported only for usage in Framer
	 */
	const SwitchLayoutGroupContext = reactExports.createContext({});

	/**
	 * This should only ever be modified on the client otherwise it'll
	 * persist through server requests. If we need instanced states we
	 * could lazy-init via root.
	 */
	const globalProjectionState = {
	    /**
	     * Global flag as to whether the tree has animated since the last time
	     * we resized the window
	     */
	    hasAnimatedSinceResize: true,
	    /**
	     * We set this to true once, on the first update. Any nodes added to the tree beyond that
	     * update will be given a `data-projection-id` attribute.
	     */
	    hasEverUpdated: false,
	};

	function pixelsToPercent(pixels, axis) {
	    if (axis.max === axis.min)
	        return 0;
	    return (pixels / (axis.max - axis.min)) * 100;
	}
	/**
	 * We always correct borderRadius as a percentage rather than pixels to reduce paints.
	 * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
	 * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
	 * borderRadius in both states. If we animate between the two in pixels that will trigger
	 * a paint each time. If we animate between the two in percentage we'll avoid a paint.
	 */
	const correctBorderRadius = {
	    correct: (latest, node) => {
	        if (!node.target)
	            return latest;
	        /**
	         * If latest is a string, if it's a percentage we can return immediately as it's
	         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
	         */
	        if (typeof latest === "string") {
	            if (px.test(latest)) {
	                latest = parseFloat(latest);
	            }
	            else {
	                return latest;
	            }
	        }
	        /**
	         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
	         * pixel value as a percentage of each axis
	         */
	        const x = pixelsToPercent(latest, node.target.x);
	        const y = pixelsToPercent(latest, node.target.y);
	        return `${x}% ${y}%`;
	    },
	};

	const correctBoxShadow = {
	    correct: (latest, { treeScale, projectionDelta }) => {
	        const original = latest;
	        const shadow = complex.parse(latest);
	        // TODO: Doesn't support multiple shadows
	        if (shadow.length > 5)
	            return original;
	        const template = complex.createTransformer(latest);
	        const offset = typeof shadow[0] !== "number" ? 1 : 0;
	        // Calculate the overall context scale
	        const xScale = projectionDelta.x.scale * treeScale.x;
	        const yScale = projectionDelta.y.scale * treeScale.y;
	        shadow[0 + offset] /= xScale;
	        shadow[1 + offset] /= yScale;
	        /**
	         * Ideally we'd correct x and y scales individually, but because blur and
	         * spread apply to both we have to take a scale average and apply that instead.
	         * We could potentially improve the outcome of this by incorporating the ratio between
	         * the two scales.
	         */
	        const averageScale = mixNumber$1(xScale, yScale, 0.5);
	        // Blur
	        if (typeof shadow[2 + offset] === "number")
	            shadow[2 + offset] /= averageScale;
	        // Spread
	        if (typeof shadow[3 + offset] === "number")
	            shadow[3 + offset] /= averageScale;
	        return template(shadow);
	    },
	};

	const scaleCorrectors = {};
	function addScaleCorrector(correctors) {
	    Object.assign(scaleCorrectors, correctors);
	}

	const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

	class MeasureLayoutWithContext extends reactExports.Component {
	    /**
	     * This only mounts projection nodes for components that
	     * need measuring, we might want to do it for all components
	     * in order to incorporate transforms
	     */
	    componentDidMount() {
	        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
	        const { projection } = visualElement;
	        addScaleCorrector(defaultScaleCorrectors);
	        if (projection) {
	            if (layoutGroup.group)
	                layoutGroup.group.add(projection);
	            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
	                switchLayoutGroup.register(projection);
	            }
	            projection.root.didUpdate();
	            projection.addEventListener("animationComplete", () => {
	                this.safeToRemove();
	            });
	            projection.setOptions({
	                ...projection.options,
	                onExitComplete: () => this.safeToRemove(),
	            });
	        }
	        globalProjectionState.hasEverUpdated = true;
	    }
	    getSnapshotBeforeUpdate(prevProps) {
	        const { layoutDependency, visualElement, drag, isPresent } = this.props;
	        const projection = visualElement.projection;
	        if (!projection)
	            return null;
	        /**
	         * TODO: We use this data in relegate to determine whether to
	         * promote a previous element. There's no guarantee its presence data
	         * will have updated by this point - if a bug like this arises it will
	         * have to be that we markForRelegation and then find a new lead some other way,
	         * perhaps in didUpdate
	         */
	        projection.isPresent = isPresent;
	        if (drag ||
	            prevProps.layoutDependency !== layoutDependency ||
	            layoutDependency === undefined) {
	            projection.willUpdate();
	        }
	        else {
	            this.safeToRemove();
	        }
	        if (prevProps.isPresent !== isPresent) {
	            if (isPresent) {
	                projection.promote();
	            }
	            else if (!projection.relegate()) {
	                /**
	                 * If there's another stack member taking over from this one,
	                 * it's in charge of the exit animation and therefore should
	                 * be in charge of the safe to remove. Otherwise we call it here.
	                 */
	                frame.postRender(() => {
	                    const stack = projection.getStack();
	                    if (!stack || !stack.members.length) {
	                        this.safeToRemove();
	                    }
	                });
	            }
	        }
	        return null;
	    }
	    componentDidUpdate() {
	        const { projection } = this.props.visualElement;
	        if (projection) {
	            projection.root.didUpdate();
	            microtask.postRender(() => {
	                if (!projection.currentAnimation && projection.isLead()) {
	                    this.safeToRemove();
	                }
	            });
	        }
	    }
	    componentWillUnmount() {
	        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;
	        const { projection } = visualElement;
	        if (projection) {
	            projection.scheduleCheckAfterUnmount();
	            if (layoutGroup && layoutGroup.group)
	                layoutGroup.group.remove(projection);
	            if (promoteContext && promoteContext.deregister)
	                promoteContext.deregister(projection);
	        }
	    }
	    safeToRemove() {
	        const { safeToRemove } = this.props;
	        safeToRemove && safeToRemove();
	    }
	    render() {
	        return null;
	    }
	}
	function MeasureLayout(props) {
	    const [isPresent, safeToRemove] = usePresence();
	    const layoutGroup = reactExports.useContext(LayoutGroupContext);
	    return (jsxRuntimeExports.jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));
	}
	const defaultScaleCorrectors = {
	    borderRadius: {
	        ...correctBorderRadius,
	        applyTo: [
	            "borderTopLeftRadius",
	            "borderTopRightRadius",
	            "borderBottomLeftRadius",
	            "borderBottomRightRadius",
	        ],
	    },
	    borderTopLeftRadius: correctBorderRadius,
	    borderTopRightRadius: correctBorderRadius,
	    borderBottomLeftRadius: correctBorderRadius,
	    borderBottomRightRadius: correctBorderRadius,
	    boxShadow: correctBoxShadow,
	};

	const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
	const numBorders = borders.length;
	const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
	const isPx = (value) => typeof value === "number" || px.test(value);
	function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
	    if (shouldCrossfadeOpacity) {
	        target.opacity = mixNumber$1(0, 
	        // TODO Reinstate this if only child
	        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));
	        target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));
	    }
	    else if (isOnlyMember) {
	        target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);
	    }
	    /**
	     * Mix border radius
	     */
	    for (let i = 0; i < numBorders; i++) {
	        const borderLabel = `border${borders[i]}Radius`;
	        let followRadius = getRadius(follow, borderLabel);
	        let leadRadius = getRadius(lead, borderLabel);
	        if (followRadius === undefined && leadRadius === undefined)
	            continue;
	        followRadius || (followRadius = 0);
	        leadRadius || (leadRadius = 0);
	        const canMix = followRadius === 0 ||
	            leadRadius === 0 ||
	            isPx(followRadius) === isPx(leadRadius);
	        if (canMix) {
	            target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);
	            if (percent.test(leadRadius) || percent.test(followRadius)) {
	                target[borderLabel] += "%";
	            }
	        }
	        else {
	            target[borderLabel] = leadRadius;
	        }
	    }
	    /**
	     * Mix rotation
	     */
	    if (follow.rotate || lead.rotate) {
	        target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);
	    }
	}
	function getRadius(values, radiusName) {
	    return values[radiusName] !== undefined
	        ? values[radiusName]
	        : values.borderRadius;
	}
	// /**
	//  * We only want to mix the background color if there's a follow element
	//  * that we're not crossfading opacity between. For instance with switch
	//  * AnimateSharedLayout animations, this helps the illusion of a continuous
	//  * element being animated but also cuts down on the number of paints triggered
	//  * for elements where opacity is doing that work for us.
	//  */
	// if (
	//     !hasFollowElement &&
	//     latestLeadValues.backgroundColor &&
	//     latestFollowValues.backgroundColor
	// ) {
	//     /**
	//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
	//      * We could probably create a mixer that runs at the start of the animation but
	//      * the idea behind the crossfader is that it runs dynamically between two potentially
	//      * changing targets (ie opacity or borderRadius may be animating independently via variants)
	//      */
	//     leadState.backgroundColor = followState.backgroundColor = mixColor(
	//         latestFollowValues.backgroundColor as string,
	//         latestLeadValues.backgroundColor as string
	//     )(p)
	// }
	const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
	const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);
	function compress(min, max, easing) {
	    return (p) => {
	        // Could replace ifs with clamp
	        if (p < min)
	            return 0;
	        if (p > max)
	            return 1;
	        return easing(progress(min, max, p));
	    };
	}

	/**
	 * Reset an axis to the provided origin box.
	 *
	 * This is a mutative operation.
	 */
	function copyAxisInto(axis, originAxis) {
	    axis.min = originAxis.min;
	    axis.max = originAxis.max;
	}
	/**
	 * Reset a box to the provided origin box.
	 *
	 * This is a mutative operation.
	 */
	function copyBoxInto(box, originBox) {
	    copyAxisInto(box.x, originBox.x);
	    copyAxisInto(box.y, originBox.y);
	}
	/**
	 * Reset a delta to the provided origin box.
	 *
	 * This is a mutative operation.
	 */
	function copyAxisDeltaInto(delta, originDelta) {
	    delta.translate = originDelta.translate;
	    delta.scale = originDelta.scale;
	    delta.originPoint = originDelta.originPoint;
	    delta.origin = originDelta.origin;
	}

	/**
	 * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
	 */
	function removePointDelta(point, translate, scale, originPoint, boxScale) {
	    point -= translate;
	    point = scalePoint(point, 1 / scale, originPoint);
	    if (boxScale !== undefined) {
	        point = scalePoint(point, 1 / boxScale, originPoint);
	    }
	    return point;
	}
	/**
	 * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
	 */
	function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
	    if (percent.test(translate)) {
	        translate = parseFloat(translate);
	        const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
	        translate = relativeProgress - sourceAxis.min;
	    }
	    if (typeof translate !== "number")
	        return;
	    let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
	    if (axis === originAxis)
	        originPoint -= translate;
	    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
	    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
	}
	/**
	 * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
	 * and acts as a bridge between motion values and removeAxisDelta
	 */
	function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
	    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
	}
	/**
	 * The names of the motion values we want to apply as translation, scale and origin.
	 */
	const xKeys = ["x", "scaleX", "originX"];
	const yKeys = ["y", "scaleY", "originY"];
	/**
	 * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
	 * and acts as a bridge between motion values and removeAxisDelta
	 */
	function removeBoxTransforms(box, transforms, originBox, sourceBox) {
	    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);
	    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);
	}

	function isAxisDeltaZero(delta) {
	    return delta.translate === 0 && delta.scale === 1;
	}
	function isDeltaZero(delta) {
	    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
	}
	function axisEquals(a, b) {
	    return a.min === b.min && a.max === b.max;
	}
	function boxEquals(a, b) {
	    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
	}
	function axisEqualsRounded(a, b) {
	    return (Math.round(a.min) === Math.round(b.min) &&
	        Math.round(a.max) === Math.round(b.max));
	}
	function boxEqualsRounded(a, b) {
	    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
	}
	function aspectRatio(box) {
	    return calcLength(box.x) / calcLength(box.y);
	}
	function axisDeltaEquals(a, b) {
	    return (a.translate === b.translate &&
	        a.scale === b.scale &&
	        a.originPoint === b.originPoint);
	}

	class NodeStack {
	    constructor() {
	        this.members = [];
	    }
	    add(node) {
	        addUniqueItem(this.members, node);
	        node.scheduleRender();
	    }
	    remove(node) {
	        removeItem(this.members, node);
	        if (node === this.prevLead) {
	            this.prevLead = undefined;
	        }
	        if (node === this.lead) {
	            const prevLead = this.members[this.members.length - 1];
	            if (prevLead) {
	                this.promote(prevLead);
	            }
	        }
	    }
	    relegate(node) {
	        const indexOfNode = this.members.findIndex((member) => node === member);
	        if (indexOfNode === 0)
	            return false;
	        /**
	         * Find the next projection node that is present
	         */
	        let prevLead;
	        for (let i = indexOfNode; i >= 0; i--) {
	            const member = this.members[i];
	            if (member.isPresent !== false) {
	                prevLead = member;
	                break;
	            }
	        }
	        if (prevLead) {
	            this.promote(prevLead);
	            return true;
	        }
	        else {
	            return false;
	        }
	    }
	    promote(node, preserveFollowOpacity) {
	        const prevLead = this.lead;
	        if (node === prevLead)
	            return;
	        this.prevLead = prevLead;
	        this.lead = node;
	        node.show();
	        if (prevLead) {
	            prevLead.instance && prevLead.scheduleRender();
	            node.scheduleRender();
	            node.resumeFrom = prevLead;
	            if (preserveFollowOpacity) {
	                node.resumeFrom.preserveOpacity = true;
	            }
	            if (prevLead.snapshot) {
	                node.snapshot = prevLead.snapshot;
	                node.snapshot.latestValues =
	                    prevLead.animationValues || prevLead.latestValues;
	            }
	            if (node.root && node.root.isUpdating) {
	                node.isLayoutDirty = true;
	            }
	            const { crossfade } = node.options;
	            if (crossfade === false) {
	                prevLead.hide();
	            }
	            /**
	             * TODO:
	             *   - Test border radius when previous node was deleted
	             *   - boxShadow mixing
	             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
	             *   - Shared between element A in transformed container and element B (transform stays the same or changes)
	             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
	             * ---
	             *   - Crossfade opacity of root nodes
	             *   - layoutId changes after animation
	             *   - layoutId changes mid animation
	             */
	        }
	    }
	    exitAnimationComplete() {
	        this.members.forEach((node) => {
	            const { options, resumingFrom } = node;
	            options.onExitComplete && options.onExitComplete();
	            if (resumingFrom) {
	                resumingFrom.options.onExitComplete &&
	                    resumingFrom.options.onExitComplete();
	            }
	        });
	    }
	    scheduleRender() {
	        this.members.forEach((node) => {
	            node.instance && node.scheduleRender(false);
	        });
	    }
	    /**
	     * Clear any leads that have been removed this render to prevent them from being
	     * used in future animations and to prevent memory leaks
	     */
	    removeLeadSnapshot() {
	        if (this.lead && this.lead.snapshot) {
	            this.lead.snapshot = undefined;
	        }
	    }
	}

	function buildProjectionTransform(delta, treeScale, latestTransform) {
	    let transform = "";
	    /**
	     * The translations we use to calculate are always relative to the viewport coordinate space.
	     * But when we apply scales, we also scale the coordinate space of an element and its children.
	     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
	     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
	     */
	    const xTranslate = delta.x.translate / treeScale.x;
	    const yTranslate = delta.y.translate / treeScale.y;
	    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
	    if (xTranslate || yTranslate || zTranslate) {
	        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
	    }
	    /**
	     * Apply scale correction for the tree transform.
	     * This will apply scale to the screen-orientated axes.
	     */
	    if (treeScale.x !== 1 || treeScale.y !== 1) {
	        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
	    }
	    if (latestTransform) {
	        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;
	        if (transformPerspective)
	            transform = `perspective(${transformPerspective}px) ${transform}`;
	        if (rotate)
	            transform += `rotate(${rotate}deg) `;
	        if (rotateX)
	            transform += `rotateX(${rotateX}deg) `;
	        if (rotateY)
	            transform += `rotateY(${rotateY}deg) `;
	        if (skewX)
	            transform += `skewX(${skewX}deg) `;
	        if (skewY)
	            transform += `skewY(${skewY}deg) `;
	    }
	    /**
	     * Apply scale to match the size of the element to the size we want it.
	     * This will apply scale to the element-orientated axes.
	     */
	    const elementScaleX = delta.x.scale * treeScale.x;
	    const elementScaleY = delta.y.scale * treeScale.y;
	    if (elementScaleX !== 1 || elementScaleY !== 1) {
	        transform += `scale(${elementScaleX}, ${elementScaleY})`;
	    }
	    return transform || "none";
	}

	const compareByDepth = (a, b) => a.depth - b.depth;

	class FlatTree {
	    constructor() {
	        this.children = [];
	        this.isDirty = false;
	    }
	    add(child) {
	        addUniqueItem(this.children, child);
	        this.isDirty = true;
	    }
	    remove(child) {
	        removeItem(this.children, child);
	        this.isDirty = true;
	    }
	    forEach(callback) {
	        this.isDirty && this.children.sort(compareByDepth);
	        this.isDirty = false;
	        this.children.forEach(callback);
	    }
	}

	/**
	 * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
	 *
	 * TODO: Remove and move to library
	 */
	function resolveMotionValue(value) {
	    const unwrappedValue = isMotionValue(value) ? value.get() : value;
	    return isCustomValue(unwrappedValue)
	        ? unwrappedValue.toValue()
	        : unwrappedValue;
	}

	/**
	 * Timeout defined in ms
	 */
	function delay(callback, timeout) {
	    const start = time.now();
	    const checkElapsed = ({ timestamp }) => {
	        const elapsed = timestamp - start;
	        if (elapsed >= timeout) {
	            cancelFrame(checkElapsed);
	            callback(elapsed - timeout);
	        }
	    };
	    frame.read(checkElapsed, true);
	    return () => cancelFrame(checkElapsed);
	}

	function isSVGElement(element) {
	    return element instanceof SVGElement && element.tagName !== "svg";
	}

	function animateSingleValue(value, keyframes, options) {
	    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
	    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
	    return motionValue$1.animation;
	}

	const metrics = {
	    type: "projectionFrame",
	    totalNodes: 0,
	    resolvedTargetDeltas: 0,
	    recalculatedProjection: 0,
	};
	const isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;
	const transformAxes = ["", "X", "Y", "Z"];
	const hiddenVisibility = { visibility: "hidden" };
	/**
	 * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
	 * which has a noticeable difference in spring animations
	 */
	const animationTarget = 1000;
	let id = 0;
	function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
	    const { latestValues } = visualElement;
	    // Record the distorting transform and then temporarily set it to 0
	    if (latestValues[key]) {
	        values[key] = latestValues[key];
	        visualElement.setStaticValue(key, 0);
	        if (sharedAnimationValues) {
	            sharedAnimationValues[key] = 0;
	        }
	    }
	}
	function cancelTreeOptimisedTransformAnimations(projectionNode) {
	    projectionNode.hasCheckedOptimisedAppear = true;
	    if (projectionNode.root === projectionNode)
	        return;
	    const { visualElement } = projectionNode.options;
	    if (!visualElement)
	        return;
	    const appearId = getOptimisedAppearId(visualElement);
	    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
	        const { layout, layoutId } = projectionNode.options;
	        window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout || layoutId));
	    }
	    const { parent } = projectionNode;
	    if (parent && !parent.hasCheckedOptimisedAppear) {
	        cancelTreeOptimisedTransformAnimations(parent);
	    }
	}
	function createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {
	    return class ProjectionNode {
	        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
	            /**
	             * A unique ID generated for every projection node.
	             */
	            this.id = id++;
	            /**
	             * An id that represents a unique session instigated by startUpdate.
	             */
	            this.animationId = 0;
	            /**
	             * A Set containing all this component's children. This is used to iterate
	             * through the children.
	             *
	             * TODO: This could be faster to iterate as a flat array stored on the root node.
	             */
	            this.children = new Set();
	            /**
	             * Options for the node. We use this to configure what kind of layout animations
	             * we should perform (if any).
	             */
	            this.options = {};
	            /**
	             * We use this to detect when its safe to shut down part of a projection tree.
	             * We have to keep projecting children for scale correction and relative projection
	             * until all their parents stop performing layout animations.
	             */
	            this.isTreeAnimating = false;
	            this.isAnimationBlocked = false;
	            /**
	             * Flag to true if we think this layout has been changed. We can't always know this,
	             * currently we set it to true every time a component renders, or if it has a layoutDependency
	             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
	             * and if one node is dirtied, they all are.
	             */
	            this.isLayoutDirty = false;
	            /**
	             * Flag to true if we think the projection calculations for this node needs
	             * recalculating as a result of an updated transform or layout animation.
	             */
	            this.isProjectionDirty = false;
	            /**
	             * Flag to true if the layout *or* transform has changed. This then gets propagated
	             * throughout the projection tree, forcing any element below to recalculate on the next frame.
	             */
	            this.isSharedProjectionDirty = false;
	            /**
	             * Flag transform dirty. This gets propagated throughout the whole tree but is only
	             * respected by shared nodes.
	             */
	            this.isTransformDirty = false;
	            /**
	             * Block layout updates for instant layout transitions throughout the tree.
	             */
	            this.updateManuallyBlocked = false;
	            this.updateBlockedByResize = false;
	            /**
	             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
	             * call.
	             */
	            this.isUpdating = false;
	            /**
	             * If this is an SVG element we currently disable projection transforms
	             */
	            this.isSVG = false;
	            /**
	             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
	             * its projection styles.
	             */
	            this.needsReset = false;
	            /**
	             * Flags whether this node should have its transform reset prior to measuring.
	             */
	            this.shouldResetTransform = false;
	            /**
	             * Store whether this node has been checked for optimised appear animations. As
	             * effects fire bottom-up, and we want to look up the tree for appear animations,
	             * this makes sure we only check each path once, stopping at nodes that
	             * have already been checked.
	             */
	            this.hasCheckedOptimisedAppear = false;
	            /**
	             * An object representing the calculated contextual/accumulated/tree scale.
	             * This will be used to scale calculcated projection transforms, as these are
	             * calculated in screen-space but need to be scaled for elements to layoutly
	             * make it to their calculated destinations.
	             *
	             * TODO: Lazy-init
	             */
	            this.treeScale = { x: 1, y: 1 };
	            /**
	             *
	             */
	            this.eventHandlers = new Map();
	            this.hasTreeAnimated = false;
	            // Note: Currently only running on root node
	            this.updateScheduled = false;
	            this.scheduleUpdate = () => this.update();
	            this.projectionUpdateScheduled = false;
	            this.checkUpdateFailed = () => {
	                if (this.isUpdating) {
	                    this.isUpdating = false;
	                    this.clearAllSnapshots();
	                }
	            };
	            /**
	             * This is a multi-step process as shared nodes might be of different depths. Nodes
	             * are sorted by depth order, so we need to resolve the entire tree before moving to
	             * the next step.
	             */
	            this.updateProjection = () => {
	                this.projectionUpdateScheduled = false;
	                /**
	                 * Reset debug counts. Manually resetting rather than creating a new
	                 * object each frame.
	                 */
	                if (isDebug) {
	                    metrics.totalNodes =
	                        metrics.resolvedTargetDeltas =
	                            metrics.recalculatedProjection =
	                                0;
	                }
	                this.nodes.forEach(propagateDirtyNodes);
	                this.nodes.forEach(resolveTargetDelta);
	                this.nodes.forEach(calcProjection);
	                this.nodes.forEach(cleanDirtyNodes);
	                if (isDebug) {
	                    window.MotionDebug.record(metrics);
	                }
	            };
	            /**
	             * Frame calculations
	             */
	            this.resolvedRelativeTargetAt = 0.0;
	            this.hasProjected = false;
	            this.isVisible = true;
	            this.animationProgress = 0;
	            /**
	             * Shared layout
	             */
	            // TODO Only running on root node
	            this.sharedNodes = new Map();
	            this.latestValues = latestValues;
	            this.root = parent ? parent.root || parent : this;
	            this.path = parent ? [...parent.path, parent] : [];
	            this.parent = parent;
	            this.depth = parent ? parent.depth + 1 : 0;
	            for (let i = 0; i < this.path.length; i++) {
	                this.path[i].shouldResetTransform = true;
	            }
	            if (this.root === this)
	                this.nodes = new FlatTree();
	        }
	        addEventListener(name, handler) {
	            if (!this.eventHandlers.has(name)) {
	                this.eventHandlers.set(name, new SubscriptionManager());
	            }
	            return this.eventHandlers.get(name).add(handler);
	        }
	        notifyListeners(name, ...args) {
	            const subscriptionManager = this.eventHandlers.get(name);
	            subscriptionManager && subscriptionManager.notify(...args);
	        }
	        hasListeners(name) {
	            return this.eventHandlers.has(name);
	        }
	        /**
	         * Lifecycles
	         */
	        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
	            if (this.instance)
	                return;
	            this.isSVG = isSVGElement(instance);
	            this.instance = instance;
	            const { layoutId, layout, visualElement } = this.options;
	            if (visualElement && !visualElement.current) {
	                visualElement.mount(instance);
	            }
	            this.root.nodes.add(this);
	            this.parent && this.parent.children.add(this);
	            if (isLayoutDirty && (layout || layoutId)) {
	                this.isLayoutDirty = true;
	            }
	            if (attachResizeListener) {
	                let cancelDelay;
	                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);
	                attachResizeListener(instance, () => {
	                    this.root.updateBlockedByResize = true;
	                    cancelDelay && cancelDelay();
	                    cancelDelay = delay(resizeUnblockUpdate, 250);
	                    if (globalProjectionState.hasAnimatedSinceResize) {
	                        globalProjectionState.hasAnimatedSinceResize = false;
	                        this.nodes.forEach(finishAnimation);
	                    }
	                });
	            }
	            if (layoutId) {
	                this.root.registerSharedNode(layoutId, this);
	            }
	            // Only register the handler if it requires layout animation
	            if (this.options.animate !== false &&
	                visualElement &&
	                (layoutId || layout)) {
	                this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, }) => {
	                    if (this.isTreeAnimationBlocked()) {
	                        this.target = undefined;
	                        this.relativeTarget = undefined;
	                        return;
	                    }
	                    // TODO: Check here if an animation exists
	                    const layoutTransition = this.options.transition ||
	                        visualElement.getDefaultTransition() ||
	                        defaultLayoutTransition;
	                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();
	                    /**
	                     * The target layout of the element might stay the same,
	                     * but its position relative to its parent has changed.
	                     */
	                    const targetChanged = !this.targetLayout ||
	                        !boxEqualsRounded(this.targetLayout, newLayout) ||
	                        hasRelativeTargetChanged;
	                    /**
	                     * If the layout hasn't seemed to have changed, it might be that the
	                     * element is visually in the same place in the document but its position
	                     * relative to its parent has indeed changed. So here we check for that.
	                     */
	                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
	                    if (this.options.layoutRoot ||
	                        (this.resumeFrom && this.resumeFrom.instance) ||
	                        hasOnlyRelativeTargetChanged ||
	                        (hasLayoutChanged &&
	                            (targetChanged || !this.currentAnimation))) {
	                        if (this.resumeFrom) {
	                            this.resumingFrom = this.resumeFrom;
	                            this.resumingFrom.resumingFrom = undefined;
	                        }
	                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
	                        const animationOptions = {
	                            ...getValueTransition(layoutTransition, "layout"),
	                            onPlay: onLayoutAnimationStart,
	                            onComplete: onLayoutAnimationComplete,
	                        };
	                        if (visualElement.shouldReduceMotion ||
	                            this.options.layoutRoot) {
	                            animationOptions.delay = 0;
	                            animationOptions.type = false;
	                        }
	                        this.startAnimation(animationOptions);
	                    }
	                    else {
	                        /**
	                         * If the layout hasn't changed and we have an animation that hasn't started yet,
	                         * finish it immediately. Otherwise it will be animating from a location
	                         * that was probably never commited to screen and look like a jumpy box.
	                         */
	                        if (!hasLayoutChanged) {
	                            finishAnimation(this);
	                        }
	                        if (this.isLead() && this.options.onExitComplete) {
	                            this.options.onExitComplete();
	                        }
	                    }
	                    this.targetLayout = newLayout;
	                });
	            }
	        }
	        unmount() {
	            this.options.layoutId && this.willUpdate();
	            this.root.nodes.remove(this);
	            const stack = this.getStack();
	            stack && stack.remove(this);
	            this.parent && this.parent.children.delete(this);
	            this.instance = undefined;
	            cancelFrame(this.updateProjection);
	        }
	        // only on the root
	        blockUpdate() {
	            this.updateManuallyBlocked = true;
	        }
	        unblockUpdate() {
	            this.updateManuallyBlocked = false;
	        }
	        isUpdateBlocked() {
	            return this.updateManuallyBlocked || this.updateBlockedByResize;
	        }
	        isTreeAnimationBlocked() {
	            return (this.isAnimationBlocked ||
	                (this.parent && this.parent.isTreeAnimationBlocked()) ||
	                false);
	        }
	        // Note: currently only running on root node
	        startUpdate() {
	            if (this.isUpdateBlocked())
	                return;
	            this.isUpdating = true;
	            this.nodes && this.nodes.forEach(resetSkewAndRotation);
	            this.animationId++;
	        }
	        getTransformTemplate() {
	            const { visualElement } = this.options;
	            return visualElement && visualElement.getProps().transformTemplate;
	        }
	        willUpdate(shouldNotifyListeners = true) {
	            this.root.hasTreeAnimated = true;
	            if (this.root.isUpdateBlocked()) {
	                this.options.onExitComplete && this.options.onExitComplete();
	                return;
	            }
	            /**
	             * If we're running optimised appear animations then these must be
	             * cancelled before measuring the DOM. This is so we can measure
	             * the true layout of the element rather than the WAAPI animation
	             * which will be unaffected by the resetSkewAndRotate step.
	             *
	             * Note: This is a DOM write. Worst case scenario is this is sandwiched
	             * between other snapshot reads which will cause unnecessary style recalculations.
	             * This has to happen here though, as we don't yet know which nodes will need
	             * snapshots in startUpdate(), but we only want to cancel optimised animations
	             * if a layout animation measurement is actually going to be affected by them.
	             */
	            if (window.MotionCancelOptimisedAnimation &&
	                !this.hasCheckedOptimisedAppear) {
	                cancelTreeOptimisedTransformAnimations(this);
	            }
	            !this.root.isUpdating && this.root.startUpdate();
	            if (this.isLayoutDirty)
	                return;
	            this.isLayoutDirty = true;
	            for (let i = 0; i < this.path.length; i++) {
	                const node = this.path[i];
	                node.shouldResetTransform = true;
	                node.updateScroll("snapshot");
	                if (node.options.layoutRoot) {
	                    node.willUpdate(false);
	                }
	            }
	            const { layoutId, layout } = this.options;
	            if (layoutId === undefined && !layout)
	                return;
	            const transformTemplate = this.getTransformTemplate();
	            this.prevTransformTemplateValue = transformTemplate
	                ? transformTemplate(this.latestValues, "")
	                : undefined;
	            this.updateSnapshot();
	            shouldNotifyListeners && this.notifyListeners("willUpdate");
	        }
	        update() {
	            this.updateScheduled = false;
	            const updateWasBlocked = this.isUpdateBlocked();
	            // When doing an instant transition, we skip the layout update,
	            // but should still clean up the measurements so that the next
	            // snapshot could be taken correctly.
	            if (updateWasBlocked) {
	                this.unblockUpdate();
	                this.clearAllSnapshots();
	                this.nodes.forEach(clearMeasurements);
	                return;
	            }
	            if (!this.isUpdating) {
	                this.nodes.forEach(clearIsLayoutDirty);
	            }
	            this.isUpdating = false;
	            /**
	             * Write
	             */
	            this.nodes.forEach(resetTransformStyle);
	            /**
	             * Read ==================
	             */
	            // Update layout measurements of updated children
	            this.nodes.forEach(updateLayout);
	            /**
	             * Write
	             */
	            // Notify listeners that the layout is updated
	            this.nodes.forEach(notifyLayoutUpdate);
	            this.clearAllSnapshots();
	            /**
	             * Manually flush any pending updates. Ideally
	             * we could leave this to the following requestAnimationFrame but this seems
	             * to leave a flash of incorrectly styled content.
	             */
	            const now = time.now();
	            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
	            frameData.timestamp = now;
	            frameData.isProcessing = true;
	            frameSteps.update.process(frameData);
	            frameSteps.preRender.process(frameData);
	            frameSteps.render.process(frameData);
	            frameData.isProcessing = false;
	        }
	        didUpdate() {
	            if (!this.updateScheduled) {
	                this.updateScheduled = true;
	                microtask.read(this.scheduleUpdate);
	            }
	        }
	        clearAllSnapshots() {
	            this.nodes.forEach(clearSnapshot);
	            this.sharedNodes.forEach(removeLeadSnapshots);
	        }
	        scheduleUpdateProjection() {
	            if (!this.projectionUpdateScheduled) {
	                this.projectionUpdateScheduled = true;
	                frame.preRender(this.updateProjection, false, true);
	            }
	        }
	        scheduleCheckAfterUnmount() {
	            /**
	             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
	             * we manually call didUpdate to give a chance to the siblings to animate.
	             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
	             */
	            frame.postRender(() => {
	                if (this.isLayoutDirty) {
	                    this.root.didUpdate();
	                }
	                else {
	                    this.root.checkUpdateFailed();
	                }
	            });
	        }
	        /**
	         * Update measurements
	         */
	        updateSnapshot() {
	            if (this.snapshot || !this.instance)
	                return;
	            this.snapshot = this.measure();
	        }
	        updateLayout() {
	            if (!this.instance)
	                return;
	            // TODO: Incorporate into a forwarded scroll offset
	            this.updateScroll();
	            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&
	                !this.isLayoutDirty) {
	                return;
	            }
	            /**
	             * When a node is mounted, it simply resumes from the prevLead's
	             * snapshot instead of taking a new one, but the ancestors scroll
	             * might have updated while the prevLead is unmounted. We need to
	             * update the scroll again to make sure the layout we measure is
	             * up to date.
	             */
	            if (this.resumeFrom && !this.resumeFrom.instance) {
	                for (let i = 0; i < this.path.length; i++) {
	                    const node = this.path[i];
	                    node.updateScroll();
	                }
	            }
	            const prevLayout = this.layout;
	            this.layout = this.measure(false);
	            this.layoutCorrected = createBox();
	            this.isLayoutDirty = false;
	            this.projectionDelta = undefined;
	            this.notifyListeners("measure", this.layout.layoutBox);
	            const { visualElement } = this.options;
	            visualElement &&
	                visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);
	        }
	        updateScroll(phase = "measure") {
	            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
	            if (this.scroll &&
	                this.scroll.animationId === this.root.animationId &&
	                this.scroll.phase === phase) {
	                needsMeasurement = false;
	            }
	            if (needsMeasurement) {
	                const isRoot = checkIsScrollRoot(this.instance);
	                this.scroll = {
	                    animationId: this.root.animationId,
	                    phase,
	                    isRoot,
	                    offset: measureScroll(this.instance),
	                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,
	                };
	            }
	        }
	        resetTransform() {
	            if (!resetTransform)
	                return;
	            const isResetRequested = this.isLayoutDirty ||
	                this.shouldResetTransform ||
	                this.options.alwaysMeasureLayout;
	            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
	            const transformTemplate = this.getTransformTemplate();
	            const transformTemplateValue = transformTemplate
	                ? transformTemplate(this.latestValues, "")
	                : undefined;
	            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
	            if (isResetRequested &&
	                (hasProjection ||
	                    hasTransform(this.latestValues) ||
	                    transformTemplateHasChanged)) {
	                resetTransform(this.instance, transformTemplateValue);
	                this.shouldResetTransform = false;
	                this.scheduleRender();
	            }
	        }
	        measure(removeTransform = true) {
	            const pageBox = this.measurePageBox();
	            let layoutBox = this.removeElementScroll(pageBox);
	            /**
	             * Measurements taken during the pre-render stage
	             * still have transforms applied so we remove them
	             * via calculation.
	             */
	            if (removeTransform) {
	                layoutBox = this.removeTransform(layoutBox);
	            }
	            roundBox(layoutBox);
	            return {
	                animationId: this.root.animationId,
	                measuredBox: pageBox,
	                layoutBox,
	                latestValues: {},
	                source: this.id,
	            };
	        }
	        measurePageBox() {
	            var _a;
	            const { visualElement } = this.options;
	            if (!visualElement)
	                return createBox();
	            const box = visualElement.measureViewportBox();
	            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
	            if (!wasInScrollRoot) {
	                // Remove viewport scroll to give page-relative coordinates
	                const { scroll } = this.root;
	                if (scroll) {
	                    translateAxis(box.x, scroll.offset.x);
	                    translateAxis(box.y, scroll.offset.y);
	                }
	            }
	            return box;
	        }
	        removeElementScroll(box) {
	            var _a;
	            const boxWithoutScroll = createBox();
	            copyBoxInto(boxWithoutScroll, box);
	            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
	                return boxWithoutScroll;
	            }
	            /**
	             * Performance TODO: Keep a cumulative scroll offset down the tree
	             * rather than loop back up the path.
	             */
	            for (let i = 0; i < this.path.length; i++) {
	                const node = this.path[i];
	                const { scroll, options } = node;
	                if (node !== this.root && scroll && options.layoutScroll) {
	                    /**
	                     * If this is a new scroll root, we want to remove all previous scrolls
	                     * from the viewport box.
	                     */
	                    if (scroll.wasRoot) {
	                        copyBoxInto(boxWithoutScroll, box);
	                    }
	                    translateAxis(boxWithoutScroll.x, scroll.offset.x);
	                    translateAxis(boxWithoutScroll.y, scroll.offset.y);
	                }
	            }
	            return boxWithoutScroll;
	        }
	        applyTransform(box, transformOnly = false) {
	            const withTransforms = createBox();
	            copyBoxInto(withTransforms, box);
	            for (let i = 0; i < this.path.length; i++) {
	                const node = this.path[i];
	                if (!transformOnly &&
	                    node.options.layoutScroll &&
	                    node.scroll &&
	                    node !== node.root) {
	                    transformBox(withTransforms, {
	                        x: -node.scroll.offset.x,
	                        y: -node.scroll.offset.y,
	                    });
	                }
	                if (!hasTransform(node.latestValues))
	                    continue;
	                transformBox(withTransforms, node.latestValues);
	            }
	            if (hasTransform(this.latestValues)) {
	                transformBox(withTransforms, this.latestValues);
	            }
	            return withTransforms;
	        }
	        removeTransform(box) {
	            const boxWithoutTransform = createBox();
	            copyBoxInto(boxWithoutTransform, box);
	            for (let i = 0; i < this.path.length; i++) {
	                const node = this.path[i];
	                if (!node.instance)
	                    continue;
	                if (!hasTransform(node.latestValues))
	                    continue;
	                hasScale(node.latestValues) && node.updateSnapshot();
	                const sourceBox = createBox();
	                const nodeBox = node.measurePageBox();
	                copyBoxInto(sourceBox, nodeBox);
	                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);
	            }
	            if (hasTransform(this.latestValues)) {
	                removeBoxTransforms(boxWithoutTransform, this.latestValues);
	            }
	            return boxWithoutTransform;
	        }
	        setTargetDelta(delta) {
	            this.targetDelta = delta;
	            this.root.scheduleUpdateProjection();
	            this.isProjectionDirty = true;
	        }
	        setOptions(options) {
	            this.options = {
	                ...this.options,
	                ...options,
	                crossfade: options.crossfade !== undefined ? options.crossfade : true,
	            };
	        }
	        clearMeasurements() {
	            this.scroll = undefined;
	            this.layout = undefined;
	            this.snapshot = undefined;
	            this.prevTransformTemplateValue = undefined;
	            this.targetDelta = undefined;
	            this.target = undefined;
	            this.isLayoutDirty = false;
	        }
	        forceRelativeParentToResolveTarget() {
	            if (!this.relativeParent)
	                return;
	            /**
	             * If the parent target isn't up-to-date, force it to update.
	             * This is an unfortunate de-optimisation as it means any updating relative
	             * projection will cause all the relative parents to recalculate back
	             * up the tree.
	             */
	            if (this.relativeParent.resolvedRelativeTargetAt !==
	                frameData.timestamp) {
	                this.relativeParent.resolveTargetDelta(true);
	            }
	        }
	        resolveTargetDelta(forceRecalculation = false) {
	            var _a;
	            /**
	             * Once the dirty status of nodes has been spread through the tree, we also
	             * need to check if we have a shared node of a different depth that has itself
	             * been dirtied.
	             */
	            const lead = this.getLead();
	            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
	            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
	            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
	            const isShared = Boolean(this.resumingFrom) || this !== lead;
	            /**
	             * We don't use transform for this step of processing so we don't
	             * need to check whether any nodes have changed transform.
	             */
	            const canSkip = !(forceRecalculation ||
	                (isShared && this.isSharedProjectionDirty) ||
	                this.isProjectionDirty ||
	                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||
	                this.attemptToResolveRelativeTarget ||
	                this.root.updateBlockedByResize);
	            if (canSkip)
	                return;
	            const { layout, layoutId } = this.options;
	            /**
	             * If we have no layout, we can't perform projection, so early return
	             */
	            if (!this.layout || !(layout || layoutId))
	                return;
	            this.resolvedRelativeTargetAt = frameData.timestamp;
	            /**
	             * If we don't have a targetDelta but do have a layout, we can attempt to resolve
	             * a relativeParent. This will allow a component to perform scale correction
	             * even if no animation has started.
	             */
	            if (!this.targetDelta && !this.relativeTarget) {
	                const relativeParent = this.getClosestProjectingParent();
	                if (relativeParent &&
	                    relativeParent.layout &&
	                    this.animationProgress !== 1) {
	                    this.relativeParent = relativeParent;
	                    this.forceRelativeParentToResolveTarget();
	                    this.relativeTarget = createBox();
	                    this.relativeTargetOrigin = createBox();
	                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
	                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
	                }
	                else {
	                    this.relativeParent = this.relativeTarget = undefined;
	                }
	            }
	            /**
	             * If we have no relative target or no target delta our target isn't valid
	             * for this frame.
	             */
	            if (!this.relativeTarget && !this.targetDelta)
	                return;
	            /**
	             * Lazy-init target data structure
	             */
	            if (!this.target) {
	                this.target = createBox();
	                this.targetWithTransforms = createBox();
	            }
	            /**
	             * If we've got a relative box for this component, resolve it into a target relative to the parent.
	             */
	            if (this.relativeTarget &&
	                this.relativeTargetOrigin &&
	                this.relativeParent &&
	                this.relativeParent.target) {
	                this.forceRelativeParentToResolveTarget();
	                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
	                /**
	                 * If we've only got a targetDelta, resolve it into a target
	                 */
	            }
	            else if (this.targetDelta) {
	                if (Boolean(this.resumingFrom)) {
	                    // TODO: This is creating a new object every frame
	                    this.target = this.applyTransform(this.layout.layoutBox);
	                }
	                else {
	                    copyBoxInto(this.target, this.layout.layoutBox);
	                }
	                applyBoxDelta(this.target, this.targetDelta);
	            }
	            else {
	                /**
	                 * If no target, use own layout as target
	                 */
	                copyBoxInto(this.target, this.layout.layoutBox);
	            }
	            /**
	             * If we've been told to attempt to resolve a relative target, do so.
	             */
	            if (this.attemptToResolveRelativeTarget) {
	                this.attemptToResolveRelativeTarget = false;
	                const relativeParent = this.getClosestProjectingParent();
	                if (relativeParent &&
	                    Boolean(relativeParent.resumingFrom) ===
	                        Boolean(this.resumingFrom) &&
	                    !relativeParent.options.layoutScroll &&
	                    relativeParent.target &&
	                    this.animationProgress !== 1) {
	                    this.relativeParent = relativeParent;
	                    this.forceRelativeParentToResolveTarget();
	                    this.relativeTarget = createBox();
	                    this.relativeTargetOrigin = createBox();
	                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
	                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
	                }
	                else {
	                    this.relativeParent = this.relativeTarget = undefined;
	                }
	            }
	            /**
	             * Increase debug counter for resolved target deltas
	             */
	            if (isDebug) {
	                metrics.resolvedTargetDeltas++;
	            }
	        }
	        getClosestProjectingParent() {
	            if (!this.parent ||
	                hasScale(this.parent.latestValues) ||
	                has2DTranslate(this.parent.latestValues)) {
	                return undefined;
	            }
	            if (this.parent.isProjecting()) {
	                return this.parent;
	            }
	            else {
	                return this.parent.getClosestProjectingParent();
	            }
	        }
	        isProjecting() {
	            return Boolean((this.relativeTarget ||
	                this.targetDelta ||
	                this.options.layoutRoot) &&
	                this.layout);
	        }
	        calcProjection() {
	            var _a;
	            const lead = this.getLead();
	            const isShared = Boolean(this.resumingFrom) || this !== lead;
	            let canSkip = true;
	            /**
	             * If this is a normal layout animation and neither this node nor its nearest projecting
	             * is dirty then we can't skip.
	             */
	            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
	                canSkip = false;
	            }
	            /**
	             * If this is a shared layout animation and this node's shared projection is dirty then
	             * we can't skip.
	             */
	            if (isShared &&
	                (this.isSharedProjectionDirty || this.isTransformDirty)) {
	                canSkip = false;
	            }
	            /**
	             * If we have resolved the target this frame we must recalculate the
	             * projection to ensure it visually represents the internal calculations.
	             */
	            if (this.resolvedRelativeTargetAt === frameData.timestamp) {
	                canSkip = false;
	            }
	            if (canSkip)
	                return;
	            const { layout, layoutId } = this.options;
	            /**
	             * If this section of the tree isn't animating we can
	             * delete our target sources for the following frame.
	             */
	            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||
	                this.currentAnimation ||
	                this.pendingAnimation);
	            if (!this.isTreeAnimating) {
	                this.targetDelta = this.relativeTarget = undefined;
	            }
	            if (!this.layout || !(layout || layoutId))
	                return;
	            /**
	             * Reset the corrected box with the latest values from box, as we're then going
	             * to perform mutative operations on it.
	             */
	            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
	            /**
	             * Record previous tree scales before updating.
	             */
	            const prevTreeScaleX = this.treeScale.x;
	            const prevTreeScaleY = this.treeScale.y;
	            /**
	             * Apply all the parent deltas to this box to produce the corrected box. This
	             * is the layout box, as it will appear on screen as a result of the transforms of its parents.
	             */
	            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
	            /**
	             * If this layer needs to perform scale correction but doesn't have a target,
	             * use the layout as the target.
	             */
	            if (lead.layout &&
	                !lead.target &&
	                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
	                lead.target = lead.layout.layoutBox;
	                lead.targetWithTransforms = createBox();
	            }
	            const { target } = lead;
	            if (!target) {
	                /**
	                 * If we don't have a target to project into, but we were previously
	                 * projecting, we want to remove the stored transform and schedule
	                 * a render to ensure the elements reflect the removed transform.
	                 */
	                if (this.prevProjectionDelta) {
	                    this.createProjectionDeltas();
	                    this.scheduleRender();
	                }
	                return;
	            }
	            if (!this.projectionDelta || !this.prevProjectionDelta) {
	                this.createProjectionDeltas();
	            }
	            else {
	                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
	                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
	            }
	            /**
	             * Update the delta between the corrected box and the target box before user-set transforms were applied.
	             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
	             * for our layout reprojection, but still allow them to be scaled correctly by the user.
	             * It might be that to simplify this we may want to accept that user-set scale is also corrected
	             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
	             * to allow people to choose whether these styles are corrected based on just the
	             * layout reprojection or the final bounding box.
	             */
	            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
	            if (this.treeScale.x !== prevTreeScaleX ||
	                this.treeScale.y !== prevTreeScaleY ||
	                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||
	                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
	                this.hasProjected = true;
	                this.scheduleRender();
	                this.notifyListeners("projectionUpdate", target);
	            }
	            /**
	             * Increase debug counter for recalculated projections
	             */
	            if (isDebug) {
	                metrics.recalculatedProjection++;
	            }
	        }
	        hide() {
	            this.isVisible = false;
	            // TODO: Schedule render
	        }
	        show() {
	            this.isVisible = true;
	            // TODO: Schedule render
	        }
	        scheduleRender(notifyAll = true) {
	            var _a;
	            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
	            if (notifyAll) {
	                const stack = this.getStack();
	                stack && stack.scheduleRender();
	            }
	            if (this.resumingFrom && !this.resumingFrom.instance) {
	                this.resumingFrom = undefined;
	            }
	        }
	        createProjectionDeltas() {
	            this.prevProjectionDelta = createDelta();
	            this.projectionDelta = createDelta();
	            this.projectionDeltaWithTransform = createDelta();
	        }
	        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
	            const snapshot = this.snapshot;
	            const snapshotLatestValues = snapshot
	                ? snapshot.latestValues
	                : {};
	            const mixedValues = { ...this.latestValues };
	            const targetDelta = createDelta();
	            if (!this.relativeParent ||
	                !this.relativeParent.options.layoutRoot) {
	                this.relativeTarget = this.relativeTargetOrigin = undefined;
	            }
	            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
	            const relativeLayout = createBox();
	            const snapshotSource = snapshot ? snapshot.source : undefined;
	            const layoutSource = this.layout ? this.layout.source : undefined;
	            const isSharedLayoutAnimation = snapshotSource !== layoutSource;
	            const stack = this.getStack();
	            const isOnlyMember = !stack || stack.members.length <= 1;
	            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&
	                !isOnlyMember &&
	                this.options.crossfade === true &&
	                !this.path.some(hasOpacityCrossfade));
	            this.animationProgress = 0;
	            let prevRelativeTarget;
	            this.mixTargetDelta = (latest) => {
	                const progress = latest / 1000;
	                mixAxisDelta(targetDelta.x, delta.x, progress);
	                mixAxisDelta(targetDelta.y, delta.y, progress);
	                this.setTargetDelta(targetDelta);
	                if (this.relativeTarget &&
	                    this.relativeTargetOrigin &&
	                    this.layout &&
	                    this.relativeParent &&
	                    this.relativeParent.layout) {
	                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
	                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
	                    /**
	                     * If this is an unchanged relative target we can consider the
	                     * projection not dirty.
	                     */
	                    if (prevRelativeTarget &&
	                        boxEquals(this.relativeTarget, prevRelativeTarget)) {
	                        this.isProjectionDirty = false;
	                    }
	                    if (!prevRelativeTarget)
	                        prevRelativeTarget = createBox();
	                    copyBoxInto(prevRelativeTarget, this.relativeTarget);
	                }
	                if (isSharedLayoutAnimation) {
	                    this.animationValues = mixedValues;
	                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
	                }
	                this.root.scheduleUpdateProjection();
	                this.scheduleRender();
	                this.animationProgress = progress;
	            };
	            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
	        }
	        startAnimation(options) {
	            this.notifyListeners("animationStart");
	            this.currentAnimation && this.currentAnimation.stop();
	            if (this.resumingFrom && this.resumingFrom.currentAnimation) {
	                this.resumingFrom.currentAnimation.stop();
	            }
	            if (this.pendingAnimation) {
	                cancelFrame(this.pendingAnimation);
	                this.pendingAnimation = undefined;
	            }
	            /**
	             * Start the animation in the next frame to have a frame with progress 0,
	             * where the target is the same as when the animation started, so we can
	             * calculate the relative positions correctly for instant transitions.
	             */
	            this.pendingAnimation = frame.update(() => {
	                globalProjectionState.hasAnimatedSinceResize = true;
	                this.currentAnimation = animateSingleValue(0, animationTarget, {
	                    ...options,
	                    onUpdate: (latest) => {
	                        this.mixTargetDelta(latest);
	                        options.onUpdate && options.onUpdate(latest);
	                    },
	                    onComplete: () => {
	                        options.onComplete && options.onComplete();
	                        this.completeAnimation();
	                    },
	                });
	                if (this.resumingFrom) {
	                    this.resumingFrom.currentAnimation = this.currentAnimation;
	                }
	                this.pendingAnimation = undefined;
	            });
	        }
	        completeAnimation() {
	            if (this.resumingFrom) {
	                this.resumingFrom.currentAnimation = undefined;
	                this.resumingFrom.preserveOpacity = undefined;
	            }
	            const stack = this.getStack();
	            stack && stack.exitAnimationComplete();
	            this.resumingFrom =
	                this.currentAnimation =
	                    this.animationValues =
	                        undefined;
	            this.notifyListeners("animationComplete");
	        }
	        finishAnimation() {
	            if (this.currentAnimation) {
	                this.mixTargetDelta && this.mixTargetDelta(animationTarget);
	                this.currentAnimation.stop();
	            }
	            this.completeAnimation();
	        }
	        applyTransformsToTarget() {
	            const lead = this.getLead();
	            let { targetWithTransforms, target, layout, latestValues } = lead;
	            if (!targetWithTransforms || !target || !layout)
	                return;
	            /**
	             * If we're only animating position, and this element isn't the lead element,
	             * then instead of projecting into the lead box we instead want to calculate
	             * a new target that aligns the two boxes but maintains the layout shape.
	             */
	            if (this !== lead &&
	                this.layout &&
	                layout &&
	                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
	                target = this.target || createBox();
	                const xLength = calcLength(this.layout.layoutBox.x);
	                target.x.min = lead.target.x.min;
	                target.x.max = target.x.min + xLength;
	                const yLength = calcLength(this.layout.layoutBox.y);
	                target.y.min = lead.target.y.min;
	                target.y.max = target.y.min + yLength;
	            }
	            copyBoxInto(targetWithTransforms, target);
	            /**
	             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
	             * This is the final box that we will then project into by calculating a transform delta and
	             * applying it to the corrected box.
	             */
	            transformBox(targetWithTransforms, latestValues);
	            /**
	             * Update the delta between the corrected box and the final target box, after
	             * user-set transforms are applied to it. This will be used by the renderer to
	             * create a transform style that will reproject the element from its layout layout
	             * into the desired bounding box.
	             */
	            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
	        }
	        registerSharedNode(layoutId, node) {
	            if (!this.sharedNodes.has(layoutId)) {
	                this.sharedNodes.set(layoutId, new NodeStack());
	            }
	            const stack = this.sharedNodes.get(layoutId);
	            stack.add(node);
	            const config = node.options.initialPromotionConfig;
	            node.promote({
	                transition: config ? config.transition : undefined,
	                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity
	                    ? config.shouldPreserveFollowOpacity(node)
	                    : undefined,
	            });
	        }
	        isLead() {
	            const stack = this.getStack();
	            return stack ? stack.lead === this : true;
	        }
	        getLead() {
	            var _a;
	            const { layoutId } = this.options;
	            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
	        }
	        getPrevLead() {
	            var _a;
	            const { layoutId } = this.options;
	            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;
	        }
	        getStack() {
	            const { layoutId } = this.options;
	            if (layoutId)
	                return this.root.sharedNodes.get(layoutId);
	        }
	        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {
	            const stack = this.getStack();
	            if (stack)
	                stack.promote(this, preserveFollowOpacity);
	            if (needsReset) {
	                this.projectionDelta = undefined;
	                this.needsReset = true;
	            }
	            if (transition)
	                this.setOptions({ transition });
	        }
	        relegate() {
	            const stack = this.getStack();
	            if (stack) {
	                return stack.relegate(this);
	            }
	            else {
	                return false;
	            }
	        }
	        resetSkewAndRotation() {
	            const { visualElement } = this.options;
	            if (!visualElement)
	                return;
	            // If there's no detected skew or rotation values, we can early return without a forced render.
	            let hasDistortingTransform = false;
	            /**
	             * An unrolled check for rotation values. Most elements don't have any rotation and
	             * skipping the nested loop and new object creation is 50% faster.
	             */
	            const { latestValues } = visualElement;
	            if (latestValues.z ||
	                latestValues.rotate ||
	                latestValues.rotateX ||
	                latestValues.rotateY ||
	                latestValues.rotateZ ||
	                latestValues.skewX ||
	                latestValues.skewY) {
	                hasDistortingTransform = true;
	            }
	            // If there's no distorting values, we don't need to do any more.
	            if (!hasDistortingTransform)
	                return;
	            const resetValues = {};
	            if (latestValues.z) {
	                resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
	            }
	            // Check the skew and rotate value of all axes and reset to 0
	            for (let i = 0; i < transformAxes.length; i++) {
	                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
	                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
	            }
	            // Force a render of this element to apply the transform with all skews and rotations
	            // set to 0.
	            visualElement.render();
	            // Put back all the values we reset
	            for (const key in resetValues) {
	                visualElement.setStaticValue(key, resetValues[key]);
	                if (this.animationValues) {
	                    this.animationValues[key] = resetValues[key];
	                }
	            }
	            // Schedule a render for the next frame. This ensures we won't visually
	            // see the element with the reset rotate value applied.
	            visualElement.scheduleRender();
	        }
	        getProjectionStyles(styleProp) {
	            var _a, _b;
	            if (!this.instance || this.isSVG)
	                return undefined;
	            if (!this.isVisible) {
	                return hiddenVisibility;
	            }
	            const styles = {
	                visibility: "",
	            };
	            const transformTemplate = this.getTransformTemplate();
	            if (this.needsReset) {
	                this.needsReset = false;
	                styles.opacity = "";
	                styles.pointerEvents =
	                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
	                styles.transform = transformTemplate
	                    ? transformTemplate(this.latestValues, "")
	                    : "none";
	                return styles;
	            }
	            const lead = this.getLead();
	            if (!this.projectionDelta || !this.layout || !lead.target) {
	                const emptyStyles = {};
	                if (this.options.layoutId) {
	                    emptyStyles.opacity =
	                        this.latestValues.opacity !== undefined
	                            ? this.latestValues.opacity
	                            : 1;
	                    emptyStyles.pointerEvents =
	                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
	                }
	                if (this.hasProjected && !hasTransform(this.latestValues)) {
	                    emptyStyles.transform = transformTemplate
	                        ? transformTemplate({}, "")
	                        : "none";
	                    this.hasProjected = false;
	                }
	                return emptyStyles;
	            }
	            const valuesToRender = lead.animationValues || lead.latestValues;
	            this.applyTransformsToTarget();
	            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
	            if (transformTemplate) {
	                styles.transform = transformTemplate(valuesToRender, styles.transform);
	            }
	            const { x, y } = this.projectionDelta;
	            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
	            if (lead.animationValues) {
	                /**
	                 * If the lead component is animating, assign this either the entering/leaving
	                 * opacity
	                 */
	                styles.opacity =
	                    lead === this
	                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1
	                        : this.preserveOpacity
	                            ? this.latestValues.opacity
	                            : valuesToRender.opacityExit;
	            }
	            else {
	                /**
	                 * Or we're not animating at all, set the lead component to its layout
	                 * opacity and other components to hidden.
	                 */
	                styles.opacity =
	                    lead === this
	                        ? valuesToRender.opacity !== undefined
	                            ? valuesToRender.opacity
	                            : ""
	                        : valuesToRender.opacityExit !== undefined
	                            ? valuesToRender.opacityExit
	                            : 0;
	            }
	            /**
	             * Apply scale correction
	             */
	            for (const key in scaleCorrectors) {
	                if (valuesToRender[key] === undefined)
	                    continue;
	                const { correct, applyTo } = scaleCorrectors[key];
	                /**
	                 * Only apply scale correction to the value if we have an
	                 * active projection transform. Otherwise these values become
	                 * vulnerable to distortion if the element changes size without
	                 * a corresponding layout animation.
	                 */
	                const corrected = styles.transform === "none"
	                    ? valuesToRender[key]
	                    : correct(valuesToRender[key], lead);
	                if (applyTo) {
	                    const num = applyTo.length;
	                    for (let i = 0; i < num; i++) {
	                        styles[applyTo[i]] = corrected;
	                    }
	                }
	                else {
	                    styles[key] = corrected;
	                }
	            }
	            /**
	             * Disable pointer events on follow components. This is to ensure
	             * that if a follow component covers a lead component it doesn't block
	             * pointer events on the lead.
	             */
	            if (this.options.layoutId) {
	                styles.pointerEvents =
	                    lead === this
	                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || ""
	                        : "none";
	            }
	            return styles;
	        }
	        clearSnapshot() {
	            this.resumeFrom = this.snapshot = undefined;
	        }
	        // Only run on root
	        resetTree() {
	            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });
	            this.root.nodes.forEach(clearMeasurements);
	            this.root.sharedNodes.clear();
	        }
	    };
	}
	function updateLayout(node) {
	    node.updateLayout();
	}
	function notifyLayoutUpdate(node) {
	    var _a;
	    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
	    if (node.isLead() &&
	        node.layout &&
	        snapshot &&
	        node.hasListeners("didUpdate")) {
	        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
	        const { animationType } = node.options;
	        const isShared = snapshot.source !== node.layout.source;
	        // TODO Maybe we want to also resize the layout snapshot so we don't trigger
	        // animations for instance if layout="size" and an element has only changed position
	        if (animationType === "size") {
	            eachAxis((axis) => {
	                const axisSnapshot = isShared
	                    ? snapshot.measuredBox[axis]
	                    : snapshot.layoutBox[axis];
	                const length = calcLength(axisSnapshot);
	                axisSnapshot.min = layout[axis].min;
	                axisSnapshot.max = axisSnapshot.min + length;
	            });
	        }
	        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
	            eachAxis((axis) => {
	                const axisSnapshot = isShared
	                    ? snapshot.measuredBox[axis]
	                    : snapshot.layoutBox[axis];
	                const length = calcLength(layout[axis]);
	                axisSnapshot.max = axisSnapshot.min + length;
	                /**
	                 * Ensure relative target gets resized and rerendererd
	                 */
	                if (node.relativeTarget && !node.currentAnimation) {
	                    node.isProjectionDirty = true;
	                    node.relativeTarget[axis].max =
	                        node.relativeTarget[axis].min + length;
	                }
	            });
	        }
	        const layoutDelta = createDelta();
	        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
	        const visualDelta = createDelta();
	        if (isShared) {
	            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
	        }
	        else {
	            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
	        }
	        const hasLayoutChanged = !isDeltaZero(layoutDelta);
	        let hasRelativeTargetChanged = false;
	        if (!node.resumeFrom) {
	            const relativeParent = node.getClosestProjectingParent();
	            /**
	             * If the relativeParent is itself resuming from a different element then
	             * the relative snapshot is not relavent
	             */
	            if (relativeParent && !relativeParent.resumeFrom) {
	                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
	                if (parentSnapshot && parentLayout) {
	                    const relativeSnapshot = createBox();
	                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
	                    const relativeLayout = createBox();
	                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
	                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
	                        hasRelativeTargetChanged = true;
	                    }
	                    if (relativeParent.options.layoutRoot) {
	                        node.relativeTarget = relativeLayout;
	                        node.relativeTargetOrigin = relativeSnapshot;
	                        node.relativeParent = relativeParent;
	                    }
	                }
	            }
	        }
	        node.notifyListeners("didUpdate", {
	            layout,
	            snapshot,
	            delta: visualDelta,
	            layoutDelta,
	            hasLayoutChanged,
	            hasRelativeTargetChanged,
	        });
	    }
	    else if (node.isLead()) {
	        const { onExitComplete } = node.options;
	        onExitComplete && onExitComplete();
	    }
	    /**
	     * Clearing transition
	     * TODO: Investigate why this transition is being passed in as {type: false } from Framer
	     * and why we need it at all
	     */
	    node.options.transition = undefined;
	}
	function propagateDirtyNodes(node) {
	    /**
	     * Increase debug counter for nodes encountered this frame
	     */
	    if (isDebug) {
	        metrics.totalNodes++;
	    }
	    if (!node.parent)
	        return;
	    /**
	     * If this node isn't projecting, propagate isProjectionDirty. It will have
	     * no performance impact but it will allow the next child that *is* projecting
	     * but *isn't* dirty to just check its parent to see if *any* ancestor needs
	     * correcting.
	     */
	    if (!node.isProjecting()) {
	        node.isProjectionDirty = node.parent.isProjectionDirty;
	    }
	    /**
	     * Propagate isSharedProjectionDirty and isTransformDirty
	     * throughout the whole tree. A future revision can take another look at
	     * this but for safety we still recalcualte shared nodes.
	     */
	    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||
	        node.parent.isProjectionDirty ||
	        node.parent.isSharedProjectionDirty));
	    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
	}
	function cleanDirtyNodes(node) {
	    node.isProjectionDirty =
	        node.isSharedProjectionDirty =
	            node.isTransformDirty =
	                false;
	}
	function clearSnapshot(node) {
	    node.clearSnapshot();
	}
	function clearMeasurements(node) {
	    node.clearMeasurements();
	}
	function clearIsLayoutDirty(node) {
	    node.isLayoutDirty = false;
	}
	function resetTransformStyle(node) {
	    const { visualElement } = node.options;
	    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
	        visualElement.notify("BeforeLayoutMeasure");
	    }
	    node.resetTransform();
	}
	function finishAnimation(node) {
	    node.finishAnimation();
	    node.targetDelta = node.relativeTarget = node.target = undefined;
	    node.isProjectionDirty = true;
	}
	function resolveTargetDelta(node) {
	    node.resolveTargetDelta();
	}
	function calcProjection(node) {
	    node.calcProjection();
	}
	function resetSkewAndRotation(node) {
	    node.resetSkewAndRotation();
	}
	function removeLeadSnapshots(stack) {
	    stack.removeLeadSnapshot();
	}
	function mixAxisDelta(output, delta, p) {
	    output.translate = mixNumber$1(delta.translate, 0, p);
	    output.scale = mixNumber$1(delta.scale, 1, p);
	    output.origin = delta.origin;
	    output.originPoint = delta.originPoint;
	}
	function mixAxis(output, from, to, p) {
	    output.min = mixNumber$1(from.min, to.min, p);
	    output.max = mixNumber$1(from.max, to.max, p);
	}
	function mixBox(output, from, to, p) {
	    mixAxis(output.x, from.x, to.x, p);
	    mixAxis(output.y, from.y, to.y, p);
	}
	function hasOpacityCrossfade(node) {
	    return (node.animationValues && node.animationValues.opacityExit !== undefined);
	}
	const defaultLayoutTransition = {
	    duration: 0.45,
	    ease: [0.4, 0, 0.1, 1],
	};
	const userAgentContains = (string) => typeof navigator !== "undefined" &&
	    navigator.userAgent &&
	    navigator.userAgent.toLowerCase().includes(string);
	/**
	 * Measured bounding boxes must be rounded in Safari and
	 * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements
	 * can appear to jump.
	 */
	const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")
	    ? Math.round
	    : noop;
	function roundAxis(axis) {
	    // Round to the nearest .5 pixels to support subpixel layouts
	    axis.min = roundPoint(axis.min);
	    axis.max = roundPoint(axis.max);
	}
	function roundBox(box) {
	    roundAxis(box.x);
	    roundAxis(box.y);
	}
	function shouldAnimatePositionOnly(animationType, snapshot, layout) {
	    return (animationType === "position" ||
	        (animationType === "preserve-aspect" &&
	            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));
	}
	function checkNodeWasScrollRoot(node) {
	    var _a;
	    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
	}

	const DocumentProjectionNode = createProjectionNode$1({
	    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
	    measureScroll: () => ({
	        x: document.documentElement.scrollLeft || document.body.scrollLeft,
	        y: document.documentElement.scrollTop || document.body.scrollTop,
	    }),
	    checkIsScrollRoot: () => true,
	});

	const rootProjectionNode = {
	    current: undefined,
	};
	const HTMLProjectionNode = createProjectionNode$1({
	    measureScroll: (instance) => ({
	        x: instance.scrollLeft,
	        y: instance.scrollTop,
	    }),
	    defaultParent: () => {
	        if (!rootProjectionNode.current) {
	            const documentNode = new DocumentProjectionNode({});
	            documentNode.mount(window);
	            documentNode.setOptions({ layoutScroll: true });
	            rootProjectionNode.current = documentNode;
	        }
	        return rootProjectionNode.current;
	    },
	    resetTransform: (instance, value) => {
	        instance.style.transform = value !== undefined ? value : "none";
	    },
	    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed"),
	});

	const drag = {
	    pan: {
	        Feature: PanGesture,
	    },
	    drag: {
	        Feature: DragGesture,
	        ProjectionNode: HTMLProjectionNode,
	        MeasureLayout,
	    },
	};

	function handleHoverEvent(node, event, lifecycle) {
	    const { props } = node;
	    if (node.animationState && props.whileHover) {
	        node.animationState.setActive("whileHover", lifecycle === "Start");
	    }
	    const eventName = ("onHover" + lifecycle);
	    const callback = props[eventName];
	    if (callback) {
	        frame.postRender(() => callback(event, extractEventInfo(event)));
	    }
	}
	class HoverGesture extends Feature {
	    mount() {
	        const { current } = this.node;
	        if (!current)
	            return;
	        this.unmount = hover(current, (startEvent) => {
	            handleHoverEvent(this.node, startEvent, "Start");
	            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
	        });
	    }
	    unmount() { }
	}

	class FocusGesture extends Feature {
	    constructor() {
	        super(...arguments);
	        this.isActive = false;
	    }
	    onFocus() {
	        let isFocusVisible = false;
	        /**
	         * If this element doesn't match focus-visible then don't
	         * apply whileHover. But, if matches throws that focus-visible
	         * is not a valid selector then in that browser outline styles will be applied
	         * to the element by default and we want to match that behaviour with whileFocus.
	         */
	        try {
	            isFocusVisible = this.node.current.matches(":focus-visible");
	        }
	        catch (e) {
	            isFocusVisible = true;
	        }
	        if (!isFocusVisible || !this.node.animationState)
	            return;
	        this.node.animationState.setActive("whileFocus", true);
	        this.isActive = true;
	    }
	    onBlur() {
	        if (!this.isActive || !this.node.animationState)
	            return;
	        this.node.animationState.setActive("whileFocus", false);
	        this.isActive = false;
	    }
	    mount() {
	        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
	    }
	    unmount() { }
	}

	function handlePressEvent(node, event, lifecycle) {
	    const { props } = node;
	    if (node.animationState && props.whileTap) {
	        node.animationState.setActive("whileTap", lifecycle === "Start");
	    }
	    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));
	    const callback = props[eventName];
	    if (callback) {
	        frame.postRender(() => callback(event, extractEventInfo(event)));
	    }
	}
	class PressGesture extends Feature {
	    mount() {
	        const { current } = this.node;
	        if (!current)
	            return;
	        this.unmount = press(current, (startEvent) => {
	            handlePressEvent(this.node, startEvent, "Start");
	            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
	        }, { useGlobalTarget: this.node.props.globalTapTarget });
	    }
	    unmount() { }
	}

	/**
	 * Map an IntersectionHandler callback to an element. We only ever make one handler for one
	 * element, so even though these handlers might all be triggered by different
	 * observers, we can keep them in the same map.
	 */
	const observerCallbacks = new WeakMap();
	/**
	 * Multiple observers can be created for multiple element/document roots. Each with
	 * different settings. So here we store dictionaries of observers to each root,
	 * using serialised settings (threshold/margin) as lookup keys.
	 */
	const observers = new WeakMap();
	const fireObserverCallback = (entry) => {
	    const callback = observerCallbacks.get(entry.target);
	    callback && callback(entry);
	};
	const fireAllObserverCallbacks = (entries) => {
	    entries.forEach(fireObserverCallback);
	};
	function initIntersectionObserver({ root, ...options }) {
	    const lookupRoot = root || document;
	    /**
	     * If we don't have an observer lookup map for this root, create one.
	     */
	    if (!observers.has(lookupRoot)) {
	        observers.set(lookupRoot, {});
	    }
	    const rootObservers = observers.get(lookupRoot);
	    const key = JSON.stringify(options);
	    /**
	     * If we don't have an observer for this combination of root and settings,
	     * create one.
	     */
	    if (!rootObservers[key]) {
	        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
	    }
	    return rootObservers[key];
	}
	function observeIntersection(element, options, callback) {
	    const rootInteresectionObserver = initIntersectionObserver(options);
	    observerCallbacks.set(element, callback);
	    rootInteresectionObserver.observe(element);
	    return () => {
	        observerCallbacks.delete(element);
	        rootInteresectionObserver.unobserve(element);
	    };
	}

	const thresholdNames = {
	    some: 0,
	    all: 1,
	};
	class InViewFeature extends Feature {
	    constructor() {
	        super(...arguments);
	        this.hasEnteredView = false;
	        this.isInView = false;
	    }
	    startObserver() {
	        this.unmount();
	        const { viewport = {} } = this.node.getProps();
	        const { root, margin: rootMargin, amount = "some", once } = viewport;
	        const options = {
	            root: root ? root.current : undefined,
	            rootMargin,
	            threshold: typeof amount === "number" ? amount : thresholdNames[amount],
	        };
	        const onIntersectionUpdate = (entry) => {
	            const { isIntersecting } = entry;
	            /**
	             * If there's been no change in the viewport state, early return.
	             */
	            if (this.isInView === isIntersecting)
	                return;
	            this.isInView = isIntersecting;
	            /**
	             * Handle hasEnteredView. If this is only meant to run once, and
	             * element isn't visible, early return. Otherwise set hasEnteredView to true.
	             */
	            if (once && !isIntersecting && this.hasEnteredView) {
	                return;
	            }
	            else if (isIntersecting) {
	                this.hasEnteredView = true;
	            }
	            if (this.node.animationState) {
	                this.node.animationState.setActive("whileInView", isIntersecting);
	            }
	            /**
	             * Use the latest committed props rather than the ones in scope
	             * when this observer is created
	             */
	            const { onViewportEnter, onViewportLeave } = this.node.getProps();
	            const callback = isIntersecting ? onViewportEnter : onViewportLeave;
	            callback && callback(entry);
	        };
	        return observeIntersection(this.node.current, options, onIntersectionUpdate);
	    }
	    mount() {
	        this.startObserver();
	    }
	    update() {
	        if (typeof IntersectionObserver === "undefined")
	            return;
	        const { props, prevProps } = this.node;
	        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
	        if (hasOptionsChanged) {
	            this.startObserver();
	        }
	    }
	    unmount() { }
	}
	function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
	    return (name) => viewport[name] !== prevViewport[name];
	}

	const gestureAnimations = {
	    inView: {
	        Feature: InViewFeature,
	    },
	    tap: {
	        Feature: PressGesture,
	    },
	    focus: {
	        Feature: FocusGesture,
	    },
	    hover: {
	        Feature: HoverGesture,
	    },
	};

	const layout = {
	    layout: {
	        ProjectionNode: HTMLProjectionNode,
	        MeasureLayout,
	    },
	};

	/**
	 * @public
	 */
	const MotionConfigContext = reactExports.createContext({
	    transformPagePoint: (p) => p,
	    isStatic: false,
	    reducedMotion: "never",
	});

	const MotionContext = reactExports.createContext({});

	const isBrowser = typeof window !== "undefined";

	const useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect;

	const LazyContext = reactExports.createContext({ strict: false });

	function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
	    var _a, _b;
	    const { visualElement: parent } = reactExports.useContext(MotionContext);
	    const lazyContext = reactExports.useContext(LazyContext);
	    const presenceContext = reactExports.useContext(PresenceContext);
	    const reducedMotionConfig = reactExports.useContext(MotionConfigContext).reducedMotion;
	    const visualElementRef = reactExports.useRef(null);
	    /**
	     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
	     */
	    createVisualElement = createVisualElement || lazyContext.renderer;
	    if (!visualElementRef.current && createVisualElement) {
	        visualElementRef.current = createVisualElement(Component, {
	            visualState,
	            parent,
	            props,
	            presenceContext,
	            blockInitialAnimation: presenceContext
	                ? presenceContext.initial === false
	                : false,
	            reducedMotionConfig,
	        });
	    }
	    const visualElement = visualElementRef.current;
	    /**
	     * Load Motion gesture and animation features. These are rendered as renderless
	     * components so each feature can optionally make use of React lifecycle methods.
	     */
	    const initialLayoutGroupConfig = reactExports.useContext(SwitchLayoutGroupContext);
	    if (visualElement &&
	        !visualElement.projection &&
	        ProjectionNodeConstructor &&
	        (visualElement.type === "html" || visualElement.type === "svg")) {
	        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
	    }
	    const isMounted = reactExports.useRef(false);
	    reactExports.useInsertionEffect(() => {
	        /**
	         * Check the component has already mounted before calling
	         * `update` unnecessarily. This ensures we skip the initial update.
	         */
	        if (visualElement && isMounted.current) {
	            visualElement.update(props, presenceContext);
	        }
	    });
	    /**
	     * Cache this value as we want to know whether HandoffAppearAnimations
	     * was present on initial render - it will be deleted after this.
	     */
	    const optimisedAppearId = props[optimizedAppearDataAttribute];
	    const wantsHandoff = reactExports.useRef(Boolean(optimisedAppearId) &&
	        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&
	        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
	    useIsomorphicLayoutEffect(() => {
	        if (!visualElement)
	            return;
	        isMounted.current = true;
	        window.MotionIsMounted = true;
	        visualElement.updateFeatures();
	        microtask.render(visualElement.render);
	        /**
	         * Ideally this function would always run in a useEffect.
	         *
	         * However, if we have optimised appear animations to handoff from,
	         * it needs to happen synchronously to ensure there's no flash of
	         * incorrect styles in the event of a hydration error.
	         *
	         * So if we detect a situtation where optimised appear animations
	         * are running, we use useLayoutEffect to trigger animations.
	         */
	        if (wantsHandoff.current && visualElement.animationState) {
	            visualElement.animationState.animateChanges();
	        }
	    });
	    reactExports.useEffect(() => {
	        if (!visualElement)
	            return;
	        if (!wantsHandoff.current && visualElement.animationState) {
	            visualElement.animationState.animateChanges();
	        }
	        if (wantsHandoff.current) {
	            // This ensures all future calls to animateChanges() in this component will run in useEffect
	            queueMicrotask(() => {
	                var _a;
	                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);
	            });
	            wantsHandoff.current = false;
	        }
	    });
	    return visualElement;
	}
	function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
	    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;
	    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"]
	        ? undefined
	        : getClosestProjectingNode(visualElement.parent));
	    visualElement.projection.setOptions({
	        layoutId,
	        layout,
	        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),
	        visualElement,
	        /**
	         * TODO: Update options in an effect. This could be tricky as it'll be too late
	         * to update by the time layout animations run.
	         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
	         * ensuring it gets called if there's no potential layout animations.
	         *
	         */
	        animationType: typeof layout === "string" ? layout : "both",
	        initialPromotionConfig,
	        layoutScroll,
	        layoutRoot,
	    });
	}
	function getClosestProjectingNode(visualElement) {
	    if (!visualElement)
	        return undefined;
	    return visualElement.options.allowProjection !== false
	        ? visualElement.projection
	        : getClosestProjectingNode(visualElement.parent);
	}

	/**
	 * Creates a ref function that, when called, hydrates the provided
	 * external ref and VisualElement.
	 */
	function useMotionRef(visualState, visualElement, externalRef) {
	    return reactExports.useCallback((instance) => {
	        instance && visualState.mount && visualState.mount(instance);
	        if (visualElement) {
	            if (instance) {
	                visualElement.mount(instance);
	            }
	            else {
	                visualElement.unmount();
	            }
	        }
	        if (externalRef) {
	            if (typeof externalRef === "function") {
	                externalRef(instance);
	            }
	            else if (isRefObject(externalRef)) {
	                externalRef.current = instance;
	            }
	        }
	    }, 
	    /**
	     * Only pass a new ref callback to React if we've received a visual element
	     * factory. Otherwise we'll be mounting/remounting every time externalRef
	     * or other dependencies change.
	     */
	    [visualElement]);
	}

	function isControllingVariants(props) {
	    return (isAnimationControls(props.animate) ||
	        variantProps.some((name) => isVariantLabel(props[name])));
	}
	function isVariantNode(props) {
	    return Boolean(isControllingVariants(props) || props.variants);
	}

	function getCurrentTreeVariants(props, context) {
	    if (isControllingVariants(props)) {
	        const { initial, animate } = props;
	        return {
	            initial: initial === false || isVariantLabel(initial)
	                ? initial
	                : undefined,
	            animate: isVariantLabel(animate) ? animate : undefined,
	        };
	    }
	    return props.inherit !== false ? context : {};
	}

	function useCreateMotionContext(props) {
	    const { initial, animate } = getCurrentTreeVariants(props, reactExports.useContext(MotionContext));
	    return reactExports.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
	}
	function variantLabelsAsDependency(prop) {
	    return Array.isArray(prop) ? prop.join(" ") : prop;
	}

	const featureProps = {
	    animation: [
	        "animate",
	        "variants",
	        "whileHover",
	        "whileTap",
	        "exit",
	        "whileInView",
	        "whileFocus",
	        "whileDrag",
	    ],
	    exit: ["exit"],
	    drag: ["drag", "dragControls"],
	    focus: ["whileFocus"],
	    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
	    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
	    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
	    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
	    layout: ["layout", "layoutId"],
	};
	const featureDefinitions = {};
	for (const key in featureProps) {
	    featureDefinitions[key] = {
	        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),
	    };
	}

	function loadFeatures(features) {
	    for (const key in features) {
	        featureDefinitions[key] = {
	            ...featureDefinitions[key],
	            ...features[key],
	        };
	    }
	}

	const motionComponentSymbol = Symbol.for("motionComponentSymbol");

	/**
	 * Create a `motion` component.
	 *
	 * This function accepts a Component argument, which can be either a string (ie "div"
	 * for `motion.div`), or an actual React component.
	 *
	 * Alongside this is a config option which provides a way of rendering the provided
	 * component "offline", or outside the React render cycle.
	 */
	function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {
	    preloadedFeatures && loadFeatures(preloadedFeatures);
	    function MotionComponent(props, externalRef) {
	        /**
	         * If we need to measure the element we load this functionality in a
	         * separate class component in order to gain access to getSnapshotBeforeUpdate.
	         */
	        let MeasureLayout;
	        const configAndProps = {
	            ...reactExports.useContext(MotionConfigContext),
	            ...props,
	            layoutId: useLayoutId(props),
	        };
	        const { isStatic } = configAndProps;
	        const context = useCreateMotionContext(props);
	        const visualState = useVisualState(props, isStatic);
	        if (!isStatic && isBrowser) {
	            useStrictMode(configAndProps, preloadedFeatures);
	            const layoutProjection = getProjectionFunctionality(configAndProps);
	            MeasureLayout = layoutProjection.MeasureLayout;
	            /**
	             * Create a VisualElement for this component. A VisualElement provides a common
	             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as
	             * providing a way of rendering to these APIs outside of the React render loop
	             * for more performant animations and interactions
	             */
	            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
	        }
	        /**
	         * The mount order and hierarchy is specific to ensure our element ref
	         * is hydrated by the time features fire their effects.
	         */
	        return (jsxRuntimeExports.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsxRuntimeExports.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));
	    }
	    const ForwardRefMotionComponent = reactExports.forwardRef(MotionComponent);
	    ForwardRefMotionComponent[motionComponentSymbol] = Component;
	    return ForwardRefMotionComponent;
	}
	function useLayoutId({ layoutId }) {
	    const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
	    return layoutGroupId && layoutId !== undefined
	        ? layoutGroupId + "-" + layoutId
	        : layoutId;
	}
	function useStrictMode(configAndProps, preloadedFeatures) {
	    const isStrict = reactExports.useContext(LazyContext).strict;
	    /**
	     * If we're in development mode, check to make sure we're not rendering a motion component
	     * as a child of LazyMotion, as this will break the file-size benefits of using it.
	     */
	    if (process.env.NODE_ENV !== "production" &&
	        preloadedFeatures &&
	        isStrict) {
	        const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
	        configAndProps.ignoreStrict
	            ? warning(false, strictMessage)
	            : invariant(false, strictMessage);
	    }
	}
	function getProjectionFunctionality(props) {
	    const { drag, layout } = featureDefinitions;
	    if (!drag && !layout)
	        return {};
	    const combined = { ...drag, ...layout };
	    return {
	        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))
	            ? combined.MeasureLayout
	            : undefined,
	        ProjectionNode: combined.ProjectionNode,
	    };
	}

	/**
	 * We keep these listed separately as we use the lowercase tag names as part
	 * of the runtime bundle to detect SVG components
	 */
	const lowercaseSVGElements = [
	    "animate",
	    "circle",
	    "defs",
	    "desc",
	    "ellipse",
	    "g",
	    "image",
	    "line",
	    "filter",
	    "marker",
	    "mask",
	    "metadata",
	    "path",
	    "pattern",
	    "polygon",
	    "polyline",
	    "rect",
	    "stop",
	    "switch",
	    "symbol",
	    "svg",
	    "text",
	    "tspan",
	    "use",
	    "view",
	];

	function isSVGComponent(Component) {
	    if (
	    /**
	     * If it's not a string, it's a custom React component. Currently we only support
	     * HTML custom React components.
	     */
	    typeof Component !== "string" ||
	        /**
	         * If it contains a dash, the element is a custom HTML webcomponent.
	         */
	        Component.includes("-")) {
	        return false;
	    }
	    else if (
	    /**
	     * If it's in our list of lowercase SVG tags, it's an SVG component
	     */
	    lowercaseSVGElements.indexOf(Component) > -1 ||
	        /**
	         * If it contains a capital letter, it's an SVG component
	         */
	        /[A-Z]/u.test(Component)) {
	        return true;
	    }
	    return false;
	}

	function renderHTML(element, { style, vars }, styleProp, projection) {
	    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
	    // Loop over any CSS variables and assign those.
	    for (const key in vars) {
	        element.style.setProperty(key, vars[key]);
	    }
	}

	/**
	 * A set of attribute names that are always read/written as camel case.
	 */
	const camelCaseAttributes = new Set([
	    "baseFrequency",
	    "diffuseConstant",
	    "kernelMatrix",
	    "kernelUnitLength",
	    "keySplines",
	    "keyTimes",
	    "limitingConeAngle",
	    "markerHeight",
	    "markerWidth",
	    "numOctaves",
	    "targetX",
	    "targetY",
	    "surfaceScale",
	    "specularConstant",
	    "specularExponent",
	    "stdDeviation",
	    "tableValues",
	    "viewBox",
	    "gradientTransform",
	    "pathLength",
	    "startOffset",
	    "textLength",
	    "lengthAdjust",
	]);

	function renderSVG(element, renderState, _styleProp, projection) {
	    renderHTML(element, renderState, undefined, projection);
	    for (const key in renderState.attrs) {
	        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
	    }
	}

	function isForcedMotionValue(key, { layout, layoutId }) {
	    return (transformProps.has(key) ||
	        key.startsWith("origin") ||
	        ((layout || layoutId !== undefined) &&
	            (!!scaleCorrectors[key] || key === "opacity")));
	}

	function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
	    var _a;
	    const { style } = props;
	    const newValues = {};
	    for (const key in style) {
	        if (isMotionValue(style[key]) ||
	            (prevProps.style &&
	                isMotionValue(prevProps.style[key])) ||
	            isForcedMotionValue(key, props) ||
	            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {
	            newValues[key] = style[key];
	        }
	    }
	    return newValues;
	}

	function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
	    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
	    for (const key in props) {
	        if (isMotionValue(props[key]) ||
	            isMotionValue(prevProps[key])) {
	            const targetKey = transformPropOrder.indexOf(key) !== -1
	                ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)
	                : key;
	            newValues[targetKey] = props[key];
	        }
	    }
	    return newValues;
	}

	/**
	 * Creates a constant value over the lifecycle of a component.
	 *
	 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
	 * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
	 * you can ensure that initialisers don't execute twice or more.
	 */
	function useConstant(init) {
	    const ref = reactExports.useRef(null);
	    if (ref.current === null) {
	        ref.current = init();
	    }
	    return ref.current;
	}

	function makeState({ scrapeMotionValuesFromProps, createRenderState, onMount, }, props, context, presenceContext) {
	    const state = {
	        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
	        renderState: createRenderState(),
	    };
	    if (onMount) {
	        state.mount = (instance) => onMount(props, instance, state);
	    }
	    return state;
	}
	const makeUseVisualState = (config) => (props, isStatic) => {
	    const context = reactExports.useContext(MotionContext);
	    const presenceContext = reactExports.useContext(PresenceContext);
	    const make = () => makeState(config, props, context, presenceContext);
	    return isStatic ? make() : useConstant(make);
	};
	function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
	    const values = {};
	    const motionValues = scrapeMotionValues(props, {});
	    for (const key in motionValues) {
	        values[key] = resolveMotionValue(motionValues[key]);
	    }
	    let { initial, animate } = props;
	    const isControllingVariants$1 = isControllingVariants(props);
	    const isVariantNode$1 = isVariantNode(props);
	    if (context &&
	        isVariantNode$1 &&
	        !isControllingVariants$1 &&
	        props.inherit !== false) {
	        if (initial === undefined)
	            initial = context.initial;
	        if (animate === undefined)
	            animate = context.animate;
	    }
	    let isInitialAnimationBlocked = presenceContext
	        ? presenceContext.initial === false
	        : false;
	    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
	    const variantToSet = isInitialAnimationBlocked ? animate : initial;
	    if (variantToSet &&
	        typeof variantToSet !== "boolean" &&
	        !isAnimationControls(variantToSet)) {
	        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
	        for (let i = 0; i < list.length; i++) {
	            const resolved = resolveVariantFromProps(props, list[i]);
	            if (resolved) {
	                const { transitionEnd, transition, ...target } = resolved;
	                for (const key in target) {
	                    let valueTarget = target[key];
	                    if (Array.isArray(valueTarget)) {
	                        /**
	                         * Take final keyframe if the initial animation is blocked because
	                         * we want to initialise at the end of that blocked animation.
	                         */
	                        const index = isInitialAnimationBlocked
	                            ? valueTarget.length - 1
	                            : 0;
	                        valueTarget = valueTarget[index];
	                    }
	                    if (valueTarget !== null) {
	                        values[key] = valueTarget;
	                    }
	                }
	                for (const key in transitionEnd) {
	                    values[key] = transitionEnd[key];
	                }
	            }
	        }
	    }
	    return values;
	}

	const createHtmlRenderState = () => ({
	    style: {},
	    transform: {},
	    transformOrigin: {},
	    vars: {},
	});

	const createSvgRenderState = () => ({
	    ...createHtmlRenderState(),
	    attrs: {},
	});

	/**
	 * Provided a value and a ValueType, returns the value as that value type.
	 */
	const getValueAsType = (value, type) => {
	    return type && typeof value === "number"
	        ? type.transform(value)
	        : value;
	};

	const translateAlias = {
	    x: "translateX",
	    y: "translateY",
	    z: "translateZ",
	    transformPerspective: "perspective",
	};
	const numTransforms = transformPropOrder.length;
	/**
	 * Build a CSS transform style from individual x/y/scale etc properties.
	 *
	 * This outputs with a default order of transforms/scales/rotations, this can be customised by
	 * providing a transformTemplate function.
	 */
	function buildTransform(latestValues, transform, transformTemplate) {
	    // The transform string we're going to build into.
	    let transformString = "";
	    let transformIsDefault = true;
	    /**
	     * Loop over all possible transforms in order, adding the ones that
	     * are present to the transform string.
	     */
	    for (let i = 0; i < numTransforms; i++) {
	        const key = transformPropOrder[i];
	        const value = latestValues[key];
	        if (value === undefined)
	            continue;
	        let valueIsDefault = true;
	        if (typeof value === "number") {
	            valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
	        }
	        else {
	            valueIsDefault = parseFloat(value) === 0;
	        }
	        if (!valueIsDefault || transformTemplate) {
	            const valueAsType = getValueAsType(value, numberValueTypes[key]);
	            if (!valueIsDefault) {
	                transformIsDefault = false;
	                const transformName = translateAlias[key] || key;
	                transformString += `${transformName}(${valueAsType}) `;
	            }
	            if (transformTemplate) {
	                transform[key] = valueAsType;
	            }
	        }
	    }
	    transformString = transformString.trim();
	    // If we have a custom `transform` template, pass our transform values and
	    // generated transformString to that before returning
	    if (transformTemplate) {
	        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
	    }
	    else if (transformIsDefault) {
	        transformString = "none";
	    }
	    return transformString;
	}

	function buildHTMLStyles(state, latestValues, transformTemplate) {
	    const { style, vars, transformOrigin } = state;
	    // Track whether we encounter any transform or transformOrigin values.
	    let hasTransform = false;
	    let hasTransformOrigin = false;
	    /**
	     * Loop over all our latest animated values and decide whether to handle them
	     * as a style or CSS variable.
	     *
	     * Transforms and transform origins are kept separately for further processing.
	     */
	    for (const key in latestValues) {
	        const value = latestValues[key];
	        if (transformProps.has(key)) {
	            // If this is a transform, flag to enable further transform processing
	            hasTransform = true;
	            continue;
	        }
	        else if (isCSSVariableName(key)) {
	            vars[key] = value;
	            continue;
	        }
	        else {
	            // Convert the value to its default value type, ie 0 -> "0px"
	            const valueAsType = getValueAsType(value, numberValueTypes[key]);
	            if (key.startsWith("origin")) {
	                // If this is a transform origin, flag and enable further transform-origin processing
	                hasTransformOrigin = true;
	                transformOrigin[key] =
	                    valueAsType;
	            }
	            else {
	                style[key] = valueAsType;
	            }
	        }
	    }
	    if (!latestValues.transform) {
	        if (hasTransform || transformTemplate) {
	            style.transform = buildTransform(latestValues, state.transform, transformTemplate);
	        }
	        else if (style.transform) {
	            /**
	             * If we have previously created a transform but currently don't have any,
	             * reset transform style to none.
	             */
	            style.transform = "none";
	        }
	    }
	    /**
	     * Build a transformOrigin style. Uses the same defaults as the browser for
	     * undefined origins.
	     */
	    if (hasTransformOrigin) {
	        const { originX = "50%", originY = "50%", originZ = 0, } = transformOrigin;
	        style.transformOrigin = `${originX} ${originY} ${originZ}`;
	    }
	}

	function calcOrigin(origin, offset, size) {
	    return typeof origin === "string"
	        ? origin
	        : px.transform(offset + size * origin);
	}
	/**
	 * The SVG transform origin defaults are different to CSS and is less intuitive,
	 * so we use the measured dimensions of the SVG to reconcile these.
	 */
	function calcSVGTransformOrigin(dimensions, originX, originY) {
	    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
	    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
	    return `${pxOriginX} ${pxOriginY}`;
	}

	const dashKeys = {
	    offset: "stroke-dashoffset",
	    array: "stroke-dasharray",
	};
	const camelKeys = {
	    offset: "strokeDashoffset",
	    array: "strokeDasharray",
	};
	/**
	 * Build SVG path properties. Uses the path's measured length to convert
	 * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
	 * and stroke-dasharray attributes.
	 *
	 * This function is mutative to reduce per-frame GC.
	 */
	function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
	    // Normalise path length by setting SVG attribute pathLength to 1
	    attrs.pathLength = 1;
	    // We use dash case when setting attributes directly to the DOM node and camel case
	    // when defining props on a React component.
	    const keys = useDashCase ? dashKeys : camelKeys;
	    // Build the dash offset
	    attrs[keys.offset] = px.transform(-offset);
	    // Build the dash array
	    const pathLength = px.transform(length);
	    const pathSpacing = px.transform(spacing);
	    attrs[keys.array] = `${pathLength} ${pathSpacing}`;
	}

	/**
	 * Build SVG visual attrbutes, like cx and style.transform
	 */
	function buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, 
	// This is object creation, which we try to avoid per-frame.
	...latest }, isSVGTag, transformTemplate) {
	    buildHTMLStyles(state, latest, transformTemplate);
	    /**
	     * For svg tags we just want to make sure viewBox is animatable and treat all the styles
	     * as normal HTML tags.
	     */
	    if (isSVGTag) {
	        if (state.style.viewBox) {
	            state.attrs.viewBox = state.style.viewBox;
	        }
	        return;
	    }
	    state.attrs = state.style;
	    state.style = {};
	    const { attrs, style, dimensions } = state;
	    /**
	     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
	     * and copy it into style.
	     */
	    if (attrs.transform) {
	        if (dimensions)
	            style.transform = attrs.transform;
	        delete attrs.transform;
	    }
	    // Parse transformOrigin
	    if (dimensions &&
	        (originX !== undefined || originY !== undefined || style.transform)) {
	        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
	    }
	    // Render attrX/attrY/attrScale as attributes
	    if (attrX !== undefined)
	        attrs.x = attrX;
	    if (attrY !== undefined)
	        attrs.y = attrY;
	    if (attrScale !== undefined)
	        attrs.scale = attrScale;
	    // Build SVG path if one has been defined
	    if (pathLength !== undefined) {
	        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
	    }
	}

	const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

	const svgMotionConfig = {
	    useVisualState: makeUseVisualState({
	        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
	        createRenderState: createSvgRenderState,
	        onMount: (props, instance, { renderState, latestValues }) => {
	            frame.read(() => {
	                try {
	                    renderState.dimensions =
	                        typeof instance.getBBox ===
	                            "function"
	                            ? instance.getBBox()
	                            : instance.getBoundingClientRect();
	                }
	                catch (e) {
	                    // Most likely trying to measure an unrendered element under Firefox
	                    renderState.dimensions = {
	                        x: 0,
	                        y: 0,
	                        width: 0,
	                        height: 0,
	                    };
	                }
	            });
	            frame.render(() => {
	                buildSVGAttrs(renderState, latestValues, isSVGTag(instance.tagName), props.transformTemplate);
	                renderSVG(instance, renderState);
	            });
	        },
	    }),
	};

	const htmlMotionConfig = {
	    useVisualState: makeUseVisualState({
	        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
	        createRenderState: createHtmlRenderState,
	    }),
	};

	function copyRawValuesOnly(target, source, props) {
	    for (const key in source) {
	        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
	            target[key] = source[key];
	        }
	    }
	}
	function useInitialMotionValues({ transformTemplate }, visualState) {
	    return reactExports.useMemo(() => {
	        const state = createHtmlRenderState();
	        buildHTMLStyles(state, visualState, transformTemplate);
	        return Object.assign({}, state.vars, state.style);
	    }, [visualState]);
	}
	function useStyle(props, visualState) {
	    const styleProp = props.style || {};
	    const style = {};
	    /**
	     * Copy non-Motion Values straight into style
	     */
	    copyRawValuesOnly(style, styleProp, props);
	    Object.assign(style, useInitialMotionValues(props, visualState));
	    return style;
	}
	function useHTMLProps(props, visualState) {
	    // The `any` isn't ideal but it is the type of createElement props argument
	    const htmlProps = {};
	    const style = useStyle(props, visualState);
	    if (props.drag && props.dragListener !== false) {
	        // Disable the ghost element when a user drags
	        htmlProps.draggable = false;
	        // Disable text selection
	        style.userSelect =
	            style.WebkitUserSelect =
	                style.WebkitTouchCallout =
	                    "none";
	        // Disable scrolling on the draggable direction
	        style.touchAction =
	            props.drag === true
	                ? "none"
	                : `pan-${props.drag === "x" ? "y" : "x"}`;
	    }
	    if (props.tabIndex === undefined &&
	        (props.onTap || props.onTapStart || props.whileTap)) {
	        htmlProps.tabIndex = 0;
	    }
	    htmlProps.style = style;
	    return htmlProps;
	}

	/**
	 * A list of all valid MotionProps.
	 *
	 * @privateRemarks
	 * This doesn't throw if a `MotionProp` name is missing - it should.
	 */
	const validMotionProps = new Set([
	    "animate",
	    "exit",
	    "variants",
	    "initial",
	    "style",
	    "values",
	    "variants",
	    "transition",
	    "transformTemplate",
	    "custom",
	    "inherit",
	    "onBeforeLayoutMeasure",
	    "onAnimationStart",
	    "onAnimationComplete",
	    "onUpdate",
	    "onDragStart",
	    "onDrag",
	    "onDragEnd",
	    "onMeasureDragConstraints",
	    "onDirectionLock",
	    "onDragTransitionEnd",
	    "_dragX",
	    "_dragY",
	    "onHoverStart",
	    "onHoverEnd",
	    "onViewportEnter",
	    "onViewportLeave",
	    "globalTapTarget",
	    "ignoreStrict",
	    "viewport",
	]);
	/**
	 * Check whether a prop name is a valid `MotionProp` key.
	 *
	 * @param key - Name of the property to check
	 * @returns `true` is key is a valid `MotionProp`.
	 *
	 * @public
	 */
	function isValidMotionProp(key) {
	    return (key.startsWith("while") ||
	        (key.startsWith("drag") && key !== "draggable") ||
	        key.startsWith("layout") ||
	        key.startsWith("onTap") ||
	        key.startsWith("onPan") ||
	        key.startsWith("onLayout") ||
	        validMotionProps.has(key));
	}

	let shouldForward = (key) => !isValidMotionProp(key);
	function loadExternalIsValidProp(isValidProp) {
	    if (!isValidProp)
	        return;
	    // Explicitly filter our events
	    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
	}
	/**
	 * Emotion and Styled Components both allow users to pass through arbitrary props to their components
	 * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
	 * of these should be passed to the underlying DOM node.
	 *
	 * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
	 * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
	 * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
	 * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
	 *
	 * By making it an optionalDependency we can offer this functionality only in the situations where it's
	 * actually required.
	 */
	try {
	    /**
	     * We attempt to import this package but require won't be defined in esm environments, in that case
	     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
	     * in favour of explicit injection.
	     */
	    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
	}
	catch (_a) {
	    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
	}
	function filterProps(props, isDom, forwardMotionProps) {
	    const filteredProps = {};
	    for (const key in props) {
	        /**
	         * values is considered a valid prop by Emotion, so if it's present
	         * this will be rendered out to the DOM unless explicitly filtered.
	         *
	         * We check the type as it could be used with the `feColorMatrix`
	         * element, which we support.
	         */
	        if (key === "values" && typeof props.values === "object")
	            continue;
	        if (shouldForward(key) ||
	            (forwardMotionProps === true && isValidMotionProp(key)) ||
	            (!isDom && !isValidMotionProp(key)) ||
	            // If trying to use native HTML drag events, forward drag listeners
	            (props["draggable"] &&
	                key.startsWith("onDrag"))) {
	            filteredProps[key] =
	                props[key];
	        }
	    }
	    return filteredProps;
	}

	function useSVGProps(props, visualState, _isStatic, Component) {
	    const visualProps = reactExports.useMemo(() => {
	        const state = createSvgRenderState();
	        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
	        return {
	            ...state.attrs,
	            style: { ...state.style },
	        };
	    }, [visualState]);
	    if (props.style) {
	        const rawStyles = {};
	        copyRawValuesOnly(rawStyles, props.style, props);
	        visualProps.style = { ...rawStyles, ...visualProps.style };
	    }
	    return visualProps;
	}

	function createUseRender(forwardMotionProps = false) {
	    const useRender = (Component, props, ref, { latestValues }, isStatic) => {
	        const useVisualProps = isSVGComponent(Component)
	            ? useSVGProps
	            : useHTMLProps;
	        const visualProps = useVisualProps(props, latestValues, isStatic, Component);
	        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
	        const elementProps = Component !== reactExports.Fragment
	            ? { ...filteredProps, ...visualProps, ref }
	            : {};
	        /**
	         * If component has been handed a motion value as its child,
	         * memoise its initial value and render that. Subsequent updates
	         * will be handled by the onChange handler
	         */
	        const { children } = props;
	        const renderedChildren = reactExports.useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);
	        return reactExports.createElement(Component, {
	            ...elementProps,
	            children: renderedChildren,
	        });
	    };
	    return useRender;
	}

	function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
	    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {
	        const baseConfig = isSVGComponent(Component)
	            ? svgMotionConfig
	            : htmlMotionConfig;
	        const config = {
	            ...baseConfig,
	            preloadedFeatures,
	            useRender: createUseRender(forwardMotionProps),
	            createVisualElement,
	            Component,
	        };
	        return createRendererMotionComponent(config);
	    };
	}

	// Does this device prefer reduced motion? Returns `null` server-side.
	const prefersReducedMotion = { current: null };
	const hasReducedMotionListener = { current: false };

	function initPrefersReducedMotion() {
	    hasReducedMotionListener.current = true;
	    if (!isBrowser)
	        return;
	    if (window.matchMedia) {
	        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
	        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);
	        motionMediaQuery.addListener(setReducedMotionPreferences);
	        setReducedMotionPreferences();
	    }
	    else {
	        prefersReducedMotion.current = false;
	    }
	}

	function updateMotionValuesFromProps(element, next, prev) {
	    for (const key in next) {
	        const nextValue = next[key];
	        const prevValue = prev[key];
	        if (isMotionValue(nextValue)) {
	            /**
	             * If this is a motion value found in props or style, we want to add it
	             * to our visual element's motion value map.
	             */
	            element.addValue(key, nextValue);
	            /**
	             * Check the version of the incoming motion value with this version
	             * and warn against mismatches.
	             */
	            if (process.env.NODE_ENV === "development") {
	                warnOnce(nextValue.version === "11.15.0", `Attempting to mix Motion versions ${nextValue.version} with 11.15.0 may not work as expected.`);
	            }
	        }
	        else if (isMotionValue(prevValue)) {
	            /**
	             * If we're swapping from a motion value to a static value,
	             * create a new motion value from that
	             */
	            element.addValue(key, motionValue(nextValue, { owner: element }));
	        }
	        else if (prevValue !== nextValue) {
	            /**
	             * If this is a flat value that has changed, update the motion value
	             * or create one if it doesn't exist. We only want to do this if we're
	             * not handling the value with our animation state.
	             */
	            if (element.hasValue(key)) {
	                const existingValue = element.getValue(key);
	                if (existingValue.liveStyle === true) {
	                    existingValue.jump(nextValue);
	                }
	                else if (!existingValue.hasAnimated) {
	                    existingValue.set(nextValue);
	                }
	            }
	            else {
	                const latestValue = element.getStaticValue(key);
	                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));
	            }
	        }
	    }
	    // Handle removed values
	    for (const key in prev) {
	        if (next[key] === undefined)
	            element.removeValue(key);
	    }
	    return next;
	}

	const visualElementStore = new WeakMap();

	/**
	 * A list of all ValueTypes
	 */
	const valueTypes = [...dimensionValueTypes, color, complex];
	/**
	 * Tests a value against the list of ValueTypes
	 */
	const findValueType = (v) => valueTypes.find(testValueType(v));

	const propEventHandlers = [
	    "AnimationStart",
	    "AnimationComplete",
	    "Update",
	    "BeforeLayoutMeasure",
	    "LayoutMeasure",
	    "LayoutAnimationStart",
	    "LayoutAnimationComplete",
	];
	/**
	 * A VisualElement is an imperative abstraction around UI elements such as
	 * HTMLElement, SVGElement, Three.Object3D etc.
	 */
	class VisualElement {
	    /**
	     * This method takes React props and returns found MotionValues. For example, HTML
	     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
	     *
	     * This isn't an abstract method as it needs calling in the constructor, but it is
	     * intended to be one.
	     */
	    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
	        return {};
	    }
	    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {
	        /**
	         * A reference to the current underlying Instance, e.g. a HTMLElement
	         * or Three.Mesh etc.
	         */
	        this.current = null;
	        /**
	         * A set containing references to this VisualElement's children.
	         */
	        this.children = new Set();
	        /**
	         * Determine what role this visual element should take in the variant tree.
	         */
	        this.isVariantNode = false;
	        this.isControllingVariants = false;
	        /**
	         * Decides whether this VisualElement should animate in reduced motion
	         * mode.
	         *
	         * TODO: This is currently set on every individual VisualElement but feels
	         * like it could be set globally.
	         */
	        this.shouldReduceMotion = null;
	        /**
	         * A map of all motion values attached to this visual element. Motion
	         * values are source of truth for any given animated value. A motion
	         * value might be provided externally by the component via props.
	         */
	        this.values = new Map();
	        this.KeyframeResolver = KeyframeResolver;
	        /**
	         * Cleanup functions for active features (hover/tap/exit etc)
	         */
	        this.features = {};
	        /**
	         * A map of every subscription that binds the provided or generated
	         * motion values onChange listeners to this visual element.
	         */
	        this.valueSubscriptions = new Map();
	        /**
	         * A reference to the previously-provided motion values as returned
	         * from scrapeMotionValuesFromProps. We use the keys in here to determine
	         * if any motion values need to be removed after props are updated.
	         */
	        this.prevMotionValues = {};
	        /**
	         * An object containing a SubscriptionManager for each active event.
	         */
	        this.events = {};
	        /**
	         * An object containing an unsubscribe function for each prop event subscription.
	         * For example, every "Update" event can have multiple subscribers via
	         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.
	         */
	        this.propEventSubscriptions = {};
	        this.notifyUpdate = () => this.notify("Update", this.latestValues);
	        this.render = () => {
	            if (!this.current)
	                return;
	            this.triggerBuild();
	            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
	        };
	        this.renderScheduledAt = 0.0;
	        this.scheduleRender = () => {
	            const now = time.now();
	            if (this.renderScheduledAt < now) {
	                this.renderScheduledAt = now;
	                frame.render(this.render, false, true);
	            }
	        };
	        const { latestValues, renderState } = visualState;
	        this.latestValues = latestValues;
	        this.baseTarget = { ...latestValues };
	        this.initialValues = props.initial ? { ...latestValues } : {};
	        this.renderState = renderState;
	        this.parent = parent;
	        this.props = props;
	        this.presenceContext = presenceContext;
	        this.depth = parent ? parent.depth + 1 : 0;
	        this.reducedMotionConfig = reducedMotionConfig;
	        this.options = options;
	        this.blockInitialAnimation = Boolean(blockInitialAnimation);
	        this.isControllingVariants = isControllingVariants(props);
	        this.isVariantNode = isVariantNode(props);
	        if (this.isVariantNode) {
	            this.variantChildren = new Set();
	        }
	        this.manuallyAnimateOnMount = Boolean(parent && parent.current);
	        /**
	         * Any motion values that are provided to the element when created
	         * aren't yet bound to the element, as this would technically be impure.
	         * However, we iterate through the motion values and set them to the
	         * initial values for this component.
	         *
	         * TODO: This is impure and we should look at changing this to run on mount.
	         * Doing so will break some tests but this isn't necessarily a breaking change,
	         * more a reflection of the test.
	         */
	        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
	        for (const key in initialMotionValues) {
	            const value = initialMotionValues[key];
	            if (latestValues[key] !== undefined && isMotionValue(value)) {
	                value.set(latestValues[key], false);
	            }
	        }
	    }
	    mount(instance) {
	        this.current = instance;
	        visualElementStore.set(instance, this);
	        if (this.projection && !this.projection.instance) {
	            this.projection.mount(instance);
	        }
	        if (this.parent && this.isVariantNode && !this.isControllingVariants) {
	            this.removeFromVariantTree = this.parent.addVariantChild(this);
	        }
	        this.values.forEach((value, key) => this.bindToMotionValue(key, value));
	        if (!hasReducedMotionListener.current) {
	            initPrefersReducedMotion();
	        }
	        this.shouldReduceMotion =
	            this.reducedMotionConfig === "never"
	                ? false
	                : this.reducedMotionConfig === "always"
	                    ? true
	                    : prefersReducedMotion.current;
	        if (process.env.NODE_ENV !== "production") {
	            warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
	        }
	        if (this.parent)
	            this.parent.children.add(this);
	        this.update(this.props, this.presenceContext);
	    }
	    unmount() {
	        visualElementStore.delete(this.current);
	        this.projection && this.projection.unmount();
	        cancelFrame(this.notifyUpdate);
	        cancelFrame(this.render);
	        this.valueSubscriptions.forEach((remove) => remove());
	        this.valueSubscriptions.clear();
	        this.removeFromVariantTree && this.removeFromVariantTree();
	        this.parent && this.parent.children.delete(this);
	        for (const key in this.events) {
	            this.events[key].clear();
	        }
	        for (const key in this.features) {
	            const feature = this.features[key];
	            if (feature) {
	                feature.unmount();
	                feature.isMounted = false;
	            }
	        }
	        this.current = null;
	    }
	    bindToMotionValue(key, value) {
	        if (this.valueSubscriptions.has(key)) {
	            this.valueSubscriptions.get(key)();
	        }
	        const valueIsTransform = transformProps.has(key);
	        const removeOnChange = value.on("change", (latestValue) => {
	            this.latestValues[key] = latestValue;
	            this.props.onUpdate && frame.preRender(this.notifyUpdate);
	            if (valueIsTransform && this.projection) {
	                this.projection.isTransformDirty = true;
	            }
	        });
	        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
	        let removeSyncCheck;
	        if (window.MotionCheckAppearSync) {
	            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
	        }
	        this.valueSubscriptions.set(key, () => {
	            removeOnChange();
	            removeOnRenderRequest();
	            if (removeSyncCheck)
	                removeSyncCheck();
	            if (value.owner)
	                value.stop();
	        });
	    }
	    sortNodePosition(other) {
	        /**
	         * If these nodes aren't even of the same type we can't compare their depth.
	         */
	        if (!this.current ||
	            !this.sortInstanceNodePosition ||
	            this.type !== other.type) {
	            return 0;
	        }
	        return this.sortInstanceNodePosition(this.current, other.current);
	    }
	    updateFeatures() {
	        let key = "animation";
	        for (key in featureDefinitions) {
	            const featureDefinition = featureDefinitions[key];
	            if (!featureDefinition)
	                continue;
	            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
	            /**
	             * If this feature is enabled but not active, make a new instance.
	             */
	            if (!this.features[key] &&
	                FeatureConstructor &&
	                isEnabled(this.props)) {
	                this.features[key] = new FeatureConstructor(this);
	            }
	            /**
	             * If we have a feature, mount or update it.
	             */
	            if (this.features[key]) {
	                const feature = this.features[key];
	                if (feature.isMounted) {
	                    feature.update();
	                }
	                else {
	                    feature.mount();
	                    feature.isMounted = true;
	                }
	            }
	        }
	    }
	    triggerBuild() {
	        this.build(this.renderState, this.latestValues, this.props);
	    }
	    /**
	     * Measure the current viewport box with or without transforms.
	     * Only measures axis-aligned boxes, rotate and skew must be manually
	     * removed with a re-render to work.
	     */
	    measureViewportBox() {
	        return this.current
	            ? this.measureInstanceViewportBox(this.current, this.props)
	            : createBox();
	    }
	    getStaticValue(key) {
	        return this.latestValues[key];
	    }
	    setStaticValue(key, value) {
	        this.latestValues[key] = value;
	    }
	    /**
	     * Update the provided props. Ensure any newly-added motion values are
	     * added to our map, old ones removed, and listeners updated.
	     */
	    update(props, presenceContext) {
	        if (props.transformTemplate || this.props.transformTemplate) {
	            this.scheduleRender();
	        }
	        this.prevProps = this.props;
	        this.props = props;
	        this.prevPresenceContext = this.presenceContext;
	        this.presenceContext = presenceContext;
	        /**
	         * Update prop event handlers ie onAnimationStart, onAnimationComplete
	         */
	        for (let i = 0; i < propEventHandlers.length; i++) {
	            const key = propEventHandlers[i];
	            if (this.propEventSubscriptions[key]) {
	                this.propEventSubscriptions[key]();
	                delete this.propEventSubscriptions[key];
	            }
	            const listenerName = ("on" + key);
	            const listener = props[listenerName];
	            if (listener) {
	                this.propEventSubscriptions[key] = this.on(key, listener);
	            }
	        }
	        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
	        if (this.handleChildMotionValue) {
	            this.handleChildMotionValue();
	        }
	    }
	    getProps() {
	        return this.props;
	    }
	    /**
	     * Returns the variant definition with a given name.
	     */
	    getVariant(name) {
	        return this.props.variants ? this.props.variants[name] : undefined;
	    }
	    /**
	     * Returns the defined default transition on this component.
	     */
	    getDefaultTransition() {
	        return this.props.transition;
	    }
	    getTransformPagePoint() {
	        return this.props.transformPagePoint;
	    }
	    getClosestVariantNode() {
	        return this.isVariantNode
	            ? this
	            : this.parent
	                ? this.parent.getClosestVariantNode()
	                : undefined;
	    }
	    /**
	     * Add a child visual element to our set of children.
	     */
	    addVariantChild(child) {
	        const closestVariantNode = this.getClosestVariantNode();
	        if (closestVariantNode) {
	            closestVariantNode.variantChildren &&
	                closestVariantNode.variantChildren.add(child);
	            return () => closestVariantNode.variantChildren.delete(child);
	        }
	    }
	    /**
	     * Add a motion value and bind it to this visual element.
	     */
	    addValue(key, value) {
	        // Remove existing value if it exists
	        const existingValue = this.values.get(key);
	        if (value !== existingValue) {
	            if (existingValue)
	                this.removeValue(key);
	            this.bindToMotionValue(key, value);
	            this.values.set(key, value);
	            this.latestValues[key] = value.get();
	        }
	    }
	    /**
	     * Remove a motion value and unbind any active subscriptions.
	     */
	    removeValue(key) {
	        this.values.delete(key);
	        const unsubscribe = this.valueSubscriptions.get(key);
	        if (unsubscribe) {
	            unsubscribe();
	            this.valueSubscriptions.delete(key);
	        }
	        delete this.latestValues[key];
	        this.removeValueFromRenderState(key, this.renderState);
	    }
	    /**
	     * Check whether we have a motion value for this key
	     */
	    hasValue(key) {
	        return this.values.has(key);
	    }
	    getValue(key, defaultValue) {
	        if (this.props.values && this.props.values[key]) {
	            return this.props.values[key];
	        }
	        let value = this.values.get(key);
	        if (value === undefined && defaultValue !== undefined) {
	            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });
	            this.addValue(key, value);
	        }
	        return value;
	    }
	    /**
	     * If we're trying to animate to a previously unencountered value,
	     * we need to check for it in our state and as a last resort read it
	     * directly from the instance (which might have performance implications).
	     */
	    readValue(key, target) {
	        var _a;
	        let value = this.latestValues[key] !== undefined || !this.current
	            ? this.latestValues[key]
	            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
	        if (value !== undefined && value !== null) {
	            if (typeof value === "string" &&
	                (isNumericalString(value) || isZeroValueString(value))) {
	                // If this is a number read as a string, ie "0" or "200", convert it to a number
	                value = parseFloat(value);
	            }
	            else if (!findValueType(value) && complex.test(target)) {
	                value = getAnimatableNone(key, target);
	            }
	            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
	        }
	        return isMotionValue(value) ? value.get() : value;
	    }
	    /**
	     * Set the base target to later animate back to. This is currently
	     * only hydrated on creation and when we first read a value.
	     */
	    setBaseTarget(key, value) {
	        this.baseTarget[key] = value;
	    }
	    /**
	     * Find the base target for a value thats been removed from all animation
	     * props.
	     */
	    getBaseTarget(key) {
	        var _a;
	        const { initial } = this.props;
	        let valueFromInitial;
	        if (typeof initial === "string" || typeof initial === "object") {
	            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
	            if (variant) {
	                valueFromInitial = variant[key];
	            }
	        }
	        /**
	         * If this value still exists in the current initial variant, read that.
	         */
	        if (initial && valueFromInitial !== undefined) {
	            return valueFromInitial;
	        }
	        /**
	         * Alternatively, if this VisualElement config has defined a getBaseTarget
	         * so we can read the value from an alternative source, try that.
	         */
	        const target = this.getBaseTargetFromProps(this.props, key);
	        if (target !== undefined && !isMotionValue(target))
	            return target;
	        /**
	         * If the value was initially defined on initial, but it doesn't any more,
	         * return undefined. Otherwise return the value as initially read from the DOM.
	         */
	        return this.initialValues[key] !== undefined &&
	            valueFromInitial === undefined
	            ? undefined
	            : this.baseTarget[key];
	    }
	    on(eventName, callback) {
	        if (!this.events[eventName]) {
	            this.events[eventName] = new SubscriptionManager();
	        }
	        return this.events[eventName].add(callback);
	    }
	    notify(eventName, ...args) {
	        if (this.events[eventName]) {
	            this.events[eventName].notify(...args);
	        }
	    }
	}

	class DOMVisualElement extends VisualElement {
	    constructor() {
	        super(...arguments);
	        this.KeyframeResolver = DOMKeyframesResolver;
	    }
	    sortInstanceNodePosition(a, b) {
	        /**
	         * compareDocumentPosition returns a bitmask, by using the bitwise &
	         * we're returning true if 2 in that bitmask is set to true. 2 is set
	         * to true if b preceeds a.
	         */
	        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
	    }
	    getBaseTargetFromProps(props, key) {
	        return props.style
	            ? props.style[key]
	            : undefined;
	    }
	    removeValueFromRenderState(key, { vars, style }) {
	        delete vars[key];
	        delete style[key];
	    }
	    handleChildMotionValue() {
	        if (this.childSubscription) {
	            this.childSubscription();
	            delete this.childSubscription;
	        }
	        const { children } = this.props;
	        if (isMotionValue(children)) {
	            this.childSubscription = children.on("change", (latest) => {
	                if (this.current) {
	                    this.current.textContent = `${latest}`;
	                }
	            });
	        }
	    }
	}

	function getComputedStyle(element) {
	    return window.getComputedStyle(element);
	}
	class HTMLVisualElement extends DOMVisualElement {
	    constructor() {
	        super(...arguments);
	        this.type = "html";
	        this.renderInstance = renderHTML;
	    }
	    readValueFromInstance(instance, key) {
	        if (transformProps.has(key)) {
	            const defaultType = getDefaultValueType(key);
	            return defaultType ? defaultType.default || 0 : 0;
	        }
	        else {
	            const computedStyle = getComputedStyle(instance);
	            const value = (isCSSVariableName(key)
	                ? computedStyle.getPropertyValue(key)
	                : computedStyle[key]) || 0;
	            return typeof value === "string" ? value.trim() : value;
	        }
	    }
	    measureInstanceViewportBox(instance, { transformPagePoint }) {
	        return measureViewportBox(instance, transformPagePoint);
	    }
	    build(renderState, latestValues, props) {
	        buildHTMLStyles(renderState, latestValues, props.transformTemplate);
	    }
	    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
	        return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
	    }
	}

	class SVGVisualElement extends DOMVisualElement {
	    constructor() {
	        super(...arguments);
	        this.type = "svg";
	        this.isSVGTag = false;
	        this.measureInstanceViewportBox = createBox;
	    }
	    getBaseTargetFromProps(props, key) {
	        return props[key];
	    }
	    readValueFromInstance(instance, key) {
	        if (transformProps.has(key)) {
	            const defaultType = getDefaultValueType(key);
	            return defaultType ? defaultType.default || 0 : 0;
	        }
	        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
	        return instance.getAttribute(key);
	    }
	    scrapeMotionValuesFromProps(props, prevProps, visualElement) {
	        return scrapeMotionValuesFromProps(props, prevProps, visualElement);
	    }
	    build(renderState, latestValues, props) {
	        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
	    }
	    renderInstance(instance, renderState, styleProp, projection) {
	        renderSVG(instance, renderState, styleProp, projection);
	    }
	    mount(instance) {
	        this.isSVGTag = isSVGTag(instance.tagName);
	        super.mount(instance);
	    }
	}

	const createDomVisualElement = (Component, options) => {
	    return isSVGComponent(Component)
	        ? new SVGVisualElement(options)
	        : new HTMLVisualElement(options, {
	            allowProjection: Component !== reactExports.Fragment,
	        });
	};

	const createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({
	    ...animations,
	    ...gestureAnimations,
	    ...drag,
	    ...layout,
	}, createDomVisualElement);

	const motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);

	function SecuritySetup(_ref) {
	  let {
	    onComplete
	  } = _ref;
	  const [pin, setPin] = reactExports.useState('');
	  const [securityMethod, setSecurityMethod] = reactExports.useState(null);
	  const [pinRequirements, setPinRequirements] = reactExports.useState({
	    length: false,
	    capital: false,
	    number: false,
	    symbol: false
	  });
	  reactExports.useEffect(() => {
	    // Check PIN requirements
	    setPinRequirements({
	      length: pin.length >= 8,
	      capital: /[A-Z]/.test(pin),
	      number: /[0-9]/.test(pin),
	      symbol: /[!@#$%^&*(),.?":{}|<>]/.test(pin)
	    });
	  }, [pin]);
	  const allRequirementsMet = Object.values(pinRequirements).every(req => req);
	  const handlePinSubmit = async () => {
	    if (allRequirementsMet) {
	      // Here you would typically hash the PIN and store it
	      onComplete({
	        method: 'pin',
	        value: pin
	      });
	    }
	  };
	  const handleOthentSetup = () => {
	    onComplete({
	      method: 'othent'
	    });
	  };
	  return /*#__PURE__*/React$1.createElement(motion.div, {
	    initial: {
	      opacity: 0,
	      y: 20
	    },
	    animate: {
	      opacity: 1,
	      y: 0
	    },
	    className: "flex flex-col items-center space-y-6 p-6"
	  }, /*#__PURE__*/React$1.createElement("h2", {
	    className: "text-xl font-semibold text-gray-900"
	  }, "Secure Your Account"), /*#__PURE__*/React$1.createElement("p", {
	    className: "text-gray-600 text-center"
	  }, "Choose how you want to secure your data"), !securityMethod ? /*#__PURE__*/React$1.createElement("div", {
	    className: "grid grid-cols-1 gap-4 w-full max-w-md"
	  }, /*#__PURE__*/React$1.createElement(motion.button, {
	    whileHover: {
	      scale: 1.02
	    },
	    whileTap: {
	      scale: 0.98
	    },
	    onClick: () => setSecurityMethod('othent'),
	    className: "flex items-center justify-center p-6 rounded-lg border border-gray-300 hover:border-blue-500 bg-white"
	  }, /*#__PURE__*/React$1.createElement("img", {
	    src: "https://onairos.sirv.com/Images/othent-icon.png",
	    alt: "Othent",
	    className: "w-8 h-8 mr-3"
	  }), /*#__PURE__*/React$1.createElement("span", {
	    className: "text-gray-700"
	  }, "Secure with Google (Othent)")), /*#__PURE__*/React$1.createElement(motion.button, {
	    whileHover: {
	      scale: 1.02
	    },
	    whileTap: {
	      scale: 0.98
	    },
	    onClick: () => setSecurityMethod('pin'),
	    className: "flex items-center justify-center p-6 rounded-lg border border-gray-300 hover:border-blue-500 bg-white"
	  }, /*#__PURE__*/React$1.createElement("span", {
	    className: "material-icons mr-3"
	  }, "lock"), /*#__PURE__*/React$1.createElement("span", {
	    className: "text-gray-700"
	  }, "Set up PIN"))) : securityMethod === 'pin' ? /*#__PURE__*/React$1.createElement(motion.div, {
	    initial: {
	      opacity: 0
	    },
	    animate: {
	      opacity: 1
	    },
	    className: "w-full max-w-md space-y-4"
	  }, /*#__PURE__*/React$1.createElement("input", {
	    type: "password",
	    value: pin,
	    onChange: e => setPin(e.target.value),
	    placeholder: "Enter your PIN",
	    className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
	  }), /*#__PURE__*/React$1.createElement("div", {
	    className: "space-y-2"
	  }, Object.entries(pinRequirements).map(_ref2 => {
	    let [req, met] = _ref2;
	    return /*#__PURE__*/React$1.createElement("div", {
	      key: req,
	      className: "flex items-center"
	    }, /*#__PURE__*/React$1.createElement("span", {
	      className: `material-icons text-sm ${met ? 'text-green-500' : 'text-gray-400'}`
	    }, met ? 'check_circle' : 'radio_button_unchecked'), /*#__PURE__*/React$1.createElement("span", {
	      className: `ml-2 text-sm ${met ? 'text-green-600' : 'text-gray-600'}`
	    }, req === 'length' ? 'At least 8 characters' : req === 'capital' ? 'One capital letter' : req === 'number' ? 'One number' : 'One special character'));
	  })), /*#__PURE__*/React$1.createElement("button", {
	    onClick: handlePinSubmit,
	    disabled: !allRequirementsMet,
	    className: `w-full py-3 px-4 rounded-lg font-semibold ${allRequirementsMet ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`
	  }, "Set PIN")) : /*#__PURE__*/React$1.createElement(motion.div, {
	    initial: {
	      opacity: 0
	    },
	    animate: {
	      opacity: 1
	    },
	    className: "w-full max-w-md"
	  }, /*#__PURE__*/React$1.createElement("button", {
	    onClick: handleOthentSetup,
	    className: "w-full py-3 px-4 rounded-lg font-semibold bg-blue-500 text-white hover:bg-blue-600"
	  }, "Continue with Othent")));
	}

	const socialPlatforms = [{
	  name: 'YouTube',
	  icon: 'https://onairos.sirv.com/Images/youtube-icon.png',
	  connected: false
	}, {
	  name: 'Reddit',
	  icon: 'https://onairos.sirv.com/Images/reddit-icon.png',
	  connected: false
	}, {
	  name: 'Instagram',
	  icon: 'https://onairos.sirv.com/Images/instagram-icon.png',
	  connected: false
	}, {
	  name: 'Pinterest',
	  icon: 'https://onairos.sirv.com/Images/pinterest-icon.png',
	  connected: false
	}];
	function UniversalOnboarding(_ref) {
	  let {
	    onComplete
	  } = _ref;
	  const [platforms, setPlatforms] = reactExports.useState(socialPlatforms);
	  const [isUnifying, setIsUnifying] = reactExports.useState(false);
	  const [unifyProgress, setUnifyProgress] = reactExports.useState(0);
	  reactExports.useEffect(() => {
	    if (isUnifying) {
	      const interval = setInterval(() => {
	        setUnifyProgress(prev => {
	          if (prev >= 100) {
	            clearInterval(interval);
	            setIsUnifying(false);
	            onComplete();
	            return 100;
	          }
	          return prev + 2;
	        });
	      }, 100);
	      return () => clearInterval(interval);
	    }
	  }, [isUnifying, onComplete]);
	  const handleConnect = async platformName => {
	    // Implement OAuth flow for each platform
	    try {
	      const response = await fetch(`https://api2.onairos.uk/connect/${platformName.toLowerCase()}`, {
	        method: 'POST',
	        headers: {
	          'Authorization': `Bearer ${localStorage.getItem('onairosToken')}`,
	          'Content-Type': 'application/json'
	        }
	      });
	      if (response.ok) {
	        setPlatforms(platforms.map(p => p.name === platformName ? {
	          ...p,
	          connected: true
	        } : p));
	      }
	    } catch (error) {
	      console.error(`Failed to connect to ${platformName}:`, error);
	    }
	  };
	  const handleUnify = async () => {
	    if (platforms.some(p => p.connected)) {
	      setIsUnifying(true);
	      try {
	        const response = await fetch('https://api2.onairos.uk/unify', {
	          method: 'POST',
	          headers: {
	            'Authorization': `Bearer ${localStorage.getItem('onairosToken')}`,
	            'Content-Type': 'application/json'
	          }
	        });
	        if (response.ok) {
	          onComplete();
	        }
	      } catch (error) {
	        console.error('Failed to unify data:', error);
	      }
	    }
	  };
	  if (isUnifying) {
	    return /*#__PURE__*/React$1.createElement(motion.div, {
	      initial: {
	        opacity: 0
	      },
	      animate: {
	        opacity: 1
	      },
	      className: "flex flex-col items-center justify-center space-y-6 p-6"
	    }, /*#__PURE__*/React$1.createElement("h2", {
	      className: "text-xl font-semibold text-gray-900"
	    }, "Unifying Your Data"), /*#__PURE__*/React$1.createElement("p", {
	      className: "text-gray-600 text-center"
	    }, "Please wait while we process your information"), /*#__PURE__*/React$1.createElement("div", {
	      className: "w-full max-w-md"
	    }, /*#__PURE__*/React$1.createElement("div", {
	      className: "relative pt-1"
	    }, /*#__PURE__*/React$1.createElement("div", {
	      className: "flex mb-2 items-center justify-between"
	    }, /*#__PURE__*/React$1.createElement("div", null, /*#__PURE__*/React$1.createElement("span", {
	      className: "text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200"
	    }, "Progress")), /*#__PURE__*/React$1.createElement("div", {
	      className: "text-right"
	    }, /*#__PURE__*/React$1.createElement("span", {
	      className: "text-xs font-semibold inline-block text-blue-600"
	    }, unifyProgress, "%"))), /*#__PURE__*/React$1.createElement(motion.div, {
	      className: "overflow-hidden h-2 mb-4 text-xs flex rounded bg-blue-200"
	    }, /*#__PURE__*/React$1.createElement(motion.div, {
	      initial: {
	        width: 0
	      },
	      animate: {
	        width: `${unifyProgress}%`
	      },
	      transition: {
	        duration: 0.5
	      },
	      className: "shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-blue-500"
	    })))), /*#__PURE__*/React$1.createElement(motion.div, {
	      animate: {
	        rotate: 360
	      },
	      transition: {
	        duration: 2,
	        repeat: Infinity,
	        ease: "linear"
	      },
	      className: "w-12 h-12"
	    }, /*#__PURE__*/React$1.createElement("svg", {
	      className: "w-full h-full text-blue-500",
	      viewBox: "0 0 24 24"
	    }, /*#__PURE__*/React$1.createElement("path", {
	      fill: "currentColor",
	      d: "M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z"
	    }))));
	  }
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "flex flex-col items-center space-y-6 p-6"
	  }, /*#__PURE__*/React$1.createElement("h2", {
	    className: "text-xl font-semibold text-gray-900"
	  }, "Connect Your Accounts"), /*#__PURE__*/React$1.createElement("p", {
	    className: "text-gray-600 text-center"
	  }, "Connect at least one account to create your personality model"), /*#__PURE__*/React$1.createElement("div", {
	    className: "grid grid-cols-2 gap-4 w-full max-w-md"
	  }, platforms.map(platform => /*#__PURE__*/React$1.createElement("button", {
	    key: platform.name,
	    onClick: () => handleConnect(platform.name),
	    className: `flex items-center justify-center p-4 rounded-lg border ${platform.connected ? 'bg-green-50 border-green-500' : 'border-gray-300 hover:border-blue-500'}`
	  }, /*#__PURE__*/React$1.createElement("img", {
	    src: platform.icon,
	    alt: platform.name,
	    className: "w-8 h-8 mr-2"
	  }), /*#__PURE__*/React$1.createElement("span", {
	    className: platform.connected ? 'text-green-600' : 'text-gray-700'
	  }, platform.connected ? 'Connected' : `Connect ${platform.name}`)))), /*#__PURE__*/React$1.createElement("button", {
	    onClick: handleUnify,
	    disabled: !platforms.some(p => p.connected),
	    className: `w-full max-w-md py-3 px-4 rounded-lg font-semibold ${platforms.some(p => p.connected) ? 'bg-blue-500 text-white hover:bg-blue-600' : 'bg-gray-300 text-gray-500 cursor-not-allowed'}`
	  }, "Unify and Create Model"));
	}

	function SignUp(_ref) {
	  let {
	    onSignUpSuccess,
	    setOthent,
	    setHashedOthentSub,
	    setEncryptedPin
	  } = _ref;
	  const [formData, setFormData] = reactExports.useState({
	    email: '',
	    username: '',
	    password: '',
	    confirmPassword: ''
	  });
	  const [error, setError] = reactExports.useState(null);
	  const handleInputChange = e => {
	    setFormData({
	      ...formData,
	      [e.target.name]: e.target.value
	    });
	  };
	  const handleSubmit = async e => {
	    e.preventDefault();
	    if (formData.password !== formData.confirmPassword) {
	      setError("Passwords don't match");
	      return;
	    }
	    try {
	      const response = await fetch('https://api2.onairos.uk/signup', {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify({
	          email: formData.email,
	          username: formData.username,
	          password: formData.password
	        })
	      });
	      const data = await response.json();
	      if (response.ok) {
	        localStorage.setItem('onairosToken', data.token);
	        localStorage.setItem('username', formData.username);
	        onSignUpSuccess(formData.username);
	      } else {
	        setError(data.message || 'Sign up failed');
	      }
	    } catch (error) {
	      setError('Sign up failed. Please try again.');
	    }
	  };
	  return /*#__PURE__*/React$1.createElement("div", {
	    className: "flex flex-col items-center justify-start max-w-sm mx-auto space-y-6 pt-4"
	  }, error && /*#__PURE__*/React$1.createElement("div", {
	    className: "w-full bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg"
	  }, error), /*#__PURE__*/React$1.createElement(AuthButtons, {
	    onLoginSuccess: onSignUpSuccess,
	    setOthent: setOthent,
	    setHashedOthentSub: setHashedOthentSub,
	    setEncryptedPin: setEncryptedPin
	  }), /*#__PURE__*/React$1.createElement("div", {
	    className: "w-full flex items-center justify-center space-x-4"
	  }, /*#__PURE__*/React$1.createElement("hr", {
	    className: "flex-grow border-gray-300"
	  }), /*#__PURE__*/React$1.createElement("span", {
	    className: "text-gray-500"
	  }, "or"), /*#__PURE__*/React$1.createElement("hr", {
	    className: "flex-grow border-gray-300"
	  })), /*#__PURE__*/React$1.createElement("form", {
	    onSubmit: handleSubmit,
	    className: "w-full space-y-4"
	  }, /*#__PURE__*/React$1.createElement("input", {
	    type: "email",
	    name: "email",
	    value: formData.email,
	    onChange: handleInputChange,
	    placeholder: "Email",
	    className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	    required: true
	  }), /*#__PURE__*/React$1.createElement("input", {
	    type: "text",
	    name: "username",
	    value: formData.username,
	    onChange: handleInputChange,
	    placeholder: "Username",
	    className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	    required: true
	  }), /*#__PURE__*/React$1.createElement("input", {
	    type: "password",
	    name: "password",
	    value: formData.password,
	    onChange: handleInputChange,
	    placeholder: "Password",
	    className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	    required: true
	  }), /*#__PURE__*/React$1.createElement("input", {
	    type: "password",
	    name: "confirmPassword",
	    value: formData.confirmPassword,
	    onChange: handleInputChange,
	    placeholder: "Confirm Password",
	    className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	    required: true
	  }), /*#__PURE__*/React$1.createElement("button", {
	    type: "submit",
	    className: "w-full bg-blue-500 text-white font-semibold py-3 px-4 rounded-lg hover:bg-blue-600 transition-colors"
	  }, "Sign Up")));
	}

	function Overlay(_ref) {
	  let {
	    setOthentConnected,
	    dataRequester,
	    NoAccount,
	    NoModel,
	    activeModels,
	    avatar,
	    setAvatar,
	    traits,
	    setTraits,
	    requestData,
	    handleConnectionSelection,
	    changeGranted,
	    granted,
	    allowSubmit,
	    rejectDataRequest,
	    sendDataRequest,
	    isAuthenticated,
	    onClose,
	    onLoginSuccess,
	    setOthentUser,
	    setHashedOthentSub,
	    setEncryptedPin,
	    accountInfo
	  } = _ref;
	  const [loginError, setLoginError] = reactExports.useState(null);
	  const [loading, setLoading] = reactExports.useState(false);
	  const overlayRef = reactExports.useRef(null);

	  // Manages Checkboxes
	  // Maintain the `isChecked` state for all checkboxes in the parent
	  const [checkedStates, setCheckedStates] = reactExports.useState({});
	  const handleCheckboxChange = (key, isChecked) => {
	    console.log(key, " is being changed check to:", isChecked);
	    setCheckedStates(prevState => ({
	      ...prevState,
	      [key]: isChecked
	    }));
	    // Call the `changeGranted` function accordingly
	    changeGranted(isChecked ? 1 : -1);

	    // Call the `handleConnectionSelection` function
	    const product = requestData[key];
	    handleConnectionSelection(dataRequester, key, product.index, product.type, product.reward, isChecked);
	    console.log(product, " Selection registered");
	    handleConnectionSelection(dataRequester, key, product.index, product.type, product.reward, true);
	  };
	  const [currentView, setCurrentView] = reactExports.useState(() => {
	    if (isAuthenticated) {
	      if (accountInfo && accountInfo.models?.length > 0) {
	        return 'datarequests';
	      }
	      return 'onboarding';
	    }
	    return 'login';
	  });
	  const [formData, setFormData] = reactExports.useState({
	    username: '',
	    password: ''
	  });
	  const [loginCompleted, setLoginCompleted] = reactExports.useState(false);
	  const API_URL = 'https://api2.onairos.uk';

	  // Set dynamic viewport height
	  reactExports.useEffect(() => {
	    const setVH = () => {
	      const vh = window.innerHeight * 0.01;
	      document.documentElement.style.setProperty('--vh', `${vh}px`);
	    };
	    setVH();
	    window.addEventListener('resize', setVH);
	    window.addEventListener('orientationchange', setVH);
	    return () => {
	      window.removeEventListener('resize', setVH);
	      window.removeEventListener('orientationchange', setVH);
	    };
	  }, []);
	  const handleClose = () => {
	    onClose();
	  };

	  // Handle click outside
	  reactExports.useEffect(() => {
	    const handleClickOutside = event => {
	      if (overlayRef.current && !overlayRef.current.contains(event.target)) {
	        handleClose?.();
	      }
	    };
	    document.addEventListener('mousedown', handleClickOutside);
	    document.addEventListener('touchstart', handleClickOutside);
	    return () => {
	      document.removeEventListener('mousedown', handleClickOutside);
	      document.removeEventListener('touchstart', handleClickOutside);
	    };
	  }, [handleClose]);
	  const handleInputChange = e => {
	    setFormData({
	      ...formData,
	      [e.target.name]: e.target.value
	    });
	  };
	  const handleOnairosLogin = async e => {
	    e.preventDefault();
	    try {
	      setLoginError(null);
	      const loginAttempt = {
	        details: {
	          username: formData.username,
	          password: formData.password
	        }
	      };
	      const response = await fetch(`${API_URL}/login`, {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify(loginAttempt)
	      });
	      const data = await response.json();
	      if (data.authentication === 'Accepted') {
	        localStorage.setItem('onairosToken', data.token);
	        localStorage.setItem('username', formData.username);
	        await handleLoginSuccess(formData.username);
	      } else {
	        throw new Error('Invalid credentials');
	      }
	    } catch (error) {
	      console.error('Login failed:', error);
	      setLoginError('Invalid username or password');
	    }
	  };
	  const handleLoginSuccess = async function (identifier) {
	    let isEmail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    setLoading(true);
	    try {
	      const result = await onLoginSuccess(identifier, isEmail);
	      setLoginError(null);
	    } catch (error) {
	      console.error('Login process failed:', error);
	      setLoginError('Failed to complete login process');
	    } finally {
	      setLoading(false);
	    }
	  };
	  const handleOnboardingComplete = () => {
	    setCurrentView('security');
	  };
	  const handleSecurityComplete = securityDetails => {
	    // Handle security setup completion
	    if (securityDetails.method === 'othent') {
	      setOthentUser(true);
	    } else if (securityDetails.method === 'pin') {
	      setEncryptedPin(securityDetails.value);
	    }
	    setCurrentView('datarequests');
	  };
	  const DataRequestsSection = _ref2 => {
	    let {
	      dataRequester,
	      granted,
	      allowSubmit,
	      rejectDataRequest,
	      sendDataRequest,
	      activeModels,
	      requestData,
	      handleConnectionSelection,
	      changeGranted,
	      avatar,
	      traits
	    } = _ref2;
	    return /*#__PURE__*/React.createElement("div", {
	      className: "flex flex-col h-full"
	    }, /*#__PURE__*/React.createElement("div", {
	      className: "px-6"
	    }, /*#__PURE__*/React.createElement("h1", {
	      className: "text-lg font-semibold text-gray-900 mb-6"
	    }, "Data Requests from ", dataRequester), /*#__PURE__*/React.createElement("div", {
	      className: "flex items-center justify-between mb-6"
	    }, /*#__PURE__*/React.createElement("button", {
	      className: "bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-8 rounded-full",
	      onClick: rejectDataRequest
	    }, "Reject All"), /*#__PURE__*/React.createElement("button", {
	      disabled: !allowSubmit || granted === 0,
	      className: `${allowSubmit && granted > 0 ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-300 cursor-not-allowed'} text-white font-bold py-2 px-8 rounded-full`,
	      onClick: sendDataRequest
	    }, "Confirm (", granted, ")"))), /*#__PURE__*/React.createElement("div", {
	      className: "flex-1 overflow-y-auto px-6"
	    }, activeModels.length === 0 ? /*#__PURE__*/React.createElement("div", {
	      className: "flex flex-col items-center justify-center py-8"
	    }, /*#__PURE__*/React.createElement("img", {
	      src: "https://onairos.sirv.com/Images/OnairosWhite.png",
	      alt: "Onairos Logo",
	      className: "w-24 h-24 mb-4"
	    }), /*#__PURE__*/React.createElement("p", {
	      className: "text-center text-gray-800 font-medium"
	    }, "Please connect ", /*#__PURE__*/React.createElement("a", {
	      href: "https://onairos.uk/connections",
	      className: "text-blue-500 hover:underline"
	    }, "Onairos"), " Personality to send ", dataRequester, " your data")) : /*#__PURE__*/React.createElement("div", {
	      className: "space-y-4"
	    }, Object.keys(requestData).sort((a, b) => {
	      const aIsActive = activeModels.includes(requestData[a].type);
	      const bIsActive = activeModels.includes(requestData[b].type);
	      if (requestData[a].type === "Avatar") return 1;
	      if (requestData[b].type === "Avatar") return -1;
	      if (requestData[b].type === "Traits") return 1;
	      if (requestData[a].type === "Traits") return -1;
	      if (aIsActive && !bIsActive) return -1;
	      if (bIsActive && !aIsActive) return 1;
	      return 0;
	    }).map((key, index) => {
	      const product = requestData[key];
	      const active = product.type === 'Personality' ? activeModels.includes(product.type) : product.type === 'Avatar' ? avatar : product.type === 'Traits' ? traits : false;
	      return /*#__PURE__*/React.createElement(IndividualConnection, {
	        key: key,
	        active: active,
	        title: product.type,
	        id: product,
	        number: index,
	        descriptions: product.descriptions,
	        rewards: product.reward,
	        size: key,
	        isChecked: !!checkedStates[key] // Pass the state from the parent
	        ,
	        onCheckboxChange: isChecked => handleCheckboxChange(key, isChecked) // Handle the change
	      });
	    }))));
	  };
	  const renderContent = () => {
	    switch (currentView) {
	      case 'signup':
	        return /*#__PURE__*/React.createElement(SignUp, {
	          onSignUpSuccess: handleLoginSuccess,
	          setOthentUser: setOthentUser,
	          setHashedOthentSub: setHashedOthentSub,
	          setEncryptedPin: setEncryptedPin
	        });
	      case 'onboarding':
	        return /*#__PURE__*/React.createElement(UniversalOnboarding, {
	          onComplete: handleOnboardingComplete
	        });
	      case 'security':
	        return /*#__PURE__*/React.createElement(SecuritySetup, {
	          onComplete: handleSecurityComplete
	        });
	      case 'datarequests':
	        return /*#__PURE__*/React.createElement(DataRequestsSection, {
	          dataRequester: dataRequester,
	          granted: granted,
	          allowSubmit: allowSubmit,
	          rejectDataRequest: rejectDataRequest,
	          sendDataRequest: sendDataRequest,
	          activeModels: activeModels,
	          requestData: requestData,
	          handleConnectionSelection: handleConnectionSelection,
	          changeGranted: changeGranted,
	          avatar: avatar,
	          traits: traits
	        });
	      default:
	        return /*#__PURE__*/React.createElement("div", {
	          className: "flex flex-col items-center justify-start max-w-sm mx-auto space-y-6 pt-4"
	        }, loginError && /*#__PURE__*/React.createElement("div", {
	          className: "w-full bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg"
	        }, loginError), /*#__PURE__*/React.createElement(AuthButtons, {
	          onLoginSuccess: handleLoginSuccess,
	          setOthentUser: setOthentUser,
	          setHashedOthentSub: setHashedOthentSub,
	          setEncryptedPin: setEncryptedPin
	        }), /*#__PURE__*/React.createElement("div", {
	          className: "w-full flex items-center justify-center space-x-4"
	        }, /*#__PURE__*/React.createElement("hr", {
	          className: "flex-grow border-gray-300"
	        }), /*#__PURE__*/React.createElement("span", {
	          className: "text-gray-500"
	        }, "or"), /*#__PURE__*/React.createElement("hr", {
	          className: "flex-grow border-gray-300"
	        })), /*#__PURE__*/React.createElement("form", {
	          onSubmit: handleOnairosLogin,
	          className: "w-full space-y-4"
	        }, /*#__PURE__*/React.createElement("input", {
	          type: "text",
	          name: "username",
	          value: formData.username,
	          onChange: handleInputChange,
	          placeholder: "Username",
	          className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	          required: true
	        }), /*#__PURE__*/React.createElement("input", {
	          type: "password",
	          name: "password",
	          value: formData.password,
	          onChange: handleInputChange,
	          placeholder: "Password",
	          className: "w-full px-4 py-3 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500",
	          required: true
	        }), /*#__PURE__*/React.createElement("button", {
	          type: "submit",
	          className: "w-full bg-blue-500 text-white font-semibold py-3 px-4 rounded-lg hover:bg-blue-600 transition-colors"
	        }, "Sign In")), /*#__PURE__*/React.createElement("button", {
	          onClick: () => setCurrentView('signup'),
	          className: "w-full text-center text-blue-500 hover:text-blue-600"
	        }, "Don't have an account? Sign up"));
	    }
	  };
	  reactExports.useEffect(() => {
	    if (isAuthenticated && accountInfo) {
	      if (accountInfo.models?.length > 0) {
	        setCurrentView('datarequests');
	      } else {
	        setCurrentView('onboarding');
	      }
	    }
	  }, [isAuthenticated, accountInfo]);
	  reactExports.useEffect(() => {
	    return () => {
	      setLoginCompleted(false);
	    };
	  }, []);
	  reactExports.useEffect(() => {}, [isAuthenticated, accountInfo]);

	  // if (loading) {
	  //   return (
	  //     <>
	  //       <div className="fixed inset-0 bg-black bg-opacity-50" />
	  //       <div 
	  //         ref={overlayRef} 
	  //         className="fixed bottom-0 left-0 right-0 w-full bg-white rounded-t-3xl shadow-2xl transform transition-transform duration-300 ease-out flex items-center justify-center"
	  //         style={{ height: 'calc(var(--vh, 1vh) * 50)' }}
	  //       >
	  //         <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
	  //       </div>
	  //     </>
	  //   );
	  // }

	  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
	    className: "fixed inset-0 bg-black bg-opacity-50",
	    onClick: handleClose,
	    style: {
	      touchAction: 'none'
	    }
	  }), /*#__PURE__*/React.createElement("div", {
	    ref: overlayRef,
	    className: "fixed bottom-0 left-0 right-0 w-full bg-white rounded-t-3xl shadow-2xl transform transition-transform duration-300 ease-out flex flex-col",
	    style: {
	      maxHeight: '60vh',
	      minHeight: '45vh',
	      height: 'auto',
	      touchAction: 'none'
	    }
	  }, /*#__PURE__*/React.createElement("div", {
	    className: "sticky top-0 bg-white z-10 px-6 pt-3 pb-2"
	  }, /*#__PURE__*/React.createElement("div", {
	    className: "w-12 h-1.5 bg-gray-300 rounded-full mx-auto"
	  })), /*#__PURE__*/React.createElement("div", {
	    className: "flex-1 overflow-y-auto px-6 pb-8",
	    style: {
	      touchAction: 'pan-y'
	    }
	  }, renderContent())));
	}

	class z extends Error {
	  constructor(t, n, r) {
	    super(typeof n == "object" ? n.message : n || t, {
	      cause: typeof n == "object" ? n.cause : r
	    }), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, z.prototype);
	  }
	}
	function Do(e) {
	  return e.replace(/_[a-z]/g, t => t[1].toUpperCase());
	}
	const xo = "ERR_INVALID_VALUE",
	  Mo = "ERR_UNEXPECTED_VALUE",
	  jo = "ERR_UNEXPECTED_TYPE",
	  Jn = "ERR_PARSE";
	function Yn(e, t) {
	  const n = {};
	  for (const r in e) {
	    const o = e[r];
	    if (!o) continue;
	    let s, a;
	    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
	    try {
	      const i = a(t(s));
	      i !== void 0 && (n[r] = i);
	    } catch (i) {
	      throw new z(Jn, `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`, i);
	    }
	  }
	  return n;
	}
	function Qn(e) {
	  let t = e;
	  if (typeof t == "string") try {
	    t = JSON.parse(t);
	  } catch (n) {
	    throw new z(xo, {
	      cause: n
	    });
	  }
	  if (typeof t != "object" || !t || Array.isArray(t)) throw new z(Mo);
	  return t;
	}
	function q(e, t) {
	  return n => {
	    const r = o => {
	      if (!(n && o === void 0)) try {
	        return t(o);
	      } catch (s) {
	        throw new z(Jn, {
	          message: `"${e}" transformer failed to parse the value`,
	          cause: s
	        });
	      }
	    };
	    return /* @__PURE__ */Object.assign(r, {
	      isValid(o) {
	        try {
	          return r(o), !0;
	        } catch {
	          return !1;
	        }
	      }
	    });
	  };
	}
	function Ue(e, t) {
	  return q(t || "object", n => {
	    const r = Qn(n);
	    return Yn(e, o => r[o]);
	  });
	}
	function Re(e) {
	  throw new z(jo, `Unexpected value received: ${JSON.stringify(e)}`);
	}
	const N = q("string", e => {
	    if (typeof e == "string" || typeof e == "number") return e.toString();
	    Re(e);
	  });
	function _e(e) {
	  return /^#[\da-f]{6}$/i.test(e);
	}
	function No(e) {
	  return /^#[\da-f]{3}$/i.test(e);
	}
	function Zn(e) {
	  const t = e.replace(/\s/g, "").toLowerCase();
	  if (_e(t)) return t;
	  if (No(t)) {
	    let r = "#";
	    for (let o = 0; o < 3; o += 1) r += t[1 + o].repeat(2);
	    return r;
	  }
	  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
	  if (!n) throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
	  return n.slice(1).reduce((r, o) => {
	    const s = parseInt(o, 10).toString(16);
	    return r + (s.length === 1 ? "0" : "") + s;
	  }, "#");
	}
	const qo = q("rgb", e => Zn(N()(e))),
	  Uo = q("themeParams", e => {
	    const t = qo(!0);
	    return Object.entries(Qn(e)).reduce((n, [r, o]) => (n[Do(r)] = t(o), n), {});
	  });
	function $o(e, t) {
	  return q("array", n => {
	    let r;
	    if (Array.isArray(n)) r = n;else if (typeof n == "string") try {
	      const o = JSON.parse(n);
	      Array.isArray(o) && (r = o);
	    } catch {}
	    return r || Re(n), r.map(e);
	  });
	}
	class G extends Error {
	  constructor(t, n, r) {
	    super(typeof n == "object" ? n.message : n || t, {
	      cause: typeof n == "object" ? n.cause : r
	    }), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, G.prototype);
	  }
	}
	function er(e) {
	  return e.replace(/[A-Z]/g, t => `_${t.toLowerCase()}`);
	}
	function Fo(e) {
	  return e.replace(/_[a-z]/g, t => t[1].toUpperCase());
	}
	const Ho = "ERR_INVALID_VALUE",
	  Wo = "ERR_UNEXPECTED_VALUE",
	  zo = "ERR_UNEXPECTED_TYPE",
	  tr = "ERR_PARSE";
	function nr(e, t) {
	  const n = {};
	  for (const r in e) {
	    const o = e[r];
	    if (!o) continue;
	    let s, a;
	    typeof o == "function" ? (s = r, a = o) : [s, a] = o;
	    try {
	      const i = a(t(s));
	      i !== void 0 && (n[r] = i);
	    } catch (i) {
	      throw new G(tr, `Parser for "${r}" property failed${s === r ? "" : `. Source field: "${s}"`}`, i);
	    }
	  }
	  return n;
	}
	function rr(e) {
	  let t = e;
	  if (typeof t == "string") try {
	    t = JSON.parse(t);
	  } catch (n) {
	    throw new G(Ho, {
	      cause: n
	    });
	  }
	  if (typeof t != "object" || !t || Array.isArray(t)) throw new G(Wo);
	  return t;
	}
	function D(e, t) {
	  return n => {
	    const r = o => {
	      if (!(n && o === void 0)) try {
	        return t(o);
	      } catch (s) {
	        throw new G(tr, {
	          message: `"${e}" transformer failed to parse the value`,
	          cause: s
	        });
	      }
	    };
	    return /* @__PURE__ */Object.assign(r, {
	      isValid(o) {
	        try {
	          return r(o), !0;
	        } catch {
	          return !1;
	        }
	      }
	    });
	  };
	}
	function O(e, t) {
	  return D(t || "object", n => {
	    const r = rr(n);
	    return nr(e, o => r[o]);
	  });
	}
	function Te(e) {
	  throw new G(zo, `Unexpected value received: ${JSON.stringify(e)}`);
	}
	const Fe = D("boolean", e => {
	    if (typeof e == "boolean") return e;
	    const t = String(e);
	    if (t === "1" || t === "true") return !0;
	    if (t === "0" || t === "false") return !1;
	    Te(e);
	  }),
	  B = D("string", e => {
	    if (typeof e == "string" || typeof e == "number") return e.toString();
	    Te(e);
	  }),
	  fe = D("number", e => {
	    if (typeof e == "number") return e;
	    if (typeof e == "string") {
	      const t = Number(e);
	      if (!Number.isNaN(t)) return t;
	    }
	    Te(e);
	  }),
	  Go = D("date", e => e instanceof Date ? e : new Date(fe()(e) * 1e3));
	function or(e, t) {
	  return D(t || "searchParams", n => {
	    typeof n != "string" && !(n instanceof URLSearchParams) && Te(n);
	    const r = typeof n == "string" ? new URLSearchParams(n) : n;
	    return nr(e, o => {
	      const s = r.get(o);
	      return s === null ? void 0 : s;
	    });
	  });
	}
	function ht(e) {
	  for (const t in e) e[t] = [er(t), e[t]];
	  return e;
	}
	const Jo = e => {
	  const t = fe(),
	    n = fe(!0),
	    r = B(),
	    o = B(!0),
	    s = Fe(!0),
	    a = O(ht({
	      addedToAttachmentMenu: s,
	      allowsWriteToPm: s,
	      firstName: r,
	      id: t,
	      isBot: s,
	      isPremium: s,
	      languageCode: o,
	      lastName: o,
	      photoUrl: o,
	      username: o
	    }), "User")(!0);
	  return or(ht({
	    authDate: Go(),
	    canSendAfter: n,
	    chat: O(ht({
	      id: t,
	      type: r,
	      title: r,
	      photoUrl: o,
	      username: o
	    }), "Chat")(!0),
	    chatInstance: o,
	    chatType: o,
	    hash: r,
	    queryId: o,
	    receiver: a,
	    startParam: o,
	    signature: r,
	    user: a
	  }), "initData")(e);
	};
	function Yo(e) {
	  return /^#[\da-f]{6}$/i.test(e);
	}
	function Qo(e) {
	  return /^#[\da-f]{3}$/i.test(e);
	}
	function Ko(e) {
	  const t = e.replace(/\s/g, "").toLowerCase();
	  if (Yo(t)) return t;
	  if (Qo(t)) {
	    let r = "#";
	    for (let o = 0; o < 3; o += 1) r += t[1 + o].repeat(2);
	    return r;
	  }
	  const n = t.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)$/) || t.match(/^rgba\((\d{1,3}),(\d{1,3}),(\d{1,3}),\d{1,3}\)$/);
	  if (!n) throw new Error(`Value "${e}" does not satisfy any of known RGB formats.`);
	  return n.slice(1).reduce((r, o) => {
	    const s = parseInt(o, 10).toString(16);
	    return r + (s.length === 1 ? "0" : "") + s;
	  }, "#");
	}
	const Zo = D("rgb", e => Ko(B()(e))),
	  Rn = D("themeParams", e => {
	    const t = Zo(!0);
	    return Object.entries(rr(e)).reduce((n, [r, o]) => (n[Fo(r)] = t(o), n), {});
	  });
	// @__NO_SIDE_EFFECTS__
	function vt(e) {
	  return JSON.stringify(Object.fromEntries(Object.entries(e).map(([t, n]) => [er(t), n])));
	}
	const Xo = e => {
	  const t = B(),
	    n = B(!0),
	    r = Fe(!0);
	  return or({
	    botInline: ["tgWebAppBotInline", r],
	    defaultColors: ["tgWebAppDefaultColors", Rn(!0)],
	    fullscreen: ["tgWebAppFullscreen", r],
	    initData: ["tgWebAppData", Jo(!0)],
	    initDataRaw: ["tgWebAppData", n],
	    platform: ["tgWebAppPlatform", t],
	    showSettings: ["tgWebAppShowSettings", r],
	    startParam: ["tgWebAppStartParam", n],
	    themeParams: ["tgWebAppThemeParams", Rn()],
	    version: ["tgWebAppVersion", t]
	  }, "launchParams")(e);
	};
	// @__NO_SIDE_EFFECTS__
	function es(e) {
	  const {
	      initDataRaw: t,
	      startParam: n,
	      showSettings: r,
	      botInline: o,
	      fullscreen: s,
	      defaultColors: a
	    } = e,
	    i = new URLSearchParams();
	  return i.set("tgWebAppPlatform", e.platform), i.set("tgWebAppThemeParams", /* @__PURE__ */vt(e.themeParams)), i.set("tgWebAppVersion", e.version), t && i.set("tgWebAppData", t), n && i.set("tgWebAppStartParam", n), typeof r == "boolean" && i.set("tgWebAppShowSettings", r ? "1" : "0"), typeof o == "boolean" && i.set("tgWebAppBotInline", o ? "1" : "0"), typeof s == "boolean" && i.set("tgWebAppFullscreen", s ? "1" : "0"), a && i.set("tgWebAppDefaultColors", /* @__PURE__ */vt(a)), i.toString();
	}
	const sr = O({
	    eventType: B(),
	    eventData: e => e
	  }, "miniAppsMessage"),
	  ar = D("fn", e => {
	    if (typeof e == "function") return e;
	    Te(e);
	  });
	const ns = O({
	  TelegramWebviewProxy: O({
	    postEvent: ar()
	  })()
	});
	function ir(e) {
	  return ns().isValid(e);
	}
	function rs() {
	  try {
	    return window.self !== window.top;
	  } catch {
	    return !0;
	  }
	}
	var os = Object.defineProperty,
	  ss = (e, t, n) => t in e ? os(e, t, {
	    enumerable: !0,
	    configurable: !0,
	    writable: !0,
	    value: n
	  }) : e[t] = n,
	  cr = (e, t, n) => ss(e, typeof t != "symbol" ? t + "" : t, n);
	let p = class ur extends Error {
	  constructor(t, n, r) {
	    super(typeof n == "object" ? n.message : n || t, {
	      cause: typeof n == "object" ? n.cause : r
	    }), this.type = t, this.name = "TypedError", Object.setPrototypeOf(this, ur.prototype);
	  }
	};
	function pr(e, t, n) {
	  return e.addEventListener(t, n), () => e.removeEventListener(t, n);
	}
	function ne(...e) {
	  const t = e.flat(1);
	  return [t.push.bind(t), () => {
	    t.forEach(n => {
	      n();
	    });
	  }];
	}
	const lr = "ERR_ABORTED",
	  dr = "ERR_CANCELED",
	  _r = "ERR_TIMED_OUT";
	function Tn(e) {
	  return new p(lr, {
	    cause: e
	  });
	}
	function Bn(e, t) {
	  return e.reject = t.reject, e;
	}
	class b extends Promise {
	  constructor(t, n) {
	    let r, o;
	    typeof t == "function" ? (r = t, o = n) : o = t;
	    let s, a;
	    super((i, l) => {
	      o || (o = {});
	      const {
	        abortSignal: u
	      } = o;
	      if (u && u.aborted) return l(Tn(u.reason));
	      const [f, y] = ne(),
	        v = m => (...W) => (y(), m(...W)),
	        L = new AbortController(),
	        {
	          signal: R
	        } = L;
	      a = v(m => {
	        L.abort(m), l(m);
	      }), s = v(i), u && f(pr(u, "abort", () => {
	        a(Tn(u.reason));
	      }));
	      const {
	        timeout: g
	      } = o;
	      if (g) {
	        const m = setTimeout(() => {
	          a(new p(_r, `Timeout reached: ${g}ms`));
	        }, g);
	        f(() => {
	          clearTimeout(m);
	        });
	      }
	      r && r(s, a, R);
	    }), cr(this, "reject"), this.reject = a;
	  }
	  /**
	   * Creates a new BetterPromise instance using executor, resolving promise when a result
	   * was returned.
	   * @param fn - function returning promise result.
	   * @param options - additional options.
	   */
	  static withFn(t, n) {
	    return new b((r, o, s) => {
	      try {
	        const a = t(s);
	        return a instanceof Promise ? a.then(r, o) : r(a);
	      } catch (a) {
	        o(a);
	      }
	    }, n);
	  }
	  /**
	   * @see Promise.resolve
	   */
	  static resolve(t) {
	    return new b(n => {
	      n(t);
	    });
	  }
	  /**
	   * @see Promise.reject
	   */
	  static reject(t) {
	    return new b((n, r) => {
	      r(t);
	    });
	  }
	  /**
	   * Cancels the promise execution.
	   */
	  cancel() {
	    this.reject(new p(dr));
	  }
	  /**
	   * @see Promise.catch
	   */
	  catch(t) {
	    return this.then(void 0, t);
	  }
	  /**
	   * @see Promise.finally
	   */
	  finally(t) {
	    return Bn(super.finally(t), this);
	  }
	  /**
	   * @see Promise.then
	   */
	  then(t, n) {
	    return Bn(super.then(t, n), this);
	  }
	}
	function Pn(e, t) {
	  return e.resolve = t.resolve, e;
	}
	let is = class Oe extends b {
	  constructor(t, n) {
	    let r, o;
	    typeof t == "function" ? (r = t, o = n) : o = t;
	    let s;
	    super((a, i, l) => {
	      s = a, r && r(a, i, l);
	    }, o), cr(this, "resolve"), this.resolve = s;
	  }
	  /**
	   * Creates a new EnhancedPromise instance using executor, resolving promise when a result
	   * was returned.
	   * @param fn - function returning promise result.
	   * @param options - additional options.
	   */
	  static withFn(t, n) {
	    return new Oe((r, o, s) => b.withFn(t, {
	      abortSignal: s
	    }).then(r, o), n);
	  }
	  /**
	   * @see Promise.resolve
	   */
	  static resolve(t) {
	    return new Oe(n => {
	      n(t);
	    });
	  }
	  /**
	   * @see Promise.reject
	   */
	  static reject(t) {
	    return new Oe((n, r) => {
	      r(t);
	    });
	  }
	  /**
	   * @see Promise.catch
	   */
	  catch(t) {
	    return this.then(void 0, t);
	  }
	  /**
	   * @see Promise.finally
	   */
	  finally(t) {
	    return Pn(super.finally(t), this);
	  }
	  /**
	   * @see Promise.then
	   */
	  then(t, n) {
	    return Pn(super.then(t, n), this);
	  }
	};
	function fr(e) {
	  return `tapps/${e}`;
	}
	function P(e, t) {
	  sessionStorage.setItem(fr(e), JSON.stringify(t));
	}
	function k(e) {
	  const t = sessionStorage.getItem(fr(e));
	  try {
	    return t ? JSON.parse(t) : void 0;
	  } catch {}
	}
	function Lt(e) {
	  return e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`);
	}
	// @__NO_SIDE_EFFECTS__
	function us(e, t) {
	  t || (t = {});
	  const {
	    textColor: n,
	    bgColor: r,
	    shouldLog: o = !0
	  } = t;
	  function s(a, ...i) {
	    if (!o || typeof o == "function" && !o()) return;
	    const l = "font-weight:bold;padding:0 5px;border-radius:5px";
	    console[a](`%c${Intl.DateTimeFormat("en-GB", {
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      fractionalSecondDigits: 3,
      timeZone: "UTC"
    }).format(new Date())}%c / %c${e}`, `${l};background-color: lightblue;color:black`, "", `${l};${n ? `color:${n};` : ""}${r ? `background-color:${r}` : ""}`, ...i);
	  }
	  return [function (...a) {
	    s("log", ...a);
	  }, function (...a) {
	    s("error", ...a);
	  }];
	}
	function Vt(e, t) {
	  document.documentElement.style.setProperty(e, t);
	}
	function Nt(e) {
	  document.documentElement.style.removeProperty(e);
	}
	function ps(e, t) {
	  t();
	}
	// @__NO_SIDE_EFFECTS__
	function re(e, t) {
	  t || (t = {});
	  const n = t.equals || Object.is;
	  let r = [],
	    o = e;
	  const s = u => {
	    if (!n(o, u)) {
	      const f = o;
	      o = u, ps(l, () => {
	        [...r].forEach(([y, v]) => {
	          y(u, f), v && i(y, !0);
	        });
	      });
	    }
	  };
	  function a(u) {
	    const f = typeof u != "object" ? {
	      once: u
	    } : u;
	    return {
	      once: f.once || !1,
	      signal: f.signal || !1
	    };
	  }
	  const i = (u, f) => {
	      const y = a(f),
	        v = r.findIndex(([L, R]) => L === u && R.once === y.once && R.signal === y.signal);
	      v >= 0 && r.splice(v, 1);
	    },
	    l = Object.assign(function () {
	      return ls(l), o;
	    }, {
	      destroy() {
	        r = [];
	      },
	      set: s,
	      reset() {
	        s(e);
	      },
	      sub(u, f) {
	        return r.push([u, a(f)]), () => i(u, f);
	      },
	      unsub: i,
	      unsubAll() {
	        r = r.filter(u => u[1].signal);
	      }
	    });
	  return l;
	}
	const bt = [];
	function ls(e) {
	  bt.length && bt[bt.length - 1].add(e);
	}
	const ds = /* @__PURE__ */re(!1),
	  [qt, _s] = /* @__PURE__ */us("Bridge", {
	    bgColor: "#9147ff",
	    textColor: "white",
	    shouldLog: ds
	  }),
	  fs = {
	    clipboard_text_received: O({
	      req_id: B(),
	      data: e => e === null ? e : B(!0)(e)
	    }, "clipboard_text_received"),
	    custom_method_invoked: O({
	      req_id: B(),
	      result: e => e,
	      error: B(!0)
	    }, "custom_method_invoked"),
	    popup_closed: D("popup_closed", e => e ? O({
	      button_id: t => t == null ? void 0 : B()(t)
	    })()(e) : {}),
	    viewport_changed: O({
	      height: fe(),
	      width: e => e == null ? window.innerWidth : fe()(e),
	      is_state_stable: Fe(),
	      is_expanded: Fe()
	    }, "viewport_changed")
	  };
	function ms(e) {
	  const t = window,
	    [, n] = ne(
	    // Add listener, which handles events sent from the Telegram web application and also events
	    // generated by the local emitEvent function.
	    pr(t, "message", r => {
	      if (r.source !== t.parent) return;
	      let o;
	      try {
	        o = sr()(r.data);
	      } catch {
	        return;
	      }
	      const {
	          eventType: s,
	          eventData: a
	        } = o,
	        i = fs[s];
	      try {
	        const l = i ? i()(a) : a;
	        qt("Event received:", l ? {
	          eventType: s,
	          eventData: l
	        } : {
	          eventType: s
	        }), e([s, l]);
	      } catch (l) {
	        _s([`An error occurred processing the "${s}" event from the Telegram application.`, "Please, file an issue here:", "https://github.com/Telegram-Mini-Apps/telegram-apps/issues/new/choose"].join(`
`), o, l);
	      }
	    }));
	  return n;
	}
	const At = /* @__PURE__ */re(),
	  kn = /* @__PURE__ */re();
	function mr() {
	  return kn() || kn.set(ms(At.set)), At;
	}
	const gt = /* @__PURE__ */re({});
	function hr(e) {
	  let t = gt()[e];
	  return t || (t = /* @__PURE__ */re(void 0, {
	    equals() {
	      return !1;
	    }
	  }), mr().sub(n => {
	    n && n[0] === e && t.set(n[1]);
	  }), gt.set({
	    ...gt(),
	    [e]: t
	  })), t;
	}
	function w(e, t, n) {
	  return hr(e).sub(t, n);
	}
	const bs = "ERR_RETRIEVE_LP_FAILED",
	  br = "ERR_UNKNOWN_ENV",
	  ws = "ERR_INVOKE_CUSTOM_METHOD_RESPONSE",
	  ys = /* @__PURE__ */re("https://web.telegram.org");
	function Ut(e, t) {
	  qt("Posting event:", t ? {
	    eventType: e,
	    eventData: t
	  } : {
	    eventType: e
	  });
	  const n = window;
	  if (ir(n)) {
	    n.TelegramWebviewProxy.postEvent(e, JSON.stringify(t));
	    return;
	  }
	  const r = JSON.stringify({
	    eventType: e,
	    eventData: t
	  });
	  if (rs()) return n.parent.postMessage(r, ys());
	  const {
	    external: o
	  } = n;
	  if (O({
	    notify: ar()
	  })().isValid(o)) {
	    o.notify(r);
	    return;
	  }
	  throw new p(br);
	}
	function $t(e, t, n) {
	  n || (n = {});
	  const {
	      capture: r
	    } = n,
	    [o, s] = ne();
	  return new b(a => {
	    (Array.isArray(t) ? t : [t]).forEach(i => {
	      o(w(i, l => {
	        (!r || (Array.isArray(t) ? r({
	          event: i,
	          payload: l
	        }) : r(l))) && a(l);
	      }));
	    }), (n.postEvent || Ut)(e, n.params);
	  }, n).finally(s);
	}
	function Ft(e) {
	  return Xo()(e);
	}
	function gr(e) {
	  return Ft(e.replace(/^[^?#]*[?#]/, "").replace(/[?#]/g, "&"));
	}
	function Ss() {
	  return gr(window.location.href);
	}
	function Es() {
	  const e = performance.getEntriesByType("navigation")[0];
	  if (!e) throw new Error("Unable to get first navigation entry.");
	  return gr(e.name);
	}
	const vs = "launchParams";
	function As() {
	  return Ft(k(vs) || "");
	}
	function wr(e) {
	  P("launchParams", /* @__PURE__ */es(e));
	}
	function yr(e) {
	  return e instanceof Error ? e.message + (e.cause ? `
  ${yr(e.cause)}` : "") : JSON.stringify(e);
	}
	function Y() {
	  const e = [];
	  for (const t of [
	  // Try to retrieve launch parameters from the current location. This method can return
	  // nothing in case, location was changed, and then the page was reloaded.
	  Ss,
	  // Then, try using the lower level API - window.performance.
	  Es,
	  // Finally, try to extract launch parameters from the session storage.
	  As]) try {
	    const n = t();
	    return wr(n), n;
	  } catch (n) {
	    e.push(n);
	  }
	  throw new p(bs, ["Unable to retrieve launch parameters from any known source. Perhaps, you have opened your app outside Telegram?", "📖 Refer to docs for more information:", "https://docs.telegram-mini-apps.com/packages/telegram-apps-bridge/environment", "Collected errors:", ...e.map(t => `— ${yr(t)}`)].join(`
`));
	}
	function In(e) {
	  if (e === "simple") try {
	    return Y(), !0;
	  } catch {
	    return !1;
	  }
	  return b.withFn(async () => {
	    if (ir(window)) return !0;
	    try {
	      return await $t("web_app_request_theme", "theme_changed", {
	        timeout: 100
	      }), !0;
	    } catch {
	      return !1;
	    }
	  }, e);
	}
	function C(e, t, n) {
	  hr(e).unsub(t, n);
	}
	function Sr(e) {
	  return ({
	    req_id: t
	  }) => t === e;
	}
	function On(e) {
	  return e.split(".").map(Number);
	}
	function Bs(e, t) {
	  const n = On(e),
	    r = On(t),
	    o = Math.max(n.length, r.length);
	  for (let s = 0; s < o; s += 1) {
	    const a = n[s] || 0,
	      i = r[s] || 0;
	    if (a !== i) return a > i ? 1 : -1;
	  }
	  return 0;
	}
	function S(e, t) {
	  return Bs(e, t) <= 0;
	}
	function J(e, t, n) {
	  if (typeof n == "string") {
	    if (e === "web_app_open_link") {
	      if (t === "try_instant_view") return S("6.4", n);
	      if (t === "try_browser") return S("7.6", n);
	    }
	    if (e === "web_app_set_header_color" && t === "color") return S("6.9", n);
	    if (e === "web_app_close" && t === "return_back") return S("7.6", n);
	    if (e === "web_app_setup_main_button" && t === "has_shine_effect") return S("7.10", n);
	  }
	  switch (e) {
	    case "web_app_open_tg_link":
	    case "web_app_open_invoice":
	    case "web_app_setup_back_button":
	    case "web_app_set_background_color":
	    case "web_app_set_header_color":
	    case "web_app_trigger_haptic_feedback":
	      return S("6.1", t);
	    case "web_app_open_popup":
	      return S("6.2", t);
	    case "web_app_close_scan_qr_popup":
	    case "web_app_open_scan_qr_popup":
	    case "web_app_read_text_from_clipboard":
	      return S("6.4", t);
	    case "web_app_switch_inline_query":
	      return S("6.7", t);
	    case "web_app_invoke_custom_method":
	    case "web_app_request_write_access":
	    case "web_app_request_phone":
	      return S("6.9", t);
	    case "web_app_setup_settings_button":
	      return S("6.10", t);
	    case "web_app_biometry_get_info":
	    case "web_app_biometry_open_settings":
	    case "web_app_biometry_request_access":
	    case "web_app_biometry_request_auth":
	    case "web_app_biometry_update_token":
	      return S("7.2", t);
	    case "web_app_setup_swipe_behavior":
	      return S("7.7", t);
	    case "web_app_share_to_story":
	      return S("7.8", t);
	    case "web_app_setup_secondary_button":
	    case "web_app_set_bottom_bar_color":
	      return S("7.10", t);
	    case "web_app_request_safe_area":
	    case "web_app_request_content_safe_area":
	    case "web_app_request_fullscreen":
	    case "web_app_exit_fullscreen":
	    case "web_app_set_emoji_status":
	    case "web_app_add_to_home_screen":
	    case "web_app_check_home_screen":
	    case "web_app_request_emoji_status_access":
	      return S("8.0", t);
	    default:
	      return ["iframe_ready", "iframe_will_reload", "web_app_close", "web_app_data_send", "web_app_expand", "web_app_open_link", "web_app_ready", "web_app_request_theme", "web_app_request_viewport", "web_app_setup_main_button", "web_app_setup_closing_behavior"].includes(e);
	  }
	}
	function ks(e, t, n, r) {
	  return $t("web_app_invoke_custom_method", "custom_method_invoked", {
	    ...(r || {}),
	    params: {
	      method: e,
	      params: t,
	      req_id: n
	    },
	    capture: Sr(n)
	  }).then(({
	    result: o,
	    error: s
	  }) => {
	    if (s) throw new p(ws, s);
	    return o;
	  });
	}
	function Is() {
	  return performance.getEntriesByType("navigation")[0];
	}
	function x() {
	  const e = Is();
	  return !!e && e.type === "reload";
	}
	let X;
	function Os(e, t) {
	  X && X.set(e, t) || t();
	}
	function Rt(e) {
	  if (X) return e();
	  X = /* @__PURE__ */new Map();
	  try {
	    e();
	  } finally {
	    X.forEach(t => t()), X = void 0;
	  }
	}
	// @__NO_SIDE_EFFECTS__
	function c(e, t) {
	  t || (t = {});
	  const n = t.equals || Object.is;
	  let r = [],
	    o = e;
	  const s = u => {
	    if (!n(o, u)) {
	      const f = o;
	      o = u, Os(l, () => {
	        [...r].forEach(([y, v]) => {
	          y(u, f), v && i(y, !0);
	        });
	      });
	    }
	  };
	  function a(u) {
	    const f = typeof u != "object" ? {
	      once: u
	    } : u;
	    return {
	      once: f.once || !1,
	      signal: f.signal || !1
	    };
	  }
	  const i = (u, f) => {
	      const y = a(f),
	        v = r.findIndex(([L, R]) => L === u && R.once === y.once && R.signal === y.signal);
	      v >= 0 && r.splice(v, 1);
	    },
	    l = Object.assign(function () {
	      return Ds(l), o;
	    }, {
	      destroy() {
	        r = [];
	      },
	      set: s,
	      reset() {
	        s(e);
	      },
	      sub(u, f) {
	        return r.push([u, a(f)]), () => i(u, f);
	      },
	      unsub: i,
	      unsubAll() {
	        r = r.filter(u => u[1].signal);
	      }
	    });
	  return l;
	}
	const ue = [];
	function Ds(e) {
	  ue.length && ue[ue.length - 1].add(e);
	}
	// @__NO_SIDE_EFFECTS__
	function d(e, t) {
	  let n = /* @__PURE__ */new Set(),
	    r;
	  function o() {
	    return r || (r = /* @__PURE__ */c(a(), t));
	  }
	  function s() {
	    o().set(a());
	  }
	  function a() {
	    n.forEach(u => {
	      u.unsub(s, {
	        signal: !0
	      });
	    });
	    const i = /* @__PURE__ */new Set();
	    let l;
	    ue.push(i);
	    try {
	      l = e();
	    } finally {
	      ue.pop();
	    }
	    return i.forEach(u => {
	      u.sub(s, {
	        signal: !0
	      });
	    }), n = i, l;
	  }
	  return Object.assign(function () {
	    return o()();
	  }, {
	    destroy() {
	      o().destroy();
	    },
	    sub(...i) {
	      return o().sub(...i);
	    },
	    unsub(...i) {
	      o().unsub(...i);
	    },
	    unsubAll(...i) {
	      o().unsubAll(...i);
	    }
	  });
	}
	const xs = /* @__PURE__ */c(/* @__PURE__ */(() => {
	    let e = 0;
	    return () => (e += 1).toString();
	  })()),
	  Er = /* @__PURE__ */c(Ut),
	  V = /* @__PURE__ */c("0.0");
	function vr() {
	  return xs()();
	}
	function oe(e, t, n) {
	  return ks(e, t, vr(), {
	    ...(n || {}),
	    postEvent: _
	  });
	}
	const E = (e, t, n) => (n || (n = {}), n.postEvent || (n.postEvent = _), $t(e, t, n)),
	  _ = (e, t) => Er()(e, t);
	const ce = "ERR_POPUP_INVALID_PARAMS",
	  Ht = "ERR_INVALID_URL",
	  js = "ERR_INVALID_SLUG",
	  F = "ERR_ALREADY_REQUESTING",
	  Wt = "ERR_ALREADY_OPENED",
	  Ns = "ERR_ALREADY_MOUNTING",
	  qs = "ERR_VARS_ALREADY_BOUND",
	  Us = "ERR_NOT_AVAILABLE",
	  $s = "ERR_NOT_INITIALIZED",
	  Dn = "ERR_NOT_SUPPORTED",
	  Fs = "ERR_NOT_MOUNTED",
	  Hs = "ERR_FULLSCREEN_FAILED";
	function xn() {
	  return typeof window > "u";
	}
	// @__NO_SIDE_EFFECTS__
	function h(e, t, {
	  isSupported: n,
	  isMounted: r,
	  component: o,
	  supports: s
	} = {}) {
	  const a = `${o ? `${o}.` : ""}${e}()`;
	  n = n ? Array.isArray(n) || typeof n == "object" && "any" in n ? n : [n] : void 0;
	  function i(g) {
	    if (s) {
	      const m = s[g];
	      return J(m[0], m[1], V());
	    }
	    return !0;
	  }
	  const l = () => {
	      if (!n) return;
	      const g = `it is unsupported in Mini Apps version ${V()}`;
	      function m(T) {
	        return typeof T == "string" ? J(T, V()) ? void 0 : g : T.fn() ? void 0 : T.error;
	      }
	      if (Array.isArray(n)) {
	        for (const T of n) {
	          const An = m(T);
	          if (An) return An;
	        }
	        return;
	      }
	      let W;
	      for (const T of n.any) if (W = m(T), !W) return;
	      return g;
	    },
	    u = (...g) => {
	      if (s) {
	        for (const m in s) if (s[m][2](...g) && !i(m)) return `option ${m} is not supported in Mini Apps version ${V()}`;
	      }
	    },
	    f = /* @__PURE__ */d(() => !l()),
	    y = /* @__PURE__ */d(() => V() !== "0.0"),
	    v = /* @__PURE__ */d(() => !r || r()),
	    L = /* @__PURE__ */d(() => In("simple") && !xn() && y() && f() && v());
	  let R;
	  if (s) {
	    R = {};
	    for (const g in s) R[g] = /* @__PURE__ */d(() => i(g));
	  }
	  return Object.assign((...g) => {
	    const m = `Unable to call the ${a} ${o ? "method" : "function"}:`;
	    if (xn() || !In("simple")) throw new p(br, `${m} it can't be called outside Mini Apps`);
	    if (!y()) throw new p($s, `${m} the SDK was not initialized. Use the SDK init() function`);
	    const W = l();
	    if (W) throw new p(Dn, `${m} ${W}`);
	    const T = u(...g);
	    if (T) throw new p(Dn, `${m} ${T}`);
	    if (!v()) throw new p(Fs, `${m} the component is not mounted. Use the ${o}.mount() method`);
	    return t(...g);
	  }, t, {
	    isAvailable: L,
	    ifAvailable(...g) {
	      return L() ? t(...g) : void 0;
	    }
	  }, n ? {
	    isSupported: f
	  } : {}, R ? {
	    supports: R
	  } : {});
	}
	function We(e, t) {
	  return t || (t = {}), (n, r, o, s) => /* @__PURE__ */h(n, r, {
	    ...t,
	    isSupported: o || t.isSupported,
	    supports: s,
	    component: e
	  });
	}
	function Q(e, t, n) {
	  return We(e, {
	    isSupported: n,
	    isMounted: t
	  });
	}
	function I(e, t) {
	  return We(e, {
	    isSupported: t
	  });
	}
	const ze = "web_app_setup_back_button",
	  Ar = "back_button_pressed",
	  Ge = "backButton",
	  Tt = /* @__PURE__ */c(!1),
	  me = /* @__PURE__ */c(!1),
	  Cr = Q(Ge, me, ze),
	  zt = I(Ge, ze);
	  Cr("hide", () => {
	    Gt(!1);
	  });
	  zt("mount", () => {
	    me() || (Gt(x() && k(Ge) || !1), me.set(!0));
	  });
	function Gt(e) {
	  e !== Tt() && (_(ze, {
	    is_visible: e
	  }), P(Ge, e), Tt.set(e));
	}
	zt("onClick", e => w(Ar, e));
	  zt("offClick", e => {
	    C(Ar, e);
	  });
	  Cr("show", () => {
	    Gt(!0);
	  });
	// @__NO_SIDE_EFFECTS__
	function Be(e, t, n, r, o) {
	  const s = o === void 0 || o ? b : Promise;
	  return Object.assign((...a) => s.resolve().then(async () => {
	    if (n()) {
	      const l = t();
	      throw r.set(l), l;
	    }
	    Rt(() => {
	      n.set(s.resolve(e(...a))), r.set(void 0);
	    });
	    let i;
	    try {
	      i = [!0, await n()];
	    } catch (l) {
	      i = [!1, l];
	    }
	    if (Rt(() => {
	      n.set(void 0), r.set(i[0] ? void 0 : i[1]);
	    }), !i[0]) throw i[1];
	    return i[1];
	  }), e);
	}
	// @__NO_SIDE_EFFECTS__
	function Rr(e, t, n, r, o, s) {
	  const a = /* @__PURE__ */Be(t, () => new p(Ns, `The ${e} component is already mounting`), o, s);
	  return i => b.resolve().then(async () => {
	    if (!r()) {
	      const l = await a(i);
	      Rt(() => {
	        r.set(!0), n(l);
	      });
	    }
	  });
	}
	const U = We,
	  Je = /* @__PURE__ */c({
	    available: !1
	  }),
	  De = /* @__PURE__ */c(!1),
	  xe = /* @__PURE__ */c(!1),
	  Ye = /* @__PURE__ */c(!1),
	  Tr = /* @__PURE__ */c(),
	  Jt = /* @__PURE__ */c();
	function Yt(e) {
	  return e.available ? {
	    available: !0,
	    tokenSaved: e.token_saved,
	    deviceId: e.device_id,
	    accessRequested: e.access_requested,
	    type: e.type,
	    accessGranted: e.access_granted
	  } : {
	    available: !1
	  };
	}
	const Mn = "web_app_biometry_get_info",
	  ta = /* @__PURE__ */h("requestBiometry", e => E(Mn, "biometry_info_received", e).then(Yt), {
	    isSupported: Mn
	  }),
	  Qe = "web_app_biometry_request_auth",
	  na = "web_app_biometry_request_access",
	  ra = "web_app_biometry_open_settings",
	  oa = "web_app_biometry_update_token",
	  Qt = "biometry_info_received",
	  te = "biometry",
	  aa = U(te),
	  ia = I(te, Qe),
	  Kt = Q(te, Ye, Qe);
	function Br() {
	  throw new p(Us, "Biometry is not available");
	}
	Kt("authenticate", e => b.withFn(async t => {
	    if (De()) throw new p(F, "Authentication is already in progress");
	    const n = Je();
	    (!n || !n.available) && Br(), De.set(!0);
	    try {
	      const r = await E(Qe, "biometry_auth_requested", {
	          abortSignal: t,
	          params: {
	            reason: ((e || {}).reason || "").trim()
	          }
	        }),
	        {
	          token: o
	        } = r;
	      return typeof o == "string" && Ke({
	        ...n,
	        token: o
	      }), r;
	    } finally {
	      De.set(!1);
	    }
	  }, e));
	  ia("openSettings", () => {
	    _(ra);
	  });
	  Kt("requestAccess", e => b.withFn(async t => {
	    if (xe()) throw new p(F, "Access request is already in progress");
	    xe.set(!0);
	    try {
	      const n = await E(na, Qt, {
	        abortSignal: t,
	        params: {
	          reason: (e || {}).reason || ""
	        }
	      }).then(Yt);
	      return n.available || Br(), Ke(n), n.accessGranted;
	    } finally {
	      xe.set(!1);
	    }
	  }, e));
	  aa("mount", /* @__PURE__ */Rr(te, e => x() && k(te) || ta(e), e => {
	    w(Qt, Pr), Ke(e);
	  }, Ye, Jt, Tr));
	  const Pr = e => {
	    Ke(Yt(e));
	  };
	function Ke(e) {
	  Je.set(e), P(te, e);
	}
	Kt("updateToken", e => (e || (e = {}), E(oa, "biometry_token_updated", {
	    ...e,
	    params: {
	      token: e.token || "",
	      reason: e.reason
	    }
	  }).then(t => t.status)));
	function Ze(e, t) {
	  return We(e, {
	    isMounted: t
	  });
	}
	const Xe = "closingBehavior",
	  Bt = /* @__PURE__ */c(!1),
	  he = /* @__PURE__ */c(!1),
	  kr = Ze(Xe, he),
	  fa = U(Xe);
	  kr("disableConfirmation", () => {
	    Zt(!1);
	  });
	  kr("enableConfirmation", () => {
	    Zt(!0);
	  });
	  fa("mount", () => {
	    he() || (Zt(x() && k(Xe) || !1), he.set(!0));
	  });
	function Zt(e) {
	  e !== Bt() && (_("web_app_setup_closing_behavior", {
	    need_confirmation: e
	  }), P(Xe, e), Bt.set(e));
	}
	const Ir = "web_app_invoke_custom_method",
	  et = I("cloudStorage", Ir);
	  et("deleteItem", (e, t) => {
	    const n = Array.isArray(e) ? e : [e];
	    return n.length ? oe("deleteStorageValues", {
	      keys: n
	    }, t).then() : b.resolve();
	  });
	function Sa(e, t) {
	  const n = Array.isArray(e) ? e : [e];
	  return n.length ? oe("getStorageValues", {
	    keys: n
	  }, t).then(r => {
	    const o = Ue(Object.fromEntries(n.map(s => [s, N()])))()(r);
	    return Array.isArray(e) ? o : o[e];
	  }) : b.resolve(typeof e == "string" ? "" : {});
	}
	et("getItem", Sa);
	  et("getKeys", e => oe("getStorageKeys", {}, e).then($o(N())()));
	  et("setItem", (e, t, n) => oe("saveStorageValue", {
	    key: e,
	    value: t
	  }, n).then());
	  const Pe = "web_app_trigger_haptic_feedback",
	  Xt = I("hapticFeedback", Pe);
	  Xt("impactOccurred", e => {
	    _(Pe, {
	      type: "impact",
	      impact_style: e
	    });
	  });
	  Xt("notificationOccurred", e => {
	    _(Pe, {
	      type: "notification",
	      notification_type: e
	    });
	  });
	  Xt("selectionChanged", () => {
	    _(Pe, {
	      type: "selection_change"
	    });
	  });
	const tn = "web_app_open_invoice",
	  Na = I("invoice", tn),
	  Me = /* @__PURE__ */c(!1);
	async function Mr(e, t, n) {
	  if (Me()) throw new p(Wt, "An invoice is already opened");
	  let r;
	  if (t === "url") {
	    const {
	      hostname: o,
	      pathname: s
	    } = new URL(e, window.location.href);
	    if (o !== "t.me") throw new p(Ht, `Link has unexpected hostname: ${o}`);
	    const a = s.match(/^\/(\$|invoice\/)([A-Za-z0-9\-_=]+)$/);
	    if (!a) throw new p(js, 'Expected to receive a link with a pathname in format "/invoice/{slug}" or "/${slug}"');
	    [,, r] = a;
	  } else r = e, n = t;
	  return Me.set(!0), E(tn, "invoice_closed", {
	    ...n,
	    params: {
	      slug: r
	    },
	    capture: o => r === o.slug
	  }).then(o => o.status).finally(() => {
	    Me.set(!1);
	  });
	}
	Na("open", Mr);
	function jr(e) {
	  return Object.fromEntries(Object.entries(e).filter(t => t[1] !== void 0));
	}
	const be = /* @__PURE__ */c(!1),
	  je = /* @__PURE__ */c(!1),
	  $ = /* @__PURE__ */c({});
	function A(e) {
	  return /* @__PURE__ */d(() => $()[e]);
	}
	const nn = A("bgColor"),
	  rn = A("buttonColor"),
	  Vr = A("buttonTextColor"),
	  Nr = A("bottomBarBgColor"),
	  He = A("secondaryBgColor");
	const pe = /* @__PURE__ */c({
	    hasShineEffect: !1,
	    isEnabled: !0,
	    isLoaderVisible: !1,
	    isVisible: !1,
	    text: "Continue"
	  }),
	  on = /* @__PURE__ */d(() => {
	    const e = pe();
	    return {
	      ...e,
	      backgroundColor: e.backgroundColor || rn() || "#2481cc",
	      textColor: e.textColor || Vr() || "#ffffff"
	    };
	  }),
	  ge = /* @__PURE__ */c(!1),
	  ai = "web_app_setup_main_button",
	  qr = "main_button_pressed",
	  tt = "mainButton",
	  sn = U(tt),
	  ii = Ze(tt, ge);
	  sn("mount", () => {
	    if (!ge()) {
	      const e = x() && k(tt);
	      e && pe.set(e), ge.set(!0);
	    }
	  });
	  sn("onClick", e => w(qr, e));
	  sn("offClick", e => {
	    C(qr, e);
	  });
	  ii("setParams", e => {
	    pe.set({
	      ...pe(),
	      ...jr(e)
	    }), P(tt, pe());
	    const t = on();
	    t.text && _(ai, {
	      color: t.backgroundColor,
	      has_shine_effect: t.hasShineEffect,
	      is_active: t.isEnabled,
	      is_progress_visible: t.isLoaderVisible,
	      is_visible: t.isVisible,
	      text: t.text,
	      text_color: t.textColor
	    });
	  });
	function an() {
	  throw new p(qs, "CSS variables are already bound");
	}
	function _i(e) {
	  return Uo()(e);
	}
	const nt = "themeParams",
	  Ur = "theme_changed",
	  fi = U(nt),
	  mi = Ze(nt, be);
	  mi("bindCssVars", e => {
	    je() && an(), e || (e = r => `--tg-theme-${Lt(r)}`);
	    function t(r) {
	      Object.entries($()).forEach(([o, s]) => {
	        s && r(o, s);
	      });
	    }
	    function n() {
	      t((r, o) => {
	        Vt(e(r), o);
	      });
	    }
	    return n(), $.sub(n), je.set(!0), () => {
	      t(Nt), $.unsub(n), je.set(!1);
	    };
	  });
	  const $r = fi("mount", () => {
	    be() || (w(Ur, Fr), $.set(x() && k(nt) || Y().themeParams), be.set(!0));
	  }),
	  Fr = e => {
	    const t = _i(e.theme_params);
	    $.set(t), P(nt, t);
	  };
	// @__NO_SIDE_EFFECTS__
	function Hr(e) {
	  return /* @__PURE__ */d(() => {
	    const t = e();
	    return _e(t) ? t : t === "bg_color" ? nn() : He();
	  });
	}
	const we = /* @__PURE__ */c("bg_color"),
	  cn = /* @__PURE__ */Hr(we),
	  ye = /* @__PURE__ */c("bottom_bar_bg_color"),
	  un = /* @__PURE__ */d(() => {
	    const e = ye();
	    return _e(e) ? e : e === "bottom_bar_bg_color" ? Nr() || He() : e === "secondary_bg_color" ? He() : nn();
	  }),
	  Se = /* @__PURE__ */c("bg_color"),
	  Wr = /* @__PURE__ */Hr(Se),
	  Ee = /* @__PURE__ */c(!1),
	  Le = /* @__PURE__ */c(!1),
	  rt = /* @__PURE__ */c(!0),
	  zr = /* @__PURE__ */d(() => ({
	    backgroundColor: we(),
	    bottomBarColor: ye(),
	    headerColor: Se(),
	    isActive: rt()
	  })),
	  Pt = "web_app_set_background_color",
	  kt = "web_app_set_bottom_bar_color",
	  Ve = "web_app_set_header_color",
	  Gr = "visibility_changed",
	  ke = "miniApp",
	  pn = {
	    any: [Pt, kt, Ve]
	  },
	  Jr = U(ke),
	  yi = I(ke, pn),
	  ot = Q(ke, Ee, pn);
	  ot("bindCssVars", e => {
	    Le() && an();
	    const [t, n] = ne();
	    function r(o, s) {
	      function a() {
	        Vt(o, s() || null);
	      }
	      a(), t(s.sub(a), Nt.bind(null, o));
	    }
	    return e || (e = o => `--tg-${Lt(o)}`), r(e("bgColor"), cn), r(e("bottomBarColor"), un), r(e("headerColor"), Wr), t(() => {
	      Le.set(!1);
	    }), Le.set(!0), n;
	  });
	  Jr("close", e => {
	    _("web_app_close", {
	      return_back: e
	    });
	  });
	  const Yr = e => {
	    rt.set(e.is_visible), st();
	  };
	  yi("mount", () => {
	    if (!Ee()) {
	      const e = x() && k(ke);
	      $r(), Qr.ifAvailable(e ? e.backgroundColor : "bg_color"), Kr.ifAvailable(e ? e.bottomBarColor : "bottom_bar_bg_color"), Zr.ifAvailable(e ? e.headerColor : "bg_color"), rt.set(e ? e.isActive : !0), w(Gr, Yr), Ee.set(!0);
	    }
	  });
	  Jr("ready", () => {
	    _("web_app_ready");
	  });
	function st() {
	  P(ke, zr());
	}
	const Qr = ot("setBackgroundColor", e => {
	    e !== we() && (_(Pt, {
	      color: e
	    }), we.set(e), st());
	  }, Pt),
	  Kr = ot("setBottomBarColor", e => {
	    e !== ye() && (_(kt, {
	      color: e
	    }), ye.set(e), st());
	  }, kt),
	  Zr = ot("setHeaderColor", e => {
	    e !== Se() && (_(Ve, _e(e) ? {
	      color: e
	    } : {
	      color_key: e
	    }), Se.set(e), st());
	  }, Ve, {
	    rgb: [Ve, "color", _e]
	  });
	function Ri(e) {
	  const t = e.message.trim(),
	    n = (e.title || "").trim(),
	    r = e.buttons || [];
	  if (n.length > 64) throw new p(ce, `Invalid title: ${n}`);
	  if (!t || t.length > 256) throw new p(ce, `Invalid message: ${t}`);
	  if (r.length > 3) throw new p(ce, `Invalid buttons count: ${r.length}`);
	  return {
	    title: n,
	    message: t,
	    buttons: r.length ? r.map((o, s) => {
	      const a = o.id || "";
	      if (a.length > 64) throw new p(ce, `Button with index ${s} has invalid id: ${a}`);
	      if (!o.type || o.type === "default" || o.type === "destructive") {
	        const i = o.text.trim();
	        if (!i || i.length > 64) throw new p(ce, `Button with index ${s} has invalid text: ${i}`);
	        return {
	          type: o.type,
	          text: i,
	          id: a
	        };
	      }
	      return {
	        type: o.type,
	        id: a
	      };
	    }) : [{
	      type: "close",
	      id: ""
	    }]
	  };
	}
	const ln = "web_app_open_popup",
	  Ti = I("popup", ln),
	  Ne = /* @__PURE__ */c(!1);
	  Ti("open", async e => {
	    if (Ne()) throw new p(Wt, "A popup is already opened");
	    Ne.set(!0);
	    try {
	      const {
	        button_id: t = null
	      } = await E(ln, "popup_closed", {
	        ...e,
	        params: Ri(e)
	      });
	      return t;
	    } finally {
	      Ne.set(!1);
	    }
	  });
	  const ki = "web_app_close_scan_qr_popup",
	  dn = "web_app_open_scan_qr_popup",
	  Ii = "scan_qr_popup_closed",
	  Oi = "qr_text_received",
	  Xr = I("qrScanner", dn),
	  It = Xr("close", () => {
	    ee.set(!1), _(ki);
	  }),
	  ee = /* @__PURE__ */c(!1);
	function xi(e) {
	  return b.withFn(t => {
	    if (ee()) throw new p(Wt, "The QR Scanner is already opened");
	    ee.set(!0), e || (e = {});
	    const {
	        onCaptured: n,
	        text: r,
	        capture: o
	      } = e,
	      [, s] = ne(
	      // Whenever the scanner was closed for some reason (by a developer or a
	      // user), we should resolve the promise with undefined.
	      ee.sub(() => {
	        a.resolve();
	      }),
	      // Whenever user closed the scanner, update the isOpened signal state.
	      w(Ii, () => {
	        ee.set(!1);
	      }),
	      // Whenever some QR was scanned, we should check if it must be captured.
	      w(Oi, i => {
	        n ? n(i.data) : (!o || o(i.data)) && (a.resolve(i.data), It());
	      })),
	      a = new is({
	        abortSignal: t
	      }).catch(It).finally(s);
	    return (e.postEvent || _)(dn, {
	      text: r
	    }), a;
	  }, e);
	}
	Xr("open", xi);
	const le = /* @__PURE__ */c({
	    hasShineEffect: !1,
	    isEnabled: !0,
	    isLoaderVisible: !1,
	    isVisible: !1,
	    position: "left",
	    text: "Cancel"
	  }),
	  _n = /* @__PURE__ */d(() => {
	    const e = le();
	    return {
	      ...e,
	      backgroundColor: e.backgroundColor || un() || "#000000",
	      textColor: e.textColor || rn() || "#2481cc"
	    };
	  }),
	  ve = /* @__PURE__ */c(!1),
	  at = "web_app_setup_secondary_button",
	  eo = "secondary_button_pressed",
	  it = "secondaryButton",
	  fn = I(it, at),
	  Hi = Q(it, ve, at);
	  fn("mount", () => {
	    if (!ve()) {
	      const e = x() && k(it);
	      e && le.set(e), ve.set(!0);
	    }
	  });
	  fn("onClick", e => w(eo, e));
	  fn("offClick", e => {
	    C(eo, e);
	  });
	  Hi("setParams", e => {
	    le.set({
	      ...le(),
	      ...Object.fromEntries(Object.entries(e).filter(([, n]) => n !== void 0))
	    }), P(it, le());
	    const t = _n();
	    t.text && _(at, {
	      color: t.backgroundColor,
	      has_shine_effect: t.hasShineEffect,
	      is_active: t.isEnabled,
	      is_progress_visible: t.isLoaderVisible,
	      is_visible: t.isVisible,
	      position: t.position,
	      text: t.text,
	      text_color: t.textColor
	    });
	  });
	const ct = "web_app_setup_settings_button",
	  to = "settings_button_pressed",
	  ut = "settingsButton",
	  Ot = /* @__PURE__ */c(!1),
	  Ae = /* @__PURE__ */c(!1),
	  mn = I(ut, ct),
	  no = Q(ut, Ae, ct);
	  no("hide", () => {
	    hn(!1);
	  });
	  mn("mount", () => {
	    Ae() || (hn(x() && k(ut) || !1), Ae.set(!0));
	  });
	function hn(e) {
	  e !== Ot() && (_(ct, {
	    is_visible: e
	  }), P(ut, e), Ot.set(e));
	}
	mn("onClick", e => w(to, e));
	  mn("offClick", e => {
	    C(to, e);
	  });
	  no("show", () => {
	    hn(!0);
	  });
	const pt = "web_app_setup_swipe_behavior",
	  lt = "swipeBehavior",
	  Ce = /* @__PURE__ */c(!1),
	  Dt = /* @__PURE__ */c(!0),
	  sc = I(lt, pt),
	  ro = Q(lt, Ce, pt);
	  ro("disableVertical", () => {
	    bn(!1);
	  });
	  ro("enableVertical", () => {
	    bn(!0);
	  });
	  sc("mount", () => {
	    Ce() || (bn(x() && k(lt) || !1, !0), Ce.set(!0));
	  });
	function bn(e, t) {
	  (e !== Dt() || t) && (_(pt, {
	    allow_vertical_swipe: e
	  }), P(lt, e), Dt.set(e));
	}
	const se = "viewport",
	  oo = "web_app_request_fullscreen",
	  pc = "fullscreen_failed",
	  gn = "fullscreen_changed",
	  so = "safe_area_changed",
	  ao = "content_safe_area_changed",
	  io = "viewport_changed",
	  jn = "web_app_request_safe_area",
	  Ln = "web_app_request_content_safe_area",
	  Vn = {
	    left: 0,
	    top: 0,
	    bottom: 0,
	    right: 0
	  };
	function wt(e) {
	  return Math.max(e, 0);
	}
	const de = /* @__PURE__ */c({
	  contentSafeAreaInsets: Vn,
	  height: 0,
	  isExpanded: !1,
	  isFullscreen: !1,
	  safeAreaInsets: Vn,
	  stableHeight: 0,
	  width: 0
	});
	function Z(e) {
	  return /* @__PURE__ */d(() => de()[e]);
	}
	function ae(e) {
	  const {
	    height: t,
	    stableHeight: n,
	    width: r
	  } = e;
	  de.set({
	    ...de(),
	    ...jr({
	      ...e,
	      height: t ? wt(t) : void 0,
	      width: r ? wt(r) : void 0,
	      stableHeight: n ? wt(n) : void 0
	    })
	  }), P(se, de());
	}
	function lc() {
	  return k(se);
	}
	const co = Z("isFullscreen"),
	  wn = /* @__PURE__ */c(),
	  uo = /* @__PURE__ */c(),
	  Ie = /* @__PURE__ */c(!1),
	  po = /* @__PURE__ */c(void 0),
	  dt = /* @__PURE__ */c(),
	  fc = Q(se, Ie, oo);
	function lo(e, t) {
	  return fc(e, /* @__PURE__ */Be(n => E(t, [gn, pc], n).then(r => {
	    if ("error" in r) {
	      if (r.error === "ALREADY_FULLSCREEN") return !0;
	      throw new p(Hs, "Fullscreen request failed", r.error);
	    }
	    return r.is_fullscreen;
	  }).then(r => {
	    r !== co() && ae({
	      isFullscreen: r
	    });
	  }), () => new p(F, "Fullscreen mode change is already being requested"), wn, uo));
	}
	lo("requestFullscreen", oo);
	  lo("exitFullscreen", "web_app_exit_fullscreen");
	  const _o = U(se),
	  bc = Ze(se, Ie);
	function _t(e) {
	  return /* @__PURE__ */d(() => yn()[e]);
	}
	const yn = Z("safeAreaInsets"),
	  fo = _t("bottom"),
	  mo = _t("left"),
	  ho = _t("right"),
	  bo = _t("top");
	function ft(e) {
	  return /* @__PURE__ */d(() => Sn()[e]);
	}
	const Sn = Z("contentSafeAreaInsets"),
	  go = ft("bottom"),
	  wo = ft("left"),
	  yo = ft("right"),
	  So = ft("top"),
	  gc = /* @__PURE__ */h("requestContentSafeAreaInsets", e => E(Ln, "content_safe_area_changed", e), {
	    isSupported: Ln
	  }),
	  wc = /* @__PURE__ */h("requestSafeAreaInsets", e => E(jn, "safe_area_changed", e), {
	    isSupported: jn
	  });
	function yc(e) {
	  return E("web_app_request_viewport", "viewport_changed", e).then(t => ({
	    height: t.height,
	    width: t.width,
	    isExpanded: t.is_expanded,
	    isStable: t.is_state_stable
	  }));
	}
	const Eo = e => {
	    const {
	      height: t
	    } = e;
	    ae({
	      isExpanded: e.is_expanded,
	      height: t,
	      width: e.width,
	      stableHeight: e.is_state_stable ? t : void 0
	    });
	  },
	  vo = e => {
	    ae({
	      isFullscreen: e.is_fullscreen
	    });
	  },
	  Ao = e => {
	    ae({
	      safeAreaInsets: e
	    });
	  },
	  Co = e => {
	    ae({
	      contentSafeAreaInsets: e
	    });
	  };
	  _o("mount", /* @__PURE__ */Rr(se, e => b.resolve().then(async () => {
	    const t = x() && lc();
	    if (t) return t;
	    const [n, r] = await b.all([wc.ifAvailable(e) || yn(), gc.ifAvailable(e) || Sn()]),
	      o = Y(),
	      s = {
	        contentSafeAreaInsets: r,
	        isFullscreen: !!o.fullscreen,
	        safeAreaInsets: n
	      };
	    if (["macos", "tdesktop", "unigram", "webk", "weba", "web"].includes(o.platform)) {
	      const a = window;
	      return {
	        ...s,
	        height: a.innerHeight,
	        isExpanded: !0,
	        stableHeight: a.innerHeight,
	        width: a.innerWidth
	      };
	    }
	    return yc(e).then(a => ({
	      ...s,
	      height: a.height,
	      isExpanded: a.isExpanded,
	      stableHeight: a.isStable ? a.height : 0,
	      width: a.width
	    }));
	  }), e => {
	    w(io, Eo), w(gn, vo), w(so, Ao), w(ao, Co), ae(e);
	  }, Ie, dt, po));
	const qe = /* @__PURE__ */c(!1),
	  En = Z("height"),
	  vn = Z("stableHeight"),
	  Ro = Z("width");
	  bc("bindCssVars", e => {
	    qe() && an(), e || (e = n => `--tg-viewport-${Lt(n)}`);
	    const t = [["height", En], ["stableHeight", vn], ["width", Ro], ["safeAreaInsetTop", bo], ["safeAreaInsetBottom", fo], ["safeAreaInsetLeft", mo], ["safeAreaInsetRight", ho], ["contentSafeAreaInsetTop", So], ["contentSafeAreaInsetBottom", go], ["contentSafeAreaInsetLeft", wo], ["contentSafeAreaInsetRight", yo]].reduce((n, [r, o]) => {
	      const s = e(r);
	      if (s) {
	        const a = () => {
	          Vt(s, `${o()}px`);
	        };
	        n.push([a, o.sub(a), s]);
	      }
	      return n;
	    }, []);
	    return t.forEach(n => {
	      n[0]();
	    }), qe.set(!0), () => {
	      t.forEach(n => {
	        n[1](), Nt(n[2]);
	      }), qe.set(!1);
	    };
	  });
	  _o("expand", () => {
	    _("web_app_expand");
	  });
	  const kc = U();
	  kc("openLink", (e, t) => {
	    if (typeof e == "string") try {
	      e = new URL(e);
	    } catch (n) {
	      throw new p(Ht, `"${e.toString()}" is invalid URL`, n);
	    }
	    t || (t = {}), _("web_app_open_link", {
	      url: e.toString(),
	      try_browser: t.tryBrowser,
	      try_instant_view: t.tryInstantView
	    });
	  });
	  const Un = "web_app_open_tg_link",
	  Ic = U(),
	  Oc = Ic("openTelegramLink", e => {
	    const t = e.toString();
	    if (!t.match(/^https:\/\/t.me\/.+/)) throw new p(Ht, `"${t}" is invalid URL`);
	    if (!J(Un, V())) {
	      window.location.href = t;
	      return;
	    }
	    e = new URL(e), _(Un, {
	      path_full: e.pathname + e.search
	    });
	  }),
	  Dc = U();
	  Dc("shareURL", (e, t) => {
	    Oc("https://t.me/share/url?" + new URLSearchParams({
	      url: e,
	      text: t || ""
	    }).toString().replace(/\+/g, "%20"));
	  });
	function Pu() {
	  return reactExports.useMemo(Y, []);
	}

	// Dynamic import for crypto-js's sha256
	const loadSha256 = async () => {
	  const module = await Promise.resolve().then(function () { return sha256$1; });
	  return module.default;
	};

	// // Dynamic import for @othent/kms
	// const loadOthentKms = async () => {
	//   try{
	//     console.log("Entering Dynamic Othent Load")
	//     const module = await import(/* webpackChunkName: "othent-kms" */ '@othent/kms');
	//     console.log("DYNAMICALLY LOADED OTHENT")
	//     return module;
	//   }catch(e){
	//     console.error("Error loading Othent DYnamically : ", e)
	//   }
	// };

	// import Buffer
	function OnairosButton(_ref) {
	  let {
	    requestData,
	    webpageName,
	    inferenceData = null,
	    onComplete = null,
	    autoFetch = true,
	    proofMode = false,
	    textLayout = 'below',
	    textColor = 'white',
	    login = false,
	    buttonType = 'pill',
	    loginReturn = null,
	    loginType = 'signIn',
	    visualType = 'full'
	  } = _ref;
	  const isTelegramMiniApp = () => {
	    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
	    return typeof window.Telegram !== 'undefined' && /telegram/i.test(userAgent) && /mobile/i.test(navigator.userAgent);
	  };
	  const [launchParams, setLaunchParams] = reactExports.useState(null);

	  // Modified useEffect for launch params
	  reactExports.useEffect(() => {
	    let mounted = true;
	    if (isTelegramMiniApp()) {
	      const params = Pu();
	      if (mounted) {
	        setLaunchParams(params);
	      }
	    }
	    return () => {
	      mounted = false;
	    };
	  }, []);

	  // Modified useEffect for handling launch parameters
	  reactExports.useEffect(() => {
	    if (!launchParams) return;
	    console.log('Launch Params:', launchParams);
	    if (launchParams.startParam) {
	      try {
	        setMessage(`Received parameters: ${launchParams.startParam}`);
	        setAuthDialog({
	          show: true,
	          type: 'callback',
	          data: {
	            startParam: launchParams.startParam
	          }
	        });
	      } catch (err) {
	        console.error('Error parsing launch params:', err);
	      }
	    }
	  }, [launchParams]);

	  // Modified Telegram initialization
	  reactExports.useEffect(() => {
	    if (!isTelegramMiniApp()) return;
	    try {
	      const webApp = window.Telegram?.WebApp;
	      if (webApp) {
	        webApp.ready();
	      }
	    } catch (err) {
	      console.error('Error initializing Telegram WebApp:', err);
	    }
	  }, []);
	  reactExports.useState(null);
	  const [showOverlay, setShowOverlay] = reactExports.useState(false);
	  const [activeModels, setActiveModels] = reactExports.useState([]);
	  const [granted, setGranted] = reactExports.useState(0);
	  const [selectedRequests, setSelectedRequests] = reactExports.useState({});
	  const [avatar, setAvatar] = reactExports.useState(false);
	  const [traits, setTraits] = reactExports.useState(false);
	  const [othentUser, setOthentUser] = reactExports.useState(false);
	  const [othentConnected, setOthentConnected] = reactExports.useState(false);
	  const NoAccount = reactExports.useRef(false);
	  const NoModel = reactExports.useRef(false);
	  const [isAuthenticated, setIsAuthenticated] = reactExports.useState(false);
	  const [authToken, setAuthToken] = reactExports.useState(null);
	  const [loading, setLoading] = reactExports.useState(true);
	  const [hashedOthentSub, setHashedOthentSub] = reactExports.useState(null);
	  const [encryptedPin, setEncryptedPin] = reactExports.useState(null);
	  const [authDialog, setAuthDialog] = reactExports.useState({
	    show: false,
	    type: null,
	    data: null
	  });
	  const [accountInfo, setAccountInfo] = reactExports.useState(null);
	  const [isLoading, setIsLoading] = reactExports.useState(false);
	  const [isProcessingAuth, setIsProcessingAuth] = reactExports.useState(false);
	  const hasProcessedCallback = reactExports.useRef(false);
	  const [authError, setAuthError] = reactExports.useState(null);
	  const [notif, setNotif] = reactExports.useState({
	    show: false,
	    color: null,
	    message: null
	  });
	  reactExports.useState(null);
	  const [message, setMessage] = reactExports.useState("Initializing...");

	  // const telegram = useTelegram();
	  // const { webApp } = telegram; 
	  const API_URL = 'https://api2.onairos.uk';
	  // const API_URL = 'http://localhost:8080';

	  // Modified callback handling
	  reactExports.useEffect(() => {
	    if (!isTelegramMiniApp()) return;
	    const handleCallback = async () => {
	      const callbackURL = new URL(window.location.href);
	      const code = callbackURL.searchParams.get("code");
	      const state = callbackURL.searchParams.get("state");
	      if (code && state && !hasProcessedCallback.current && !isProcessingAuth) {
	        hasProcessedCallback.current = true;
	        setIsProcessingAuth(true);
	        try {
	          await completeAuth(callbackURL.toString());
	          setOthentConnected(true);
	          window.history.replaceState({}, document.title, window.location.pathname);
	        } catch (error) {
	          console.error("Auth callback processing failed:", error);
	          setAuthError(error.message);
	        } finally {
	          setIsProcessingAuth(false);
	        }
	      }
	    };
	    handleCallback();
	  }, []);
	  const completeAuth = async callbackURL => {
	    try {
	      const appInfo = {
	        name: "Onairos",
	        version: "1.0.0",
	        env: "production"
	      };
	      setAuthDialog({
	        show: true,
	        type: 'callback',
	        data: {
	          code: callbackURL,
	          state: 'Completing Callback'
	        }
	      });
	      const othent = new Othent({
	        appInfo,
	        throwErrors: true,
	        // Enable error throwing for better error handling
	        auth0LogInMethod: "redirect",
	        auth0RedirectURI: window.location.href,
	        auth0ReturnToURI: window.location.href
	      });
	      // Complete authentication using the callback URL with code and state params
	      // const userDetails = await othent.completeConnectionAfterRedirect(callbackURL);
	      // setAuthDialog({
	      //   show: true,
	      //   type: 'callback',
	      //   data: {
	      //     code: userDetails.email,
	      //     state: 'approved'
	      //   }
	      // });
	      // Add error handling for Othent initialization
	      if (!othent) {
	        throw new Error("Failed to initialize Othent");
	      }
	      if (!userDetails || !userDetails.sub) {
	        throw new Error("Invalid user details received from Othent");
	      }
	      setIsAuthenticated(true);
	      const sha256 = await loadSha256();
	      const hashedOthentSub = sha256(userDetails.sub).toString();
	      setHashedOthentSub(hashedOthentSub);
	      const userOnairosPin = await getPin(hashedOthentSub);
	      setEncryptedPin(userOnairosPin.result);
	      setAuthToken(userOnairosPin.token);
	      // Wait for account info before showing overlay
	      await fetchAccountInfo(userDetails.email, true);
	      setShowOverlay(true);

	      // Store Othent token
	      localStorage.setItem('othentToken', JSON.stringify(userDetails));
	      localStorage.setItem('onairosToken', userDetails.token); // If Othent provides a token
	    } catch (error) {
	      setNotif({
	        show: true,
	        color: 'red',
	        message: 'An error has occured, please try again'
	      });
	      // setAuthDialog({
	      //   show: true,
	      //   type: 'auth',
	      //   data: {
	      //     success: false,
	      //     error: error.message
	      //   }
	      // });
	      console.error("Authentication failed:", error);
	      throw error; // Rethrow for the useEffect to handle
	    }
	  };

	  // Add error display
	  reactExports.useEffect(() => {
	    if (authError) {
	      // Show error to user (implement your error UI here)
	      console.error("Authentication error:", authError);
	    }
	  }, [authError]);
	  const isMobileDevice = () => {
	    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
	    return /android|iphone|ipad|ipod|windows phone/i.test(userAgent);
	  };
	  const findLargestDataObject = arrayOfObjects => {
	    // Update the hierarchy
	    const hierarchy = {
	      'Small': 16,
	      'Medium': 32,
	      'Large': 64
	    };
	    let largestValue = 0;
	    arrayOfObjects.forEach(obj => {
	      const currentValue = hierarchy[obj.data];
	      if (currentValue > largestValue) {
	        largestValue = currentValue;
	      }
	    });
	    return largestValue;
	  };
	  reactExports.useEffect(() => {
	    // Only proceed if autoFetch is true and onComplete is a function
	    if (autoFetch && inferenceData && typeof onComplete === 'function') {
	      const handleAPIResponse = async event => {
	        if (event.data && event.data.source === 'content-script' && event.data.type === 'API_URL_RESPONSE' && event.data.unique === "Onairos-Response") {
	          const {
	            APIurl,
	            approved,
	            accessToken
	          } = event.data;
	          const trimSize = findLargestDataObject(approved);
	          // Trim the data array based on the allowed number of items
	          const trimmedData = inferenceData.slice(0, trimSize);
	          // Fetch the new anime data from the API URL
	          const jsonData = {
	            Input: trimmedData // Your request payload
	          };
	          try {
	            const response = await fetch(APIurl, {
	              method: 'POST',
	              headers: {
	                'Content-Type': 'application/json',
	                'Authorization': `Bearer ${accessToken}`
	              },
	              body: JSON.stringify(jsonData)
	            });
	            const data = await response.json();
	            onComplete(data);
	          } catch (error) {
	            console.error(error);
	            onComplete(null, error);
	          }
	        }
	      };
	      window.addEventListener('message', handleAPIResponse);
	      return () => {
	        window.removeEventListener('message', handleAPIResponse);
	      };
	    }
	  }, []);
	  const handleConnectionSelection = (dataRequester, key, index, type, reward, isSelected) => {
	    setSelectedRequests(prev => ({
	      ...prev,
	      [`${dataRequester}-${key}-${index}`]: {
	        type,
	        reward,
	        isSelected
	      }
	    }));
	  };
	  const changeGranted = value => {
	    setGranted(prev => Math.max(prev + value, 0));
	  };
	  const handleAPIRequestForMobile = async () => {
	    if (isMobileDevice()) {
	      setShowOverlay(true);
	    }
	    return;
	  };
	  const rejectDataRequest = () => {
	    setShowOverlay(false);
	    if (onComplete) {
	      onComplete('rejected');
	    }
	  };
	  const makeApiCall = async (approvedRequests, pin, othentSub) => {
	    const jsonData = {
	      Info: {
	        EncryptedUserPin: pin,
	        confirmations: approvedRequests,
	        web3Type: 'othent',
	        Domain: window.location.href,
	        proofMode: false,
	        OthentSub: othentSub
	      }
	    };
	    try {
	      const response = await fetch('https://api2.onairos.uk/getAPIurl', {
	        // const response = await fetch('http://localhost:8080/getAPIurl', {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify(jsonData)
	      });
	      const data = await response.json();
	      if (autoFetch && onComplete) {
	        onComplete(data);
	      } else {
	        setAuthDialog({
	          show: true,
	          type: 'apiURL',
	          data: {
	            code: data,
	            // Updated from response.body.apiUrl to data.apiUrl
	            state: pin
	          }
	        });
	        // chrome.runtime.sendMessage({
	        //   source: 'dataRequestPage',
	        //   type: 'returnedAPIurl',
	        //   APIurl:response.body.apiUrl,
	        //   accessToken:response.body.token,
	        //   approved:selectedConnections.current,
	        // })
	      }
	    } catch (error) {
	      console.error(error);
	      if (onComplete) {
	        onComplete(null, error);
	      }
	    }
	  };
	  const sendDataRequest = async () => {
	    if (granted <= 0) return;
	    try {
	      // Retrieve approved requests
	      const approvedRequests = Object.values(selectedRequests).filter(req => req.isSelected).map(req => ({
	        type: req.type,
	        reward: req.reward
	      }));
	      if (encryptedPin == null && othentUser && !othentConnected) {
	        setAuthDialog({
	          show: true,
	          type: 'debug',
	          data: {
	            code: 'Connecting Othent Details',
	            state1: encryptedPin,
	            state2: othentConnected,
	            state3: othentUser
	          }
	        });
	        const appInfo = {
	          name: 'Onairos',
	          version: '1.0.0',
	          env: 'production'
	        };
	        const othent = new Othent({
	          appInfo,
	          throwErrors: false
	        });
	        const userDetails = await othent.connect();
	        const sha256 = await loadSha256();
	        const hashedSub = sha256(userDetails.sub).toString();
	        setHashedOthentSub(hashedSub);

	        // Wait for the pin to be retrieved
	        // const userOnairosDetails = await getPin((userDetails.sub).toString());
	        const userOnairosDetails = await getPin(hashedSub);
	        const pin = userOnairosDetails.result;
	        setEncryptedPin(pin);
	        // setAuthToken(userOnairosDetails.token);

	        setOthentConnected(true);
	        setAuthDialog({
	          show: true,
	          type: 'callback',
	          data: {
	            code: 'Just Before API',
	            state: userOnairosDetails.token
	          }
	        });

	        // Make API call with newly retrieved data
	        await makeApiCall(approvedRequests, pin, hashedSub);
	      } else {
	        // Make API call with existing state
	        if (encryptedPin && hashedOthentSub) {
	          await makeApiCall(approvedRequests, encryptedPin, hashedOthentSub);
	        } else {
	          console.error('Missing required authentication data');
	        }
	      }
	    } catch (error) {
	      console.error('Error in sendDataRequest:', error);
	    } finally {
	      setShowOverlay(false);
	    }
	  };
	  const OnairosPublicKey = `
    -----BEGIN PUBLIC KEY-----
    MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4wkWvRPaJiY8CwQ5BoJI
    amcGAYV91Bk8NrvWq4PXM+J/RJugfgTNCYKQ/c6g4xa1YES/tJEzFS7nf0Kdoqxm
    5aav0ru5vS4fc4vCOLTI9W1T7nj02NY91rogsQm2/KMxUQ8DaLeTZKi+0Wjsa9YO
    6XGGd1wh4azgQkj04MWW5J1EBCcBavKoY+C85oA9jkkklQ8nGWgbugmZs7eXHNQb
    qH8/ZHcB9Kx1CZ6XjQuVd6YE/A+swV+DksbkXANcYjr6SY/2TbB8GfpcOMM3bkyN
    Q8e0A51q5a8abfuAkDZXe67MwKMWu/626abwPZhJrKr5HhRZZDwPtnXlktYHhOK6
    lQIDAQAB
    -----END PUBLIC KEY-----
      `;
	  const domain = window.location.href;
	  const openTerminal = async () => {
	    if (isMobileDevice()) {
	      // Testing
	      await handleAPIRequestForMobile();
	      return;
	    }
	    console.log("openTerminal clicked");
	    window.postMessage({
	      source: 'webpage',
	      type: 'openTerminal',
	      webpageName: webpageName,
	      domain: domain,
	      key: "Key"
	    });
	  };
	  reactExports.useEffect(() => {
	    // Listener to receive messages
	    const handleMessage = event => {
	      console.log("Message received in useEffect:", event.data);
	      if (event.data && event.data.action === 'terminalOpened') {
	        ConnectOnairos();
	      }
	    };
	    window.addEventListener('message', handleMessage);
	    return () => {
	      window.removeEventListener('message', handleMessage);
	    };
	  }, []);
	  const ConnectOnairos = async () => {
	    try {
	      const appInfo = {
	        name: "Onairos",
	        version: "1.0.0",
	        env: "production"
	      };
	      const othent = new Othent({
	        appInfo,
	        throwErrors: false
	      });
	      // Get User Othent Secure Details
	      // const { connect} = await loadOthentKms();
	      const userDetails = await othent.connect();
	      const sha256 = await loadSha256();
	      const hashedOthentSub = sha256(userDetails.sub).toString();
	      const encryptedPin = await getPin(hashedOthentSub);
	      console.log("Got your Pin");
	      function convertToBuffer(string) {
	        try {
	          // Decode base64 string
	          const encodedData = window.atob(string);
	          const uint8Array = new Uint8Array(encodedData.length);
	          for (let i = 0; i < encodedData.length; i++) {
	            uint8Array[i] = encodedData.charCodeAt(i);
	          }
	          return uint8Array.buffer; // This is an ArrayBuffer
	        } catch (e) {
	          console.error("Error converting to Buffer :", e);
	        }
	      }
	      const bufferPIN = convertToBuffer(encryptedPin.result);

	      // const {decrypt }= await loadOthentKms();
	      console.log("Decrypting your Pin");
	      const userPin = await othent.decrypt(bufferPIN);
	      console.log("Decrypted Pin");
	      // RSA Encrypt the PIN to transmit to Terminal and backend
	      rsaEncrypt(OnairosPublicKey, userPin).then(encryptedData => {
	        // Prepare the data to be sent
	        window.postMessage({
	          source: 'webpage',
	          type: 'GET_API_URL',
	          webpageName: webpageName,
	          domain: domain,
	          requestData: requestData,
	          proofMode: proofMode,
	          HashedOthentSub: hashedOthentSub,
	          EncryptedUserPin: encryptedData
	        });
	      }).catch(error => {
	        console.error("Encryption failed:", error);
	      });
	    } catch (e) {
	      console.error("Error Sending Data to Terminal: ", e);
	    }
	  };

	  // Styling and button class based on visual type and login mode
	  const buttonClass = `flex items-center justify-center font-bold rounded cursor-pointer ${buttonType === 'pill' ? 'px-4 py-2' : 'w-12 h-12'} ${login ? 'bg-white border border-gray-300' : 'bg-transparent'}
    ${isMobileDevice() ? '' : 'OnairosConnect'}
    `;
	  const buttonStyle = {
	    flexDirection: textLayout === 'below' ? 'column' : 'row',
	    backgroundColor: login ? '#ffffff' : 'transparent',
	    color: login ? 'black' : textColor,
	    border: login ? '1px solid #ddd' : '1px solid transparent'
	  };

	  // Icon and text style based on the visualType
	  const logoStyle = {
	    width: '20px',
	    height: '20px',
	    marginRight: visualType === 'full' ? '12px' : '0' // Space between icon and text only in full mode
	  };
	  const getText = () => {
	    switch (loginType) {
	      case 'signUp':
	        return 'Sign Up with Onairos';
	      case 'signOut':
	        return 'Sign Out of Onairos';
	      default:
	        return 'Sign In with Onairos';
	    }
	  };

	  // Make sure you have this environment variable set

	  const fetchAccountInfo = async function (identifier) {
	    let isEmail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    try {
	      const jsonData = isEmail ? {
	        Info: {
	          identifier: identifier
	        }
	      } : {
	        Info: {
	          userName: identifier
	        }
	      };
	      const endpoint = isEmail ? '/getAccountInfo/email' : '/getAccountInfo';
	      const response = await fetch(`${API_URL}${endpoint}`, {
	        method: 'POST',
	        headers: {
	          'Content-Type': 'application/json',
	          'Authorization': `Bearer ${localStorage.getItem('onairosToken')}`
	        },
	        body: JSON.stringify(jsonData)
	      });
	      if (!response.ok) {
	        throw new Error('Failed to fetch account info');
	      }
	      const data = await response.json();
	      if (data.AccountInfo === "No Account Found") {
	        NoAccount.current = true;
	        setAccountInfo(null);
	        return null;
	      }
	      setAccountInfo(data.AccountInfo);
	      if (data.AccountInfo.models) {
	        setActiveModels(data.AccountInfo.models);
	      } else {
	        NoModel.current = true;
	      }
	      if (data.AccountInfo.avatar) {
	        setAvatar(true);
	      }
	      if (data.AccountInfo.UserTraits) {
	        setTraits(true);
	      }
	      if (data.AccountInfo.othent) {
	        setOthentUser(true);
	      }

	      // // If we have account info and models, show the overlay with data requests
	      // if (data.AccountInfo && data.AccountInfo.models?.length > 0) {
	      //   setShowOverlay(true);
	      // }

	      return data.AccountInfo;
	    } catch (error) {
	      console.error('Error fetching account info:', error);
	      throw error;
	    }
	  };
	  const checkExistingToken = async () => {
	    try {
	      const onairosToken = localStorage.getItem('onairosToken');
	      const legacyToken = localStorage.getItem('token');
	      const token = onairosToken || legacyToken;
	      if (token) {
	        const response = await fetch('https://api2.onairos.uk/verifyToken', {
	          // const response = await fetch('http://localhost:8080/verifyToken', {
	          headers: {
	            'Authorization': `Bearer ${token}`
	          }
	        });
	        if (response.ok) {
	          const data = await response.json();
	          if (data.valid) {
	            setAuthToken(token);
	            setIsAuthenticated(true);
	            const username = localStorage.getItem('username');
	            await fetchAccountInfo(username);
	          } else {
	            localStorage.removeItem('onairosToken');
	            localStorage.removeItem('token');
	          }
	        }
	      }
	    } catch (error) {
	      console.error('Token verification failed:', error);
	    } finally {
	      setLoading(false);
	    }
	  };
	  reactExports.useEffect(() => {
	    if (isMobileDevice()) {
	      checkExistingToken();
	    }
	  }, []);
	  const handleCloseOverlay = () => {
	    setGranted(0);
	    setShowOverlay(false);
	  };

	  // Check for existing token and fetch account info on mount
	  reactExports.useEffect(() => {
	    const token = localStorage.getItem('onairosToken');
	    const username = localStorage.getItem('username');
	    if (token && username) {
	      fetchAccountInfo(username, false);
	    }
	  }, []);
	  const handleLoginSuccess = async function (identifier) {
	    let isEmail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    try {
	      const accountData = await fetchAccountInfo(identifier, isEmail);
	      // Update authentication first
	      setIsAuthenticated(true);
	      // Then update account info
	      setShowOverlay(true);
	      // setAccountInfo(accountData);
	      return accountData;
	    } catch (error) {
	      console.error('Login process failed:', error);
	      throw error;
	    }
	  };

	  // Check for stored tokens on mount
	  reactExports.useEffect(() => {
	    const checkStoredAuth = async () => {
	      const token = localStorage.getItem('onairosToken');
	      const username = localStorage.getItem('username');
	      const othentToken = localStorage.getItem('othentToken');
	      if (token) {
	        try {
	          // Verify token is still valid
	          const response = await fetch(`${API_URL}/verifyToken`, {
	            method: 'POST',
	            headers: {
	              'Content-Type': 'application/json',
	              'Authorization': `Bearer ${token}`
	            }
	          });
	          if (response.ok) {
	            setIsAuthenticated(true);
	            if (username) {
	              await fetchAccountInfo(username, false);
	            } else if (othentToken) {
	              // Handle Othent stored session
	              const userDetails = JSON.parse(othentToken);
	              await fetchAccountInfo(userDetails.email, true);
	            }
	          } else {
	            // Clear invalid tokens
	            localStorage.removeItem('onairosToken');
	            localStorage.removeItem('username');
	            localStorage.removeItem('othentToken');
	          }
	        } catch (error) {
	          console.error('Token verification failed:', error);
	        }
	      }
	    };
	    checkStoredAuth();
	  }, []);
	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/React$1.createElement("div", {
	    className: "flex items-center justify-center"
	  }, /*#__PURE__*/React$1.createElement("button", {
	    className: buttonClass,
	    onClick: openTerminal,
	    style: buttonStyle
	  }, (visualType === 'full' || visualType === 'icon') && /*#__PURE__*/React$1.createElement("img", {
	    src: login ? "https://onairos.sirv.com/Images/OnairosWhite.png" : "https://onairos.sirv.com/Images/OnairosBlack.png",
	    alt: "Onairos Logo",
	    style: logoStyle,
	    className: `${buttonType === 'pill' ? 'w-6 h-6' : 'w-8 h-8'} object-contain`
	  }), (visualType === 'full' || visualType === 'textOnly') && /*#__PURE__*/React$1.createElement("span", {
	    className: `${login ? 'text-black' : textColor === 'black' ? 'text-black' : 'text-white'} ${visualType === 'icon' ? 'sr-only' : ''} ${textLayout === 'right' ? 'ml-2' : textLayout === 'left' ? 'mr-2' : ''}`
	  }, getText()))), authDialog.show &&
	  /*#__PURE__*/
	  // {false && 
	  React$1.createElement("div", {
	    className: "fixed inset-0 z-50 flex items-center justify-center"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "fixed inset-0 bg-black bg-opacity-50",
	    onClick: () => setAuthDialog({
	      show: false,
	      type: null,
	      data: null
	    })
	  }), /*#__PURE__*/React$1.createElement("div", {
	    className: "relative bg-white rounded-lg p-6 max-w-lg w-full mx-4 max-h-[80vh] overflow-y-auto"
	  }, /*#__PURE__*/React$1.createElement("button", {
	    onClick: () => setAuthDialog({
	      show: false,
	      type: null,
	      data: null
	    }),
	    className: "absolute top-4 right-4 text-gray-400 hover:text-gray-600"
	  }, /*#__PURE__*/React$1.createElement("span", {
	    className: "sr-only"
	  }, "Close"), /*#__PURE__*/React$1.createElement("svg", {
	    className: "h-6 w-6",
	    fill: "none",
	    viewBox: "0 0 24 24",
	    stroke: "currentColor"
	  }, /*#__PURE__*/React$1.createElement("path", {
	    strokeLinecap: "round",
	    strokeLinejoin: "round",
	    strokeWidth: 2,
	    d: "M6 18L18 6M6 6l12 12"
	  }))), /*#__PURE__*/React$1.createElement("h3", {
	    className: "text-lg font-semibold mb-4"
	  }, authDialog.type === 'callback' ? 'Callback Details' : 'Authentication Result'), /*#__PURE__*/React$1.createElement("h3", {
	    className: "text-lg font-semibold mb-4"
	  }, authDialog.type === 'debug' ? 'Debug Results' : 'Authentication Result'), /*#__PURE__*/React$1.createElement("h3", {
	    className: "text-lg font-semibold mb-4"
	  }, authDialog.type === 'apiURL' ? 'API Url Returned' : 'Authentication Result'), /*#__PURE__*/React$1.createElement("div", {
	    className: "bg-gray-50 rounded p-4 overflow-x-auto"
	  }, /*#__PURE__*/React$1.createElement("pre", {
	    className: "text-sm"
	  }, JSON.stringify(authDialog.data, null, 2))), authDialog.type === 'auth' && /*#__PURE__*/React$1.createElement("div", {
	    className: `mt-4 p-3 rounded ${authDialog.data?.success ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`
	  }, authDialog.data?.success ? 'Authentication successful!' : 'Authentication failed'))), isLoading && /*#__PURE__*/React$1.createElement("div", {
	    className: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "bg-white p-6 rounded-lg shadow-xl"
	  }, /*#__PURE__*/React$1.createElement("div", {
	    className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500 mx-auto"
	  }), /*#__PURE__*/React$1.createElement("p", {
	    className: "mt-4 text-gray-600"
	  }, "Loading your account..."))), showOverlay && !isLoading && /*#__PURE__*/React$1.createElement(Overlay, {
	    setOthentConnected: setOthentConnected,
	    dataRequester: webpageName,
	    NoAccount: NoAccount,
	    NoModel: NoModel,
	    accountInfo: accountInfo,
	    activeModels: activeModels,
	    avatar: avatar,
	    traits: traits,
	    requestData: requestData,
	    handleConnectionSelection: handleConnectionSelection,
	    changeGranted: changeGranted,
	    granted: granted,
	    allowSubmit: granted > 0,
	    rejectDataRequest: rejectDataRequest,
	    sendDataRequest: sendDataRequest,
	    isAuthenticated: isAuthenticated,
	    onLoginSuccess: handleLoginSuccess,
	    onClose: handleCloseOverlay,
	    setOthentUser: setOthentUser,
	    setHashedOthentSub: setHashedOthentSub,
	    setEncryptedPin: setEncryptedPin
	  }));
	}

	// Configuration object for the Telegram SDK

	function Onairos(props) {
	  return /*#__PURE__*/React$1.createElement(React$1.Fragment, null, /*#__PURE__*/React$1.createElement(OnairosButton, props));
	}

	var sha256$3 = {exports: {}};

	function commonjsRequire(path) {
		throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
	}

	var core$1 = {exports: {}};

	var _nodeResolve_empty = {};

	var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': _nodeResolve_empty
	});

	var require$$0 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(_nodeResolve_empty$1);

	var core = core$1.exports;

	var hasRequiredCore;

	function requireCore () {
		if (hasRequiredCore) return core$1.exports;
		hasRequiredCore = 1;
		(function (module, exports) {
			(function (root, factory) {
			  {
			    // CommonJS
			    module.exports = factory();
			  }
			})(core, function () {
			  /*globals window, global, require*/

			  /**
			   * CryptoJS core components.
			   */
			  var CryptoJS = CryptoJS || function (Math, undefined$1) {
			    var crypto;

			    // Native crypto from window (Browser)
			    if (typeof window !== 'undefined' && window.crypto) {
			      crypto = window.crypto;
			    }

			    // Native crypto in web worker (Browser)
			    if (typeof self !== 'undefined' && self.crypto) {
			      crypto = self.crypto;
			    }

			    // Native crypto from worker
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			      crypto = globalThis.crypto;
			    }

			    // Native (experimental IE 11) crypto from window (Browser)
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			      crypto = window.msCrypto;
			    }

			    // Native crypto from global (NodeJS)
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			      crypto = commonjsGlobal.crypto;
			    }

			    // Native crypto import via require (NodeJS)
			    if (!crypto && typeof commonjsRequire === 'function') {
			      try {
			        crypto = require$$0;
			      } catch (err) {}
			    }

			    /*
			     * Cryptographically secure pseudorandom number generator
			     *
			     * As Math.random() is cryptographically not safe to use
			     */
			    var cryptoSecureRandomInt = function () {
			      if (crypto) {
			        // Use getRandomValues method (Browser)
			        if (typeof crypto.getRandomValues === 'function') {
			          try {
			            return crypto.getRandomValues(new Uint32Array(1))[0];
			          } catch (err) {}
			        }

			        // Use randomBytes method (NodeJS)
			        if (typeof crypto.randomBytes === 'function') {
			          try {
			            return crypto.randomBytes(4).readInt32LE();
			          } catch (err) {}
			        }
			      }
			      throw new Error('Native crypto module could not be used to get secure random number.');
			    };

			    /*
			     * Local polyfill of Object.create
			      */
			    var create = Object.create || function () {
			      function F() {}
			      return function (obj) {
			        var subtype;
			        F.prototype = obj;
			        subtype = new F();
			        F.prototype = null;
			        return subtype;
			      };
			    }();

			    /**
			     * CryptoJS namespace.
			     */
			    var C = {};

			    /**
			     * Library namespace.
			     */
			    var C_lib = C.lib = {};

			    /**
			     * Base object for prototypal inheritance.
			     */
			    var Base = C_lib.Base = function () {
			      return {
			        /**
			         * Creates a new object that inherits from this object.
			         *
			         * @param {Object} overrides Properties to copy into the new object.
			         *
			         * @return {Object} The new object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var MyType = CryptoJS.lib.Base.extend({
			         *         field: 'value',
			         *
			         *         method: function () {
			         *         }
			         *     });
			         */
			        extend: function (overrides) {
			          // Spawn
			          var subtype = create(this);

			          // Augment
			          if (overrides) {
			            subtype.mixIn(overrides);
			          }

			          // Create default initializer
			          if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			            subtype.init = function () {
			              subtype.$super.init.apply(this, arguments);
			            };
			          }

			          // Initializer's prototype is the subtype object
			          subtype.init.prototype = subtype;

			          // Reference supertype
			          subtype.$super = this;
			          return subtype;
			        },
			        /**
			         * Extends this object and runs the init method.
			         * Arguments to create() will be passed to init().
			         *
			         * @return {Object} The new object.
			         *
			         * @static
			         *
			         * @example
			         *
			         *     var instance = MyType.create();
			         */
			        create: function () {
			          var instance = this.extend();
			          instance.init.apply(instance, arguments);
			          return instance;
			        },
			        /**
			         * Initializes a newly created object.
			         * Override this method to add some logic when your objects are created.
			         *
			         * @example
			         *
			         *     var MyType = CryptoJS.lib.Base.extend({
			         *         init: function () {
			         *             // ...
			         *         }
			         *     });
			         */
			        init: function () {},
			        /**
			         * Copies properties into this object.
			         *
			         * @param {Object} properties The properties to mix in.
			         *
			         * @example
			         *
			         *     MyType.mixIn({
			         *         field: 'value'
			         *     });
			         */
			        mixIn: function (properties) {
			          for (var propertyName in properties) {
			            if (properties.hasOwnProperty(propertyName)) {
			              this[propertyName] = properties[propertyName];
			            }
			          }

			          // IE won't copy toString using the loop above
			          if (properties.hasOwnProperty('toString')) {
			            this.toString = properties.toString;
			          }
			        },
			        /**
			         * Creates a copy of this object.
			         *
			         * @return {Object} The clone.
			         *
			         * @example
			         *
			         *     var clone = instance.clone();
			         */
			        clone: function () {
			          return this.init.prototype.extend(this);
			        }
			      };
			    }();

			    /**
			     * An array of 32-bit words.
			     *
			     * @property {Array} words The array of 32-bit words.
			     * @property {number} sigBytes The number of significant bytes in this word array.
			     */
			    var WordArray = C_lib.WordArray = Base.extend({
			      /**
			       * Initializes a newly created word array.
			       *
			       * @param {Array} words (Optional) An array of 32-bit words.
			       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
			       *
			       * @example
			       *
			       *     var wordArray = CryptoJS.lib.WordArray.create();
			       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
			       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
			       */
			      init: function (words, sigBytes) {
			        words = this.words = words || [];
			        if (sigBytes != undefined$1) {
			          this.sigBytes = sigBytes;
			        } else {
			          this.sigBytes = words.length * 4;
			        }
			      },
			      /**
			       * Converts this word array to a string.
			       *
			       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
			       *
			       * @return {string} The stringified word array.
			       *
			       * @example
			       *
			       *     var string = wordArray + '';
			       *     var string = wordArray.toString();
			       *     var string = wordArray.toString(CryptoJS.enc.Utf8);
			       */
			      toString: function (encoder) {
			        return (encoder || Hex).stringify(this);
			      },
			      /**
			       * Concatenates a word array to this word array.
			       *
			       * @param {WordArray} wordArray The word array to append.
			       *
			       * @return {WordArray} This word array.
			       *
			       * @example
			       *
			       *     wordArray1.concat(wordArray2);
			       */
			      concat: function (wordArray) {
			        // Shortcuts
			        var thisWords = this.words;
			        var thatWords = wordArray.words;
			        var thisSigBytes = this.sigBytes;
			        var thatSigBytes = wordArray.sigBytes;

			        // Clamp excess bits
			        this.clamp();

			        // Concat
			        if (thisSigBytes % 4) {
			          // Copy one byte at a time
			          for (var i = 0; i < thatSigBytes; i++) {
			            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
			            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
			          }
			        } else {
			          // Copy one word at a time
			          for (var j = 0; j < thatSigBytes; j += 4) {
			            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
			          }
			        }
			        this.sigBytes += thatSigBytes;

			        // Chainable
			        return this;
			      },
			      /**
			       * Removes insignificant bits.
			       *
			       * @example
			       *
			       *     wordArray.clamp();
			       */
			      clamp: function () {
			        // Shortcuts
			        var words = this.words;
			        var sigBytes = this.sigBytes;

			        // Clamp
			        words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
			        words.length = Math.ceil(sigBytes / 4);
			      },
			      /**
			       * Creates a copy of this word array.
			       *
			       * @return {WordArray} The clone.
			       *
			       * @example
			       *
			       *     var clone = wordArray.clone();
			       */
			      clone: function () {
			        var clone = Base.clone.call(this);
			        clone.words = this.words.slice(0);
			        return clone;
			      },
			      /**
			       * Creates a word array filled with random bytes.
			       *
			       * @param {number} nBytes The number of random bytes to generate.
			       *
			       * @return {WordArray} The random word array.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var wordArray = CryptoJS.lib.WordArray.random(16);
			       */
			      random: function (nBytes) {
			        var words = [];
			        for (var i = 0; i < nBytes; i += 4) {
			          words.push(cryptoSecureRandomInt());
			        }
			        return new WordArray.init(words, nBytes);
			      }
			    });

			    /**
			     * Encoder namespace.
			     */
			    var C_enc = C.enc = {};

			    /**
			     * Hex encoding strategy.
			     */
			    var Hex = C_enc.Hex = {
			      /**
			       * Converts a word array to a hex string.
			       *
			       * @param {WordArray} wordArray The word array.
			       *
			       * @return {string} The hex string.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
			       */
			      stringify: function (wordArray) {
			        // Shortcuts
			        var words = wordArray.words;
			        var sigBytes = wordArray.sigBytes;

			        // Convert
			        var hexChars = [];
			        for (var i = 0; i < sigBytes; i++) {
			          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
			          hexChars.push((bite >>> 4).toString(16));
			          hexChars.push((bite & 0x0f).toString(16));
			        }
			        return hexChars.join('');
			      },
			      /**
			       * Converts a hex string to a word array.
			       *
			       * @param {string} hexStr The hex string.
			       *
			       * @return {WordArray} The word array.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
			       */
			      parse: function (hexStr) {
			        // Shortcut
			        var hexStrLength = hexStr.length;

			        // Convert
			        var words = [];
			        for (var i = 0; i < hexStrLength; i += 2) {
			          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
			        }
			        return new WordArray.init(words, hexStrLength / 2);
			      }
			    };

			    /**
			     * Latin1 encoding strategy.
			     */
			    var Latin1 = C_enc.Latin1 = {
			      /**
			       * Converts a word array to a Latin1 string.
			       *
			       * @param {WordArray} wordArray The word array.
			       *
			       * @return {string} The Latin1 string.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
			       */
			      stringify: function (wordArray) {
			        // Shortcuts
			        var words = wordArray.words;
			        var sigBytes = wordArray.sigBytes;

			        // Convert
			        var latin1Chars = [];
			        for (var i = 0; i < sigBytes; i++) {
			          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
			          latin1Chars.push(String.fromCharCode(bite));
			        }
			        return latin1Chars.join('');
			      },
			      /**
			       * Converts a Latin1 string to a word array.
			       *
			       * @param {string} latin1Str The Latin1 string.
			       *
			       * @return {WordArray} The word array.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
			       */
			      parse: function (latin1Str) {
			        // Shortcut
			        var latin1StrLength = latin1Str.length;

			        // Convert
			        var words = [];
			        for (var i = 0; i < latin1StrLength; i++) {
			          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
			        }
			        return new WordArray.init(words, latin1StrLength);
			      }
			    };

			    /**
			     * UTF-8 encoding strategy.
			     */
			    var Utf8 = C_enc.Utf8 = {
			      /**
			       * Converts a word array to a UTF-8 string.
			       *
			       * @param {WordArray} wordArray The word array.
			       *
			       * @return {string} The UTF-8 string.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
			       */
			      stringify: function (wordArray) {
			        try {
			          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			        } catch (e) {
			          throw new Error('Malformed UTF-8 data');
			        }
			      },
			      /**
			       * Converts a UTF-8 string to a word array.
			       *
			       * @param {string} utf8Str The UTF-8 string.
			       *
			       * @return {WordArray} The word array.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
			       */
			      parse: function (utf8Str) {
			        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			      }
			    };

			    /**
			     * Abstract buffered block algorithm template.
			     *
			     * The property blockSize must be implemented in a concrete subtype.
			     *
			     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
			     */
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			      /**
			       * Resets this block algorithm's data buffer to its initial state.
			       *
			       * @example
			       *
			       *     bufferedBlockAlgorithm.reset();
			       */
			      reset: function () {
			        // Initial values
			        this._data = new WordArray.init();
			        this._nDataBytes = 0;
			      },
			      /**
			       * Adds new data to this block algorithm's buffer.
			       *
			       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
			       *
			       * @example
			       *
			       *     bufferedBlockAlgorithm._append('data');
			       *     bufferedBlockAlgorithm._append(wordArray);
			       */
			      _append: function (data) {
			        // Convert string to WordArray, else assume WordArray already
			        if (typeof data == 'string') {
			          data = Utf8.parse(data);
			        }

			        // Append
			        this._data.concat(data);
			        this._nDataBytes += data.sigBytes;
			      },
			      /**
			       * Processes available data blocks.
			       *
			       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
			       *
			       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
			       *
			       * @return {WordArray} The processed data.
			       *
			       * @example
			       *
			       *     var processedData = bufferedBlockAlgorithm._process();
			       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
			       */
			      _process: function (doFlush) {
			        var processedWords;

			        // Shortcuts
			        var data = this._data;
			        var dataWords = data.words;
			        var dataSigBytes = data.sigBytes;
			        var blockSize = this.blockSize;
			        var blockSizeBytes = blockSize * 4;

			        // Count blocks ready
			        var nBlocksReady = dataSigBytes / blockSizeBytes;
			        if (doFlush) {
			          // Round up to include partial blocks
			          nBlocksReady = Math.ceil(nBlocksReady);
			        } else {
			          // Round down to include only full blocks,
			          // less the number of blocks that must remain in the buffer
			          nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			        }

			        // Count words ready
			        var nWordsReady = nBlocksReady * blockSize;

			        // Count bytes ready
			        var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

			        // Process blocks
			        if (nWordsReady) {
			          for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			            // Perform concrete-algorithm logic
			            this._doProcessBlock(dataWords, offset);
			          }

			          // Remove processed words
			          processedWords = dataWords.splice(0, nWordsReady);
			          data.sigBytes -= nBytesReady;
			        }

			        // Return processed words
			        return new WordArray.init(processedWords, nBytesReady);
			      },
			      /**
			       * Creates a copy of this object.
			       *
			       * @return {Object} The clone.
			       *
			       * @example
			       *
			       *     var clone = bufferedBlockAlgorithm.clone();
			       */
			      clone: function () {
			        var clone = Base.clone.call(this);
			        clone._data = this._data.clone();
			        return clone;
			      },
			      _minBufferSize: 0
			    });

			    /**
			     * Abstract hasher template.
			     *
			     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
			     */
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			      /**
			       * Configuration options.
			       */
			      cfg: Base.extend(),
			      /**
			       * Initializes a newly created hasher.
			       *
			       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
			       *
			       * @example
			       *
			       *     var hasher = CryptoJS.algo.SHA256.create();
			       */
			      init: function (cfg) {
			        // Apply config defaults
			        this.cfg = this.cfg.extend(cfg);

			        // Set initial values
			        this.reset();
			      },
			      /**
			       * Resets this hasher to its initial state.
			       *
			       * @example
			       *
			       *     hasher.reset();
			       */
			      reset: function () {
			        // Reset data buffer
			        BufferedBlockAlgorithm.reset.call(this);

			        // Perform concrete-hasher logic
			        this._doReset();
			      },
			      /**
			       * Updates this hasher with a message.
			       *
			       * @param {WordArray|string} messageUpdate The message to append.
			       *
			       * @return {Hasher} This hasher.
			       *
			       * @example
			       *
			       *     hasher.update('message');
			       *     hasher.update(wordArray);
			       */
			      update: function (messageUpdate) {
			        // Append
			        this._append(messageUpdate);

			        // Update the hash
			        this._process();

			        // Chainable
			        return this;
			      },
			      /**
			       * Finalizes the hash computation.
			       * Note that the finalize operation is effectively a destructive, read-once operation.
			       *
			       * @param {WordArray|string} messageUpdate (Optional) A final message update.
			       *
			       * @return {WordArray} The hash.
			       *
			       * @example
			       *
			       *     var hash = hasher.finalize();
			       *     var hash = hasher.finalize('message');
			       *     var hash = hasher.finalize(wordArray);
			       */
			      finalize: function (messageUpdate) {
			        // Final message update
			        if (messageUpdate) {
			          this._append(messageUpdate);
			        }

			        // Perform concrete-hasher logic
			        var hash = this._doFinalize();
			        return hash;
			      },
			      blockSize: 512 / 32,
			      /**
			       * Creates a shortcut function to a hasher's object interface.
			       *
			       * @param {Hasher} hasher The hasher to create a helper for.
			       *
			       * @return {Function} The shortcut function.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
			       */
			      _createHelper: function (hasher) {
			        return function (message, cfg) {
			          return new hasher.init(cfg).finalize(message);
			        };
			      },
			      /**
			       * Creates a shortcut function to the HMAC's object interface.
			       *
			       * @param {Hasher} hasher The hasher to use in this HMAC helper.
			       *
			       * @return {Function} The shortcut function.
			       *
			       * @static
			       *
			       * @example
			       *
			       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
			       */
			      _createHmacHelper: function (hasher) {
			        return function (message, key) {
			          return new C_algo.HMAC.init(hasher, key).finalize(message);
			        };
			      }
			    });

			    /**
			     * Algorithm namespace.
			     */
			    var C_algo = C.algo = {};
			    return C;
			  }(Math);
			  return CryptoJS;
			}); 
		} (core$1, core$1.exports));
		return core$1.exports;
	}

	var sha256$2 = sha256$3.exports;

	var hasRequiredSha256;

	function requireSha256 () {
		if (hasRequiredSha256) return sha256$3.exports;
		hasRequiredSha256 = 1;
		(function (module, exports) {
			(function (root, factory) {
			  {
			    // CommonJS
			    module.exports = factory(requireCore());
			  }
			})(sha256$2, function (CryptoJS) {
			  (function (Math) {
			    // Shortcuts
			    var C = CryptoJS;
			    var C_lib = C.lib;
			    var WordArray = C_lib.WordArray;
			    var Hasher = C_lib.Hasher;
			    var C_algo = C.algo;

			    // Initialization and round constants tables
			    var H = [];
			    var K = [];

			    // Compute constants
			    (function () {
			      function isPrime(n) {
			        var sqrtN = Math.sqrt(n);
			        for (var factor = 2; factor <= sqrtN; factor++) {
			          if (!(n % factor)) {
			            return false;
			          }
			        }
			        return true;
			      }
			      function getFractionalBits(n) {
			        return (n - (n | 0)) * 0x100000000 | 0;
			      }
			      var n = 2;
			      var nPrime = 0;
			      while (nPrime < 64) {
			        if (isPrime(n)) {
			          if (nPrime < 8) {
			            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
			          }
			          K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
			          nPrime++;
			        }
			        n++;
			      }
			    })();

			    // Reusable object
			    var W = [];

			    /**
			     * SHA-256 hash algorithm.
			     */
			    var SHA256 = C_algo.SHA256 = Hasher.extend({
			      _doReset: function () {
			        this._hash = new WordArray.init(H.slice(0));
			      },
			      _doProcessBlock: function (M, offset) {
			        // Shortcut
			        var H = this._hash.words;

			        // Working variables
			        var a = H[0];
			        var b = H[1];
			        var c = H[2];
			        var d = H[3];
			        var e = H[4];
			        var f = H[5];
			        var g = H[6];
			        var h = H[7];

			        // Computation
			        for (var i = 0; i < 64; i++) {
			          if (i < 16) {
			            W[i] = M[offset + i] | 0;
			          } else {
			            var gamma0x = W[i - 15];
			            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
			            var gamma1x = W[i - 2];
			            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
			            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
			          }
			          var ch = e & f ^ ~e & g;
			          var maj = a & b ^ a & c ^ b & c;
			          var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
			          var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
			          var t1 = h + sigma1 + ch + K[i] + W[i];
			          var t2 = sigma0 + maj;
			          h = g;
			          g = f;
			          f = e;
			          e = d + t1 | 0;
			          d = c;
			          c = b;
			          b = a;
			          a = t1 + t2 | 0;
			        }

			        // Intermediate hash value
			        H[0] = H[0] + a | 0;
			        H[1] = H[1] + b | 0;
			        H[2] = H[2] + c | 0;
			        H[3] = H[3] + d | 0;
			        H[4] = H[4] + e | 0;
			        H[5] = H[5] + f | 0;
			        H[6] = H[6] + g | 0;
			        H[7] = H[7] + h | 0;
			      },
			      _doFinalize: function () {
			        // Shortcuts
			        var data = this._data;
			        var dataWords = data.words;
			        var nBitsTotal = this._nDataBytes * 8;
			        var nBitsLeft = data.sigBytes * 8;

			        // Add padding
			        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
			        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
			        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
			        data.sigBytes = dataWords.length * 4;

			        // Hash final blocks
			        this._process();

			        // Return final computed hash
			        return this._hash;
			      },
			      clone: function () {
			        var clone = Hasher.clone.call(this);
			        clone._hash = this._hash.clone();
			        return clone;
			      }
			    });

			    /**
			     * Shortcut function to the hasher's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     *
			     * @return {WordArray} The hash.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hash = CryptoJS.SHA256('message');
			     *     var hash = CryptoJS.SHA256(wordArray);
			     */
			    C.SHA256 = Hasher._createHelper(SHA256);

			    /**
			     * Shortcut function to the HMAC's object interface.
			     *
			     * @param {WordArray|string} message The message to hash.
			     * @param {WordArray|string} key The secret key.
			     *
			     * @return {WordArray} The HMAC.
			     *
			     * @static
			     *
			     * @example
			     *
			     *     var hmac = CryptoJS.HmacSHA256(message, key);
			     */
			    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
			  })(Math);
			  return CryptoJS.SHA256;
			}); 
		} (sha256$3, sha256$3.exports));
		return sha256$3.exports;
	}

	var sha256Exports = requireSha256();
	var sha256 = /*@__PURE__*/getDefaultExportFromCjs(sha256Exports);

	var sha256$1 = /*#__PURE__*/_mergeNamespaces({
		__proto__: null,
		'default': sha256
	}, [sha256Exports]);

	exports.Onairos = Onairos;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=onairos.umd.js.map
