{"version":3,"file":"RSA.js","names":["pemToBuffer","pem","base64String","replace","binaryString","window","atob","bytes","Uint8Array","length","i","charCodeAt","buffer","rsaEncrypt","publicKeyPem","data","publicKeyBuffer","importedKey","crypto","subtle","importKey","name","hash","encrypted","encrypt","TextEncoder","encode","bufferToBase64","error","console","binary","len","byteLength","String","fromCharCode","btoa","e"],"sources":["../src/RSA.jsx"],"sourcesContent":["// Function to convert PEM encoded public key to a format usable by the Web Crypto API\r\nfunction pemToBuffer(pem) {\r\n    // Remove the first and last lines (headers), and all line breaks\r\n    const base64String = pem\r\n        .replace(/-----BEGIN PUBLIC KEY-----/, '')\r\n        .replace(/-----END PUBLIC KEY-----/, '')\r\n        .replace(/\\s/g, '');  // remove all whitespace, not just line breaks\r\n    const binaryString = window.atob(base64String);\r\n    const bytes = new Uint8Array(binaryString.length);\r\n    for (let i = 0; i < binaryString.length; i++) {\r\n        bytes[i] = binaryString.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n}\r\n\r\n// Function to encrypt data using RSA\r\nexport async function rsaEncrypt(publicKeyPem, data) {\r\n    try {\r\n        const publicKeyBuffer = pemToBuffer(publicKeyPem);\r\n        const importedKey = await window.crypto.subtle.importKey(\r\n            'spki',\r\n            publicKeyBuffer,\r\n            {\r\n                name: 'RSA-OAEP',\r\n                hash: {name: 'SHA-256'}\r\n            },\r\n            true,\r\n            ['encrypt']\r\n        );\r\n        const encrypted = await window.crypto.subtle.encrypt(\r\n            { name: 'RSA-OAEP' },\r\n            importedKey,\r\n            new TextEncoder().encode(data)\r\n        );\r\n        return bufferToBase64(encrypted);\r\n    } catch (error) {\r\n        console.error(\"rsaEncrypt error:\", error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Function to convert ArrayBuffer to Base64\r\nfunction bufferToBase64(buffer) {\r\n    try{\r\n        let binary = '';\r\n        const bytes = new Uint8Array(buffer);\r\n        const len = bytes.byteLength;\r\n        for (let i = 0; i < len; i++) {\r\n            binary += String.fromCharCode(bytes[i]);\r\n        }\r\n        return window.btoa(binary);\r\n    }catch(e){\r\n        console.error(\"Eror in buffertoBase64 : \", e)\r\n    }\r\n}\r\n\r\n\r\n"],"mappings":";;;;;;AAAA;AACA,SAASA,WAAWA,CAACC,GAAG,EAAE;EACtB;EACA,MAAMC,YAAY,GAAGD,GAAG,CACnBE,OAAO,CAAC,4BAA4B,EAAE,EAAE,CAAC,CACzCA,OAAO,CAAC,0BAA0B,EAAE,EAAE,CAAC,CACvCA,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAE;EAC1B,MAAMC,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACJ,YAAY,CAAC;EAC9C,MAAMK,KAAK,GAAG,IAAIC,UAAU,CAACJ,YAAY,CAACK,MAAM,CAAC;EACjD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,YAAY,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;IAC1CH,KAAK,CAACG,CAAC,CAAC,GAAGN,YAAY,CAACO,UAAU,CAACD,CAAC,CAAC;EACzC;EACA,OAAOH,KAAK,CAACK,MAAM;AACvB;;AAEA;AACO,eAAeC,UAAUA,CAACC,YAAY,EAAEC,IAAI,EAAE;EACjD,IAAI;IACA,MAAMC,eAAe,GAAGhB,WAAW,CAACc,YAAY,CAAC;IACjD,MAAMG,WAAW,GAAG,MAAMZ,MAAM,CAACa,MAAM,CAACC,MAAM,CAACC,SAAS,CACpD,MAAM,EACNJ,eAAe,EACf;MACIK,IAAI,EAAE,UAAU;MAChBC,IAAI,EAAE;QAACD,IAAI,EAAE;MAAS;IAC1B,CAAC,EACD,IAAI,EACJ,CAAC,SAAS,CACd,CAAC;IACD,MAAME,SAAS,GAAG,MAAMlB,MAAM,CAACa,MAAM,CAACC,MAAM,CAACK,OAAO,CAChD;MAAEH,IAAI,EAAE;IAAW,CAAC,EACpBJ,WAAW,EACX,IAAIQ,WAAW,CAAC,CAAC,CAACC,MAAM,CAACX,IAAI,CACjC,CAAC;IACD,OAAOY,cAAc,CAACJ,SAAS,CAAC;EACpC,CAAC,CAAC,OAAOK,KAAK,EAAE;IACZC,OAAO,CAACD,KAAK,CAAC,mBAAmB,EAAEA,KAAK,CAAC;IACzC,OAAO,IAAI;EACf;AACJ;;AAEA;AACA,SAASD,cAAcA,CAACf,MAAM,EAAE;EAC5B,IAAG;IACC,IAAIkB,MAAM,GAAG,EAAE;IACf,MAAMvB,KAAK,GAAG,IAAIC,UAAU,CAACI,MAAM,CAAC;IACpC,MAAMmB,GAAG,GAAGxB,KAAK,CAACyB,UAAU;IAC5B,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,GAAG,EAAErB,CAAC,EAAE,EAAE;MAC1BoB,MAAM,IAAIG,MAAM,CAACC,YAAY,CAAC3B,KAAK,CAACG,CAAC,CAAC,CAAC;IAC3C;IACA,OAAOL,MAAM,CAAC8B,IAAI,CAACL,MAAM,CAAC;EAC9B,CAAC,QAAMM,CAAC,EAAC;IACLP,OAAO,CAACD,KAAK,CAAC,2BAA2B,EAAEQ,CAAC,CAAC;EACjD;AACJ"}